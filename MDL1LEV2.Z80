;
; ======================================================================
;        TRS-80 Model I Level II BASIC ROM - (Disassembled)
;
;     Source Code Created By : kiwisincebirth - 2025
;     [https://github.com/kiwisincebirth/TRS-80]
;
; ======================================================================
;     NOTE: this code has been formatted with 8 spaces per tab
; ----------------------------------------------------------------------
; Rom Version Definition
; #DEFINE VER13   ; Set by Default if VER12 is not defined, dont uncomment
; #DEFINE VER12	  ; Uncomment for V1.2, Leave Commented for V1.3
; #DEFINE EACA80  ; Uncomment to enable System-80 (EACA) hardware support
;
; Version 1.3 - 80/02
; Date: 01/07/80-01/13/80
; CRC-32: A8E60D9A

; Version 1.2 - 79/12
; Date: 03/19/78 - 03/25/79
; CRC-32: 0D8A132E
;
; Rom Bug Fixes
; #DEFINE BUGFIX5 ; Uncomment to Fix Error 5 - 08A7H - INT(DoubleValue) rounding
; #DEFINE BUGFIX8 ; Uncomment to Fix Error 8 - 1009H - PRINT USING, - sign at end of field
;
; Rom Additional Features
; #DEFINE NMIHARD ; Uncomment to set NMI Reset as always hard reset. (0066h)
; #DEFINE LOWCASE ; Uncomment to Disable Alpha Character Translation (0471h)
; #DEFINE FASTMEM ; Uncomment to enable Fast Memory Size Check (00C4)
; #DEFINE FREHDBT ; Uncomment to enable FreHD Auto boot at startup (incl VER13, NMIHARD)

; Build Features
; #DEFINE SIZE16K ; Uncomment to build a $FF padded 16K Image for banked ROM
;
#IFDEF PATCH
  ; USED BY AUTOMATED BUILD
  ; TO DEFINE PATCH FEATURES
  #DEFINE BUGFIX5
  #DEFINE BUGFIX8
  #DEFINE NMIHARD
  #DEFINE LOWCASE
  #DEFINE FASTMEM
  ; But Not FreHD, added manually
#ENDIF
;
; ======================================================================
;     INFORMATION
; ----------------------------------------------------------------------
;
; Original disassembled souce code obtained from:
;   https://gitlab.com/retroabandon/trs80i34-re
;
; With Following Additions
;   * Replaced all auto generated Labels with meaninful labels
;   * Ensured all jumps referenced code labels
;   * Replaced $3xxx hardware references with EQU defintions
;   * Replaced $4xxx buffer references with EQU definitions
;   * Replaced op-code with Byte definitions for Data Segments
;   * Replaced incorrect op-codes, where Better Else code "Trick" was was used.
;   * Added V1.3 modifications into the source code, with use of #IFDEF
;   * Added code Documentation from various sources
;
; This source code has been compiled with Telemark Assembler, and tested
; using a DIFF tool to ensure binary compatibility of the generated output.
;
; ======================================================================
;      ERRORS - "TRS-80 ROM Errors - Vernon Hester"
;      https://www.trs-80.com/sub-rom-bugs.htm
; ----------------------------------------------------------------------
;
; ======================================================================
;      REFERENCES
; ----------------------------------------------------------------------
;   • Git Hub Repository - [https://github.com/kiwisincebirth/TRS-80]
;   • Ira Goldlang, TRS-80 ROM Information - [https://www.trs-80.com/wordpress/roms/]
;   • TRS-80 ROM Errors - Vernon Hester - [https://www.trs-80.com/sub-rom-bugs.htm]
;   • Telemark Assembler - [https://www.cpcalive.com/docs/TASMMAN.HTM]
;   • Microsoft BASIC Decoded & Other Mysteries - James Farvour
;   • TRS-80 Rom Routines Documented (The Alternate Source) - Jack Decker
;
; ======================================================================
;
#IFNDEF VER12
    #IFNDEF VER13
    	#DEFINE VER13	; Ensure 1.3 is the default if 1.2 is not defined.
    #ENDIF
#ENDIF
;
#IFDEF FREHDBT
    #IFDEF VER12
        !!! ERROR VER12 IS NOT COMPATIBLE WITH FREHD !!!
    #ENDIF
    #IFNDEF VER13
        #DEFINE VER13 	; VER13 must be used if FreHD is defined
    #ENDIF
    #IFNDEF NMIHARD
	#DEFINE NMIHARD	; NMIHARD must be used if FreHD is defined
    #ENDIF

	DEFC 	FREHDBT_ENABLED = 1
	PUBLIC 	FREHDBT_ENABLED
#ENDIF

#IFDEF EACA80
	DEFC 	EACA80_ENABLED = 1
	PUBLIC 	EACA80_ENABLED
#ENDIF
;
#IFDEF VER12
	DEFC 	VER12_ENABLED = 1
	PUBLIC 	VER12_ENABLED
#ENDIF
;
#IFDEF VER13
	DEFC 	VER13_ENABLED = 1
	PUBLIC 	VER13_ENABLED
#ENDIF
;
; ======================================================================
; CONSTANTS
; ======================================================================
;
INCLUDE "CONSTANTS.Z80"
;
DEFC	CURCHR	= $5F	; _ cursor character
;
DEFC	BUFINI	= RAM+$1E5	; String Buffer initialised with -> colon null comma (M1)
DEFC	SMPSTK	= RAM+$1F8	; Initial Stack address (M1)
DEFC	MEMEND	= RAM+$200	; End of Reserved RAM Communications area
DEFC	SYSSTK	= RAM+$288	; Stack address usd by SYSTEM command
;
; ======================================================================
;   START OF PROGRAM CODE
; ======================================================================
;
	ORG	$0000	; Start of ROM Code Base
;
; ----------------------------------------------------------------------
; 0000H-0004H – POWER UP ROUTINE – "_START"
; ----------------------------------------------------------------------
_START:
rst00:	di			;0000
	xor	a		;0001
	jp	INIT		;0002
;
; The BDOS (Basic Disk Operating System) entry point address in most CP/M systems
; Having this here may be coincidental, or this may never called
	jp	mRST1		;0005
;
; ======================================================================
; 0008H (RST 8H) - Compare Symbol - SYMBOL
;
;   Jumps to 4000H. 4000H passes control to 1C96H.
;   Compares the symbol in the input string pointed to by HL
;   register to the value in the location following the RST 08
;   call. If there is a match, control is returned to address of the
;   RST 08 instruction 2 with the next symbol in the A-register
;   and HL incremented by one. If the two characters do not
;   match, a syntax error message is given and control returns
;   to the Input Phase.
; ----------------------------------------------------------------------
rst08:	jp	mRST1		;0008
;
; ----------------------------------------------------------------------
; 000BH-000CH – DISK ROUTINE – "_WHERE" ( RESOLVE RELOCATION ADDRESS )
;   Same as a RET instruction except leaves return address in HL
;    A relocatable program can CALL 000BH and upon return the HL register
;    will contain hte current address of PC, thus can find itself in memory
; ----------------------------------------------------------------------
_WHERE:	pop	hl		;000b
	jp	(hl)		;000c
;
; ----------------------------------------------------------------------
; 000DH-000FH – DISK BOOTSTRAP – "_BOOT"
;   Does a "warm" system reboot, in that it reloads and executes the Disk
;    Operating System but does not re-initialize all system pointers, etc.
; ----------------------------------------------------------------------
_BOOT:	jp	BOOT		;000d - Jump to Disk Bootstrap loader (069Fh)
;
; ======================================================================
; 0010H (RST 10) – GET A CHARACTER FROM THE BUFFER - GETCHR
;
;   Loads the next character from the string pointed to by the
;   HL register set into the A-register and clears the CARRY
;   flag if it is alphabetic, or sets it if is alphanumeric. Blanks
;   and control codes 09 and 0B are ignored causing the
;   following character to be loaded and tested. The HL
;   register will be incremented before loading any character
;   therefore on the first call the HL register should contain the
;   string address minus one. The string must be terminated by
;   a byte of zeros.
; ----------------------------------------------------------------------
rst10:	jp	mRST2		;0010
;
; ----------------------------------------------------------------------
; 0013H-0017H – INPUT ROUTINE – _GET
; ----------------------------------------------------------------------
_GET:	push	bc		;0013
	ld	b,$01		;0014 - device type entry code
	jr	CIOJ		;0016 - BASIC driver entry routine at 0046H
;
; ======================================================================
; 0018H (RST 18H) Compare DE:HL - CPDEHL
;
;   This routine can be called by using RST 18H or CALL 1C90H.
;   Numerically compares DE and HL. Will not work for
;   signed integers (except positive ones). Uses the A-register
;   only. Sets the S and Z flags accordingly
;   (they are set in the same way as for a normal 8 bit CP).
;   All registers are unchanged except for A
;   Jumps to lC90H through 4006H.
; ----------------------------------------------------------------------
rst18:	jp	mRST3		;0018
;
; ----------------------------------------------------------------------
; 001BH-001EH – DRIVER ENTRY ROUTINE – Part 1 – "_PUT"
; ----------------------------------------------------------------------
_PUT:	push	bc		;001b
	ld	b,$02		;001c - device type entry code
	jr	CIOJ		;001e - BASIC driver entry routine at 0046H
;
; ======================================================================
; 0020H (RST 20H) - Get the current Number Type - GETYPE
;
;   This routine jumps to 25D9H through 4009H.
;   If the NTF=8 then C=RESET or else C=SET, Z flag will be SET if NTF=3
;   (S flag is valid also.). After execution of RST 20H or CALL 25D9H,
;   A will contain the value NTF-3, all other registers are unchanged.
; ----------------------------------------------------------------------
rst20:	jp	mRST4		;0020
;
; ----------------------------------------------------------------------
; 0023H-0027H – DISK ROUTINE – "_CTL"
;   Outputs a control byte to a logical device or FCB.
;   DE = FCB and A = control byte
; ----------------------------------------------------------------------
_CTL:	push	bc		;0023
	ld	b,$04		;0024 - device type entry code
	jr	CIOJ		;0026- BASIC driver entry routine at 0046H
;
; ======================================================================
; 0028H (RST 28H) - DOS Function CALL - DOSCAL
;
;   Jumps to 400CH which contains C9H (RET) under Level II BASIC.
;   This vector is only used by Disk BASIC. It is called by the BREAK key routine,
;   and can be used to intercept the BREAK key logic
; ----------------------------------------------------------------------
_DOSCAL:
rst28:	jp	mRST5		;0028
;
; ======================================================================
; 002BH – KEYBOARD ROUTINE – "_KBD" - Scan Keyboard
;
;   This Routine Performs an instantaneous scan of the keyboard.
;   After CALLing 2BH, the A Register will contain
;   the ASCII value for the key that was pressed, or ZERO if no key pressed.
;
;   Apart from the AF Register Pair the DE Register Pair is also used by the routine.
;   If you want to wait for a key to be pressed, you would use CALL 0049
; ----------------------------------------------------------------------
_KBD:	ld	de,mKDCB	;002b
	jr	_GET		;002e
;
; ======================================================================
; 0030 (RST 30H) - Load DEBUG - LDEBUG
;
;   This CALL loads the DEBUG program and transfers
;   control to it. When DEBUG processing is complete, control
;   is returned to the original caller. For non-disk systems
;   control is returned immediately
;   This location passes control to 400FH which contains a RET (C9H)
;   under Level II. This location is only used by a Disk system
; ----------------------------------------------------------------------
rst30:	jp	mRST6		;0030
;
; ======================================================================
; 0033H – VIDEO ROUTINE – "_DSP" - Character print routine.
;
;  Print a character at the current cursor position.
;  The A Register must contain the ASCII code for the character or graphics
;  figure that is to be printed before CALLing this routine.
;  The DE Register Pair is used by the routine.
; ----------------------------------------------------------------------
VDCHAR:
_DSP:	ld	de,mDDCB	;0033 - video device control block.
	jr	_PUT		;0036
;
; ======================================================================
; 0038 (RST 38H) - Interrupt Entry Point - INTERR
;
;  This is the system entry point for all interrupts. It contains a
;  jump to section of code in the Communications Region
;  designed to field interrupts. That section of code consists
;  of a DI (disables further interrupts) followed by a RET
;  (returns to the point of interrupt) for non-disk systems
; ----------------------------------------------------------------------
rst38:	jp	mRST7		;0038
;
; ======================================================================
; 003BH – PRINTER ROUTINE – "$PRT"
;  Waits until printer is ready then prints charatcter.
;  A = ASCII character. If BREAK is pressed, a return to caller is made
;  Character LPRINT routine. Same as 33H but outputs to line printer.
;  (Contents of A Register will be printed).
; ----------------------------------------------------------------------
PRCHAR:
_PRT:	ld	de,mPDCB	;003b
	jr	_PUT		;003e
;
; ----------------------------------------------------------------------
; 0040H – INPUT ROUTINE – "$KEYIN" - GET A LINE FROM THE KEYBOARD
;  takes keyboard entry until a carriage return, a break, or buffer overrun occurs.
; ----------------------------------------------------------------------
KBLINE:
_KEYIN:	jp	KEYIN		;0040
	ret			;0043 - unsure of the purpose of these instructions
	nop			;0044
	nop			;0045
;
; ----------------------------------------------------------------------
; 0046H-0048H – DRIVER ENTRY ROUTINE – Part 2 – "CIOJ"
; ----------------------------------------------------------------------
CIOJ:	jp	CIO		;0046
;
; ======================================================================
; 0049H – KEYBOARD ROUTINE – "$KEY" -  Wait For Keyboard Input
;
;   Returns as soon as any key on keyboard is pressed. ASCII
;   value for character entered is returned in A- register. Uses
;   A, status and DE registers.
; ----------------------------------------------------------------------
KBWAIT:
_KEY:	call	_KBD		;0049
	or	a		;004c
	ret	nz		;004d
	jr	_KEY		;004e
;
; ----------------------------------------------------------------------
; 0050H-005FH – KEYBOARD LOOKUP TABLE – "KEYTAB"
;   XXX in 1.3, Shift-↓ is $00 to act as a Ctrl key
;                Std    Shifted
; ----------------------------------------------------------------------
KEYTAB:	DEFB	ENTER,	ENTER	; ENTER
	DEFB	CLRKEY,	CLRKEY	; CLEAR
	DEFB	BREAK,	BREAK	; BREAK
	DEFB	UPARRW,	ARUP	; ↑ Up Arrow
#IFDEF VER12
	DEFB	LINEF,	ARDOWN	; LF, ↓ Down Arrow
#ELSE
	DEFB	LINEF,	$00	; ↓ Down Arrow
				; to permit Shift-Down-Arrow to act as a control key
#ENDIF
	DEFB	BACKS,	ARLEFT	; BS, ← Left arrow
	DEFB	TAB,	ARIGHT	; Tab, -> right arrow
	DEFB	SPACE,	SPACE	; Space
;
; ----------------------------------------------------------------------
; 0060H-0065H – DELAY ROUTINE – "$DELAY"
;  This is a delay loop. The BC Register Pair is used as the loop counter.
;  The duration of the delay, in microseconds, is the value of BC times 14.66.
;  Register A is used.
; ----------------------------------------------------------------------
DELAY:	dec	bc		;0060
	ld	a,b		;0061
	or	c		;0062
	jr	nz,DELAY	;0063
	ret			;0065
;
; ----------------------------------------------------------------------
; 0066 - NMI RESET
; the location to which program control jumps when the RESET button
; is pressed (Non Maskable Interrupt address)
; The RESET button generates an NMI, not an actual reset.
; ----------------------------------------------------------------------
#IFDEF NMIHARD
;
NMI:	jp	_START		;0066 - wrong Stack Pointer.
;
	DEFC 	NMIHARD_ENABLED = 1
	PUBLIC 	NMIHARD_ENABLED
;
#IFDEF FREHDBT
;				;If Fre HD we use this space for improved hdboot routine
HDBOOT:	call	CLS		;0069 - Clear Screen
	call	DELAY		;006c - pause for a few seconds
	jp	HDBOOT2		;006f - continue hdboot
#ENDIF
;
	DEFS	$0072 - $	;UNUSED fill the space to next routine with ZERO's
;
#ELSE
;
NMI:	ld	sp,$0600	;0066 - wrong Stack Pointer. Replaced latter
	ld	a,(diskstat)	;0069 - $FF if no expansion interface present
	inc	a		;006C
	cp	$02		;006D - did we detect a disk controller
	jp	nc,_START	;006F - If a disk is present START as if power-up
;
#ENDIF
;
; ----------------------------------------------------------------------
; Alternative entry point to BASIC. See 06CCH or 1A19 for more details
; ----------------------------------------------------------------------
	ASSERT	$ == $0072, "Segment: Alternate BASIC Entry Point Should start at $0072"
	jp	RESETR		;0072 - Jump to Level II BASIC READY routine
;
; ----------------------------------------------------------------------
; 0075H-0104H – INITIALIZATION ROUTINE – "INIT2"
;  This is part of the Level II initialization procedure. It moves
;  several support routine from 18F7H to 191EH up to 4080H to 40A7H.
; ----------------------------------------------------------------------
INIT2:	ld	de,FDIVC	;0075 - Ram location - of Level II BASIC support routines.
	ld	hl,CONSTR	;0078 - Rom Location - of Level II BASIC support routines.
	ld  bc,CONSTR2-CONSTR+1 ;007b - Size of the Routine(s) to move
	ldir			;007e - Move the routines
;
;  Initialises String Buffer
	ld	hl,BUFINI	;0080 - String Buffer Area in RAM (41E5H)
	ld	(hl),':'	;0083 - save a colon
	inc	hl		;0085 - next location
	ld	(hl),b		;0086 - write a 0, B reg should be zero
	inc	hl		;0087 - next location
	ld	(hl),','	;0088 - save a comma
	inc	hl		;008a - next location
;
; This loads 40A7H with the I/O buffer location address 41E8H.
; (40A7H is the I/O buffer pointer and contents be changed to relocate the buffer.)
	ld	(BUFPNT),hl	;008b
;
; Fills the RAM locations pointing to all 28 DOS BASIC commands,
; set them to point to ?L3 ERROR, (4152-41A5)
	ld	de,L3ERR	;008e - address of L3 error code
	ld	b,28		;0091 - there are 28 DOS BASIC commands
	ld	hl,ERCALL	;0093 - address in RAM of lookup table
ERLOPS:	ld	(hl),OPJPNN	;0096 - opcode (1st byte) for JP nnnn
	inc	hl		;0098
	ld	(hl),e		;0099 - address low order
	inc	hl		;009a
	ld	(hl),d		;009b - address high order
	inc	hl		;009c
	djnz	ERLOPS		;009d - and loop bas as required
;
; Set DOS Exit links to RET instructions (41A6-41E2)
	ld	b,21		;009f - 21 DOS Exits
LOPRTS:	ld	(hl),OPRET	;00a1 - Store RET OpCode
	inc	hl		;00a3 - and advance to the next location (3 bytes)
	inc	hl		;00a4
	inc	hl		;00a5
	djnz	LOPRTS		;00a6 - and loop if required
;
; The rest of the initialization routine. Asks MEMORY SIZE ?,
; sets the memory pointers accordingly and prints RADIO SHACK LEVEL II BASIC ,
	ld	hl,MEMEND+$E8	;00a8 - starting address of user RAM (which is 42E8H)
	ld	(hl),b		;00ab
	ld	sp,SMPSTK	;00ac - STACK pointer to 41F8H, temporary until call STKINI
	call	STKINI		;00af - Go initialize the Level II BASIC variables and pointers
	call	CLS		;00b2 - clears the screen, changes to 64 characters, and homes the screen)
;
MEMGET:	ld	hl,MEMMSG	;00b5 - MEMORY SIZE? message
	call	STROUT		;00b8 - print it
	call	QINLIN		;00bb - Print a “?” and get input from the keyboard
	jr	c,MEMGET	;00be - If the BREAK key was pressed, ask again.
	GETCHR			;00c0 - rst 10h
	or	a		;00c1
	jr	nz,TYPMEM	;00c2 - was a response to the MEMORY SIZE?
;
#IFDEF FASTMEM
;
MEMTST:	ld	hl,$4400	;00c4 - starting address for the memory size check (4400)
LOOPMM:	inc	h		;00c7 - next PAGE ram location + $100
;
	DEFC 	FASTMEM_ENABLED = 1
	PUBLIC 	FASTMEM_ENABLED
;
#ELSE
;
MEMTST:	ld	hl,MEMEND+$14C	;00c4 - starting address for the memory size check (434C)
LOOPMM:	inc	hl		;00c7 - next ram location
;
#ENDIF
	ld	a,h		;00c8 - MSB of ram location
	or	l		;00c9 - combine with LSB of ram location
	jr	z,USEDEF	;00ca - if the current memory pointer HL is equal to zero
	ld	a,(hl)		;00cc - get byte at memory location
	ld	b,a		;00cd - save it
	cpl			;00ce - and invert it (A) for test
	ld	(hl),a		;00cf - write it back to ram
	cp	(hl)		;00d0 - retrieve and compare test value
	ld	(hl),b		;00d1 - and save original value back
	jr	z,LOOPMM	;00d2 - loop back until the end of memory is found
	jr	USEDEF		;00d4 - If the address didn’t exist, have reached HIMEM
;
; process the users input to MEMORY SIZE ?
TYPMEM:	call	LINGET		;00d6 - convert user input string (HL) into value in DE
	or	a		;00d9 - Set Flags
	jp	nz,SNERR	;00da - Display a ?SN ERROR if Register A is not equal to zero
	ex	de,hl		;00dd - move value to HL
	dec	hl		;00de - minus 1
	ld	a,$8F		;00df - Load Register A with a memory test value
	ld	b,(hl)		;00e1 - read and save current value
	ld	(hl),a		;00e2 - write the test value
	cp	(hl)		;00e3 - read and compare to see if value was saved
	ld	(hl),b		;00e4 - restore the original value
	jr	nz,MEMGET	;00e5 - if not a usaable ram adress, back to MEM SIZE prompt
USEDEF:	dec	hl		;00e7 - minus 1
	ld	de,MEMEND+$214	;00e8 - the minimum MEMORY SIZE? response.
	CPDEHL			;00eb - RST 18 - compare DE (input)  and HL (minimum)
	jp	c,OMERR		;00ec - less than memory required, so OM ERROR
	ld	de,$FFCE	;00ef - Subtract 32 Bytes
	ld	(MEMSIZ),hl	;00f2 - Save the MEMORY SIZE? amount
	add	hl,de		;00f5 - subtract 32 bytes from the memory size
	ld	(STKTOP),hl	;00f6 - start of string space pointer MEMSIZE-32
	call	SCRTCH		;00f9 - init the Level II variables and pointers
#IFNDEF FREHDBT
	; FreHD does not print this message, saving 6 bytes here
	ld	hl,HDGMSG	;00fc - Radio Shack L2 Basic - Message
	call	STROUT		;00ff - print the message
#ENDIF
; then it jumps to the entry point for the BASIC command mode
	jp	READY		;0102 - Level II BASIC READY routine
;
#IFDEF VER13
;
; (start V1.3)
;
#IFDEF FREHDBT
;
; ----------------------------------------------------------------------
; 00FFH-0112H – HDBOOT - FreHD HD bootup routine
; using space saved by HDGMSG startup message
; ----------------------------------------------------------------------
;
#IFNDEF NMIHARD
HDBOOT:				; if NMIHARD is not enabled HDBOOT starts here.
#ENDIF
;
HDBOOT2: ld	a,ROM_MODEL_1	;00ff - ROM parameter to FreHD. 1 for Model1.
        out	(WRITEROM),a	;0101 - write the value
        in	a,(READROM)	;0103 - read response
        cp	0FEh		;0105 - FE is FreHD present and valid code!
        ret	nz		;0107 - return if no FreHD or old firmware
        ld	hl,ROM_LOAD	;0108 - load more "rom" from FreHD
        ld	bc,READROM	;010b - port to read and size counter
        inir			;010e - bulk transfer
        jp	ROM_LOAD	;0110 - jump to loader in RAM
;
#ENDIF
;
; ----------------------------------------------------------------------
; 0105H-011BH – MESSAGE STORAGE
;   Note: Starts at 0113H if FreHD has been defined
; ----------------------------------------------------------------------
;
#IFDEF EACA80
MEMMSG:	DEFB	"READY ",0,0,0  ; EACA-80 Mem Size Message (V1.3)
#ELSE
MEMMSG:	DEFB	"MEM SIZE",0	; RS Mem Size Message V1.3
#ENDIF

#IFNDEF FREHDBT
		; If FreHD then this message is removed
		; saving enough space for the HDBOOT routine (00FFH) above

#IFDEF EACA80
		; EACA-80 L2 Basic (blank) Message V1.3
HDGMSG:	DEFB	ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,0
#ELSE
HDGMSG:	DEFB	"R/S L2 BASIC",ENTER,0 ; RS L2 Basic Message V1.3
#ENDIF
;
#ENDIF
;
; ----------------------------------------------------------------------
; 011CH-012CH – KEYBOUNCE V1.3
; using space save by the shortened startup messages
; ----------------------------------------------------------------------
KEYBOU:	push	bc		;011C Save Row Address in BC into the STACK
	ld 	bc,$0500	;011D the debounce delay
	call	DELAY		;0120 delay on delay count in BC (18.8 ms)
	pop	bc		;0123 Restore the Row Address back to BC
	ld	a,(bc)		;0124 Reload the original flags from active row
	and	e		;0125 Combine the current flag lists with the original flag bits
	ret	z		;0126 Return to caller if zero because the row was not active on the second test
	ld	a,d		;0127 Otherwise, we have a legitimate active row
	rlca			;0128 Multiply the row index by 2. twice.
	rlca			;0129 This code previously existed at the calling site
	jp	KYDRES		;012A Resume the keyboard driver routine
;
; (finish 1.3)
;
#ELSE
;
; (start V1.2)
;
; ----------------------------------------------------------------------
; 0105H-012CH – MESSAGE STORAGE (VERSION 1.2)
; ----------------------------------------------------------------------
;
#IFDEF EACA80
MEMMSG:	DEFB	"READY ",0,0,0,0,0,0	; EACA-80 Mem Size Message V1.2
		; EACA-80 L2 Basic (blank) Message V1.2
HDGMSG:	DEFB	ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,ENTER
        DEFB     ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,ENTER
        DEFB     ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,ENTER,0
#ELSE
MEMMSG:	DEFB	"MEMORY SIZE",0			     ; RS Mem Size Message V1.2
HDGMSG:	DEFB	"RADIO SHACK LEVEL II BASIC",ENTER,0 ; RS L2 Basic Message V1.2
#ENDIF
;
; (finish V1.2)
;
#ENDIF
;
; ----------------------------------------------------------------------
; 012DH – ?L3 ERROR ENTRY POINT – "L3ERR"
; ----------------------------------------------------------------------
L3ERR:	ld	e,ERRL3		;012d - Load Register E with the ?L3 ERROR code of 2CH
	jp	ERROR		;012f
;
; ----------------------------------------------------------------------
; 0132H-0134H –	LEVEL II BASIC POINT COMMAND ENTRY POINT – "POINT"
; ----------------------------------------------------------------------
POINT:	GETCHR			;0132 - rst 10h
	xor	a		;0133
;
; Z-80 Trick! The byte at this memory location, 01H, is there to turn the real instruction
; that follows (the operative action of the SET command) into a harmless LD BC,xxxx.
; This way, they didn’t have to jump over SET or RESET to get to the common graphics code.
; If parsing straight down, this loads BC with 0380H and then moves to 0136H. But if jump
; straight to 0136H, you skip that 01H opcode, and get a real instruciton of 3EH 80H
	DEFB	LDBCNN		;0134
;
; ----------------------------------------------------------------------
; 0135H-0137H – LEVEL II BASIC SET COMMAND ENTRY POINT – “SET”
; ----------------------------------------------------------------------
SET:	ld	a,$80		;0135
	DEFB	LDBCNN		;0137 - See comment above about what this does
;
; ----------------------------------------------------------------------
; 0138H-0139H – LEVEL II BASIC RESET COMMAND ENTRY POINT – “RESET”
; ----------------------------------------------------------------------
RESET:	ld	a,$01		;0138
;
; ----------------------------------------------------------------------
; 013AH-019CH GRAPHICS ROUTINE - Common Code for SET RESET and POINT
;   A will be 0 if POINT, 80H if SET and 1 for RESET.
; ----------------------------------------------------------------------
;
	push	af		;013a
	SYNTAX	('(')		;013b - rst 08h - all commands start with a (
	call	GETBYT		;013d - get a numeric value X coordinate
	cp	128		;0140 - is it greater than 128
	jp	nc,FCERR	;0142 - if greater than 128 then an error
	push	af		;0145 - Save coordinate’s X value on the STACK
	SYNTAX	(',')		;0146 - rst 08h - then a comma
	call	GETBYT		;0148 - get a numeric value Y coordinate
	cp	$30		;014b - test to see if the character was alphabetic or alphanumeric
	jp	nc,FCERR	;014d
	ld	d,$FF		;0150
LOPMD3:	inc	d		;0152
	sub	$03		;0153
	jr	nc,LOPMD3	;0155
	add	a,$03		;0157
	ld	c,a		;0159
	pop	af		;015a
	add	a,a		;015b
	ld	e,a		;015c
	ld	b,$02		;015d
SHFTW:	ld	a,d		;015f
	rra			;0160
	ld	d,a		;0161
	ld	a,e		;0162
	rra			;0163
	ld	e,a		;0164
	djnz	SHFTW		;0165
	ld	a,c		;0167
	adc	a,a		;0168
	inc	a		;0169
	ld	b,a		;016a
	xor	a		;016b
	scf			;016c
PWR2:	adc	a,a		;016d
	djnz	PWR2		;016e
	ld	c,a		;0170
	ld	a,d		;0171
	or	$3C		;0172
	ld	d,a		;0174
	ld	a,(de)		;0175
	or	a		;0176
	jp	m,FND4		;0177
	ld	a,$80		;017a
FND4:	ld	b,a		;017c
	pop	af		;017d
	or	a		;017e
	ld	a,b		;017f
	jr	z,TBIT		;0180
	ld	(de),a		;0182
	jp	m,SBIT		;0183
	ld	a,c		;0186
	cpl			;0187
	ld	c,a		;0188
	ld	a,(de)		;0189
	and	c		;018a
FINSTB:	ld	(de),a		;018b
FINPTB:	SYNTAX	(')')		;018c - rst 08h
	ret			;018e
SBIT:	or	c		;018f
	jr	FINSTB		;0190
TBIT:	and	c		;0192
	add	a,$FF		;0193
	sbc	a,a		;0195
	push	hl		;0196
	call	CONIA		;0197
	pop	hl		;019a
	jr	FINPTB		;019b
;
; ----------------------------------------------------------------------
; 019DH-01C8H – LEVEL II BASIC INKEY$ ROUTINE – “INKEY”
; ----------------------------------------------------------------------
INKEY:	GETCHR			;019d - rst 10h
; ----------------------------------------------------------------------
; 019E - Create 1 character string from keyboard input (TAS)
; ----------------------------------------------------------------------
	push	hl		;019e
	ld	a,(CHARC)	;019f
	or	a		;01a2
	jr	nz,BUFCIN	;01a3
	call	ISCHAR		;01a5
	or	a		;01a8
	jr	z,NULRT		;01a9
BUFCIN:	push	af		;01ab
	xor	a		;01ac
	ld	(CHARC),a	;01ad
	inc	a		;01b0
	call	STRINI		;01b1
	pop	af		;01b4
	ld	hl,(DSCTMP+1)	;01b5
	ld	(hl),a		;01b8
	jp	PUTNEW		;01b9
NULRT:	ld	hl,m_REDDY-1	;01bc
	ld	(FACLO),hl	;01bf
	ld	a,VTSTR		;01c2 - String Value Type
	ld	(VALTYP),a	;01c4
	pop	hl		;01c7
	ret			;01c8
;
; ======================================================================
; 01C9H – LEVEL II BASIC CLS ROUTINE – "CLS"
;
;   Clear the screen, select 64 characters and home the cursor.
;   All registers are used.
; ----------------------------------------------------------------------
CLS:	ld	a,CHOME		;01c9 - ascii for cursor Home
	call	OUT2D		;01cb - display it
	ld	a,CLRKEY	;01ce - ascii for erase to end of frame
	jp	OUT2D		;01d0 - call and return
;
; ======================================================================
; 01D3H – LEVEL II BASIC REFRESH RANDOM ROUTINE – “RANDOM”
;
;   This is part of the RANDOM routine which takes a value out of the
;   REFRESH register, stores it in location 40ABH and then returns.
;   A call to 01D3H reseeds the random number seed (location 40AB)
;   with the current contents of the refresh register.
; ----------------------------------------------------------------------
RANDOM:	ld	a,r		;01d3 - R (refresh) Reg - semi random number.
	ld	(RNDX+1),a	;01d5
	ret			;01d8
;
; ----------------------------------------------------------------------
; 01D9H-01F7H – CASSETTE ROUTINE
;   Output a pulse to the cassette recorder
; ----------------------------------------------------------------------
CTPULS:	ld	hl,$FC01	;01d9 - a top of pulse
	call	CTCHG		;01dc - output pulse
	ld	b,$0B		;01df - delay count of 80 milliseconds
CT1:	djnz	CT1		;01e1 - delay loop
	ld	hl,$FC02	;01e3 - a bottom of pulse
	call	CTCHG		;01e6 - output pulse
	ld	b,$0B		;01e9 - delay count of 80 milliseconds
CT2:	djnz	CT2		;01eb - delay loop
	ld	hl,$FC00	;01ed - clear pulse
	call	CTCHG		;01f0 - output pulse
	ld	b,$5C		;01f3 - delay count of 671 milliseconds
CT3:	djnz	CT3		;01f5 - delay loop
	ret			;01f7
;
; ----------------------------------------------------------------------
; 01F8H-01FDH – CASSETTE ROUTINE (TURN OFF CASSETTE) – “CTOFF”
; ----------------------------------------------------------------------
CTOFF:	push	hl		;01f8 - Save The HL Register
	ld	hl,$FB00	;01f9 - And Or Flags, turn off cassette
	jr	CTCHG2		;01fc - process this
;
; ----------------------------------------------------------------------
; 01FEH-0211H- CASSETTE ROUTINE (EVALUATE DRIVE NUMBER) – “CTON”
; ----------------------------------------------------------------------
CTON:	ld	a,(hl)		;01fe - char from BASIC program pointer
	sub	'#'		;01ff - Check for a # character
	ld	a,$00		;0201 - A default value, doesnt set flags
	jr	nz,DEFDRV	;0203 - Isnt a # char so process default = 0
	call	GETINT		;0205 - get INT drive number from BASIC program -> DE
	SYNTAX	(',')		;0208 - rst 08h - See if we have a Comma
	ld	a,e		;020a - need to convert from the negative number to positive
	and	d		;020b - combine the MSB with the LSB of the drive number
	add	a,$02		;020c - add 2 to make the drive number positive
	jp	nc,FCERR	;020e - If the drive number is invalid, FC ERROR
	dec	a		;0211 - dec the drive number
;
; ----------------------------------------------------------------------
; 0212H-021DH – CASSETTE ROUTINE (TURN ON CASSETTE) “DEFDRV”
;   CALL 212H will select the cassette unit specified in A-Register
;   and start the motor. Units are numbered from one.
;   Put 00H in A Register to turn on cassette 1, or O1H to turn on cassette 2.
;   All registers are used.
; ----------------------------------------------------------------------
DEFDRV:
#IFNDEF EACA80
	ld	(casselect),a	;0212 - Set the requested cassette
#ELSE
	out	(casport),a	;0212 - On Dick Smith System-80 (EACA) use IO port
	nop			;0214 - Nop since OUT is only 2 byte instruction
#ENDIF
	push	hl		;0215 - Save HL Register
	ld	hl,$FF04	;0216 - AND OR flags to turn on the cassette motor
CTCHG2:	call	CTCHG		;0219 - output this command
	pop	hl		;021c - current BASIC program pointer from the STACK
	ret			;021d
; ----------------------------------------------------------------------
; 021EH-022BH – CASSETTE ROUTINE – “CTSTAT”
; ----------------------------------------------------------------------
CTSTAT:	ld	hl,$FF00	;021e - no change to the cassette port
CTCHG:	ld	a,(CAST)	;0221 - saved shadow ram copy of cassette port
	and	h		;0224 - mask the value, remove unwanted bits
	or	l		;0225 - and set bits we want
	out	(vidcmt),a	;0226 - send value to the CAS port
	ld	(CAST),a	;0228 - save it for future
	ret			;022b
; ----------------------------------------------------------------------
; 022CH-0234H – CASSETTE ROUTINE (BLINK **) – “BCASIN”
;   Alternately displays and clears an asterisk in the upper right hand comer.
;   Uses all registers.
; ----------------------------------------------------------------------
BCASIN:	ld	a,(vidmem+$3F)	;022c
	xor	$0A		;022f
	ld	(vidmem+$3F),a	;0231
	ret			;0234
; ----------------------------------------------------------------------
; 0235H-0240H – CASSETTE ROUTINE (READ A BYTE) – “CASIN”
;   Read One Byte: Reads one byte from the currently selected unit.
;   The byte read is returned in the A-register. Other registers preserved
; ----------------------------------------------------------------------
CASIN:	push	bc		;0235
	push	hl		;0236
	ld	b,$08		;0237
CTB0:	call	CTBIT		;0239
	djnz	CTB0		;023c
	pop	hl		;023e
	pop	bc		;023f
	ret			;0240
; ----------------------------------------------------------------------
; 0241H-0260H – CASSETTE ROUTINE (READ A BIT) – “CTBIT”
;   Routine waits for timing pulse, and then performs a timing loop.
;   When the time is up it tests the tape for a bit, which will be “1”
;   if present and “0” if not. A CALL 241H is used by 235H eight times
;   to input one byte.
; ----------------------------------------------------------------------
CTBIT:	push	bc		;0241
	push	af		;0242
CB0:	in	a,(vidcmt)	;0243 - Read BIT from cassette port
	rla			;0245
	jr	nc,CB0		;0246
;
#IFDEF VER13
	ld	b,$60		;0248 - Delay for 703 microseconds (assume)
#ELSE
	ld	b,$41		;0248 - Delay for 476 microseconds
#ENDIF
;
CB1:	djnz	CB1		;024a - Delay Loop
	call	CTSTAT		;024c - clear the cassette controller
;
#IFDEF VER13
	ld	b,$85		;024f - Then Delay for 975 microseconds (assume)
#ELSE
	ld	b,$76		;024f - Then delay for 865 microseconds
#ENDIF
;
CB2:	djnz	CB2		;0251 - Delay Loop
	in	a,(vidcmt)	;0253 - Read BIT from cassette port
	ld	b,a		;0255
	pop	af		;0256
	rl	b		;0257
	rla			;0259
	push	af		;025a
	call	CTSTAT		;025b - clear the cassette controller
	pop	af		;025e
	pop	bc		;025f
	ret			;0260
; ----------------------------------------------------------------------
; 0261H-0263H – CASSETTE ROUTINE – “TWOCSO”
; ----------------------------------------------------------------------
TWOCSO:	call	CASOUT		;0261
;
; ----------------------------------------------------------------------
; 0264H-027DH – CASSETTE ROUTINE (WRITE A BYTE) – “CASOUT”
;   Writes the byte in the A Register to tape. BC, DE and HL are unchanged
; ----------------------------------------------------------------------
CASOUT:	push	hl		;0264
	push	bc		;0265
	push	de		;0266
	push	af		;0267
	ld	c,$08		;0268
	ld	d,a		;026a
BYT0:	call	CTPULS		;026b
	ld	a,d		;026e
	rlca			;026f
	ld	d,a		;0270
	jr	nc,BYT2		;0271
	call	CTPULS		;0273
BYT1:	dec	c		;0276
	jr	nz,BYT0		;0277
	pop	af		;0279
	pop	de		;027a
	pop	bc		;027b
	pop	hl		;027c
	ret			;027d
; ----------------------------------------------------------------------
; 027EH-0283H –	CASSETTE ROUTINE
; ----------------------------------------------------------------------
BYT2:	ld	b,$87		;027e
BYT3:	djnz	BYT3		;0280
	jr	BYT1		;0282
; ----------------------------------------------------------------------
; 0284H-0292H – CASSETTE ROUTINE (TURN ON CASSETTE AND WRITE LEADER) – “CWRTON”
; ----------------------------------------------------------------------
CWRTON:	call	CTON		;0284
	ld	b,$FF		;0287
	xor	a		;0289
CSAV1:	call	CASOUT		;028a
	djnz	CSAV1		;028d
	ld	a,$A5		;028f - sync byte (A5H)
	jr	CASOUT		;0291
; ----------------------------------------------------------------------
; 0293H-029EH –	CASSETTE ROUTINE (TURN ON CASSETTE AND READ LEADER) – “CSRDON”
; ----------------------------------------------------------------------
CSRDON:	call	CTON		;0293
CSRDON3: push	hl		;0296
	xor	a		;0297
CLOD1:	call	CTBIT		;0298
	cp	$A5		;029b - sync byte (A5H)
	jr	nz,CLOD1	;029d
; ----------------------------------------------------------------------
; 029FH-02A8H – CASSETTE ROUTINE
;   Places the double asterisk in the right top corner
;   to show that the sync byte has been found
; ----------------------------------------------------------------------
	ld	a,'*'		;029f
	ld	(vidmem+$3E),a	;02a1
	ld	(vidmem+$3F),a	;02a4
	pop	hl		;02a7
	ret			;02a8
;
ENBLK:	call	CADRIN		;02a9
	ld	(TEMP),hl	;02ac
	call	CTOFF		;02af
;
; ----------------------------------------------------------------------
; 02B2 – LEVEL II BASIC SYSTEM ROUTINE – “SYSTEM”
; ----------------------------------------------------------------------
SYSTEM:	call	SYSOUT		;02b2 - Call the DOS exit for system command at 41E2H.
	ld	sp,SYSSTK	;02b5 - Set the STACK pointer to the assumed load address.
	; This location passes control to the routine used by the BASIC command SYSTEM.
	call	CRDO		;02b8 - display a carriage return on the video display
	ld	a,'*'		;02bb
	call	OUTDO		;02bd - Display a * character on the video display.
	call	QINLIN		;02c0 - get the input from the keyboard
	jp	c,RESETR	;02c3 - If BREAK key, JMP 06CC entry. BUG 29
	GETCHR			;02c6 - rst 10h - first byte of user input
	jp	z,SNERR		;02c7 - if no input then a syntax error
	cp	'/'		;02ca - check for a slash command
	jr	z,GODO		;02cc - jump to routine to handle execution
; ----------------------------------------------------------------------
; 02CE - Load Binary program from tape
; ----------------------------------------------------------------------
	call	CSRDON		;02ce - turn on cassette motor here
LOPHD:	call	CASIN		;02d1 - read one byte from cassette
	cp	$55		;02d4 - check for header byte
	jr	nz,LOPHD	;02d6 - loop until header found
	ld	b,6		;02d8 - length of filename to read from tape
CHKBYT:	ld	a,(hl)		;02da - START LOOP - Get character in inout buffer
	or	a		;02db - set flags
	jr	z,GETDT		;02dc - if character is end of buffer, skip check
	call	CASIN		;02de - read one byte from cassette
	cp	(hl)		;02e1 - did it match users character
	jr	nz,LOPHD	;02e2 - if not skip to next program on tape
	inc	hl		;02e4 - next character to check
	djnz	CHKBYT		;02e5 - LOOP to check next character
;
GETDT:	call	BCASIN		;02e7 - Blink * in top right corner
GETDT2:	call	CASIN		;02ea - read one byte from cassette
	cp	$78		;02ed - check for execution address header byte
	jr	z,ENBLK		;02ef
	cp	$3C		;02f1 - check for file block header byte
	jr	nz,GETDT2	;02f3 - loop until find a correct header byte
;
	call	CASIN		;02f5 - read number of Bytes in the Block
	ld	b,a		;02f8 - store byte count in B for loop
	call	CADRIN		;02f9 - read two bytes Block Starting address -> HL
	add	a,l		;02fc - Add LSB of starting address to byte count
	ld	c,a		;02fd - Store Checksum (starting) in C register
LDATIN:	call	CASIN		;02fe - read one byte from cassette
	ld	(hl),a		;0301 - store the byte in memory
	inc	hl		;0302 - next address
	add	a,c		;0303 - Calculate the checksum
	ld	c,a		;0304 - Update Checksum in C register
	djnz	LDATIN		;0305 - LOOP
	call	CASIN		;0307 - read one byte from cassette - Checksum
	cp	c		;030a - Is it same the as calculated checksum
	jr	z,GETDT		;030b - if GOOD Checkum - LOOP BACK for next block
;
	ld	a,'C'		;030d - C Character
	ld	(vidmem+$3E),a	;030f - Write into Video Memory
	jr	GETDT2		;0312 - LOOP BACK for next block
;
; ----------------------------------------------------------------------
; 0314H – Read 2 bytes from the tape into Register Pair HL – “CADRIN”
;   This routine is commonly used by the SYSTEM routine to read
;   the last two bytes on tape which give the entry point.
; ----------------------------------------------------------------------
CADRIN:	call	CASIN		;0314 - read one byte from cassette
	ld	l,a		;0317
	call	CASIN		;0318 - read one byte from cassette
	ld	h,a		;031b
	ret			;031c
; ----------------------------------------------------------------------
; 031DH – Execute the Cassette Program which was Loaded – “GODO”
; ----------------------------------------------------------------------
GODO:	ex	de,hl		;031d - put user input buffer into DE
	ld	hl,(TEMP)	;031e - execution address read from tape
	ex	de,hl		;0321 - Swap back, user input buffer into HL
	GETCHR			;0322 - rst 10h
	call	nz,LINGET	;0323 - Convert to ascii string
	jr	nz,SYSTEM	;0326 - if no address defined Display * promt
	ex	de,hl		;0328 - execution address into HL
	jp	(hl)		;0329 - jump to execution address
;
; ----------------------------------------------------------------------
; 032AH-0347H – OUTPUT ROUTINE – “OUTCH1” and “OUTDO”
;   This is a general purpose output routine which outputs a byte from
;   the A Register to video, tape or printer. In order to use it,
;   the location 409CH must be loaded with -1 tape, 0 video, or 1 for printer.
; ----------------------------------------------------------------------
OUTDO:	push	bc		;032a
	ld	c,a		;032b - Save the character
	call	EXOUTC		;032c - DOS EXIT for character output
	ld	a,(PRTFLG)	;032f - get the current Device
	or	a		;0332 - set the flags
	ld	a,c		;0333 - get the character back into A
	pop	bc		;0334
	jp	m,CASOUT	;0335 - if is It Cassette
	jr	nz,OUTLPT	;0338 - if it is Printer
; ----------------------------------------------------------------------
; 033AH-0347H – OUTPUT ROUTINE – “OUT2D”
;   A Print routine which performs the same function as 33H except
;   that it doesn’t destroy the contents of the DE Register Pair.
;   All the general purpose registers are saved, which is often desirable
; ----------------------------------------------------------------------
OUT2D:	push	de		;033a
	call	_DSP		;033b
	push	af		;033e
	call	DSPPOS		;033f - Compute Line pos based on Vid Ram Cursor
	ld	(TTYPOS),a	;0342 - store current line pos
	pop	af		;0345
	pop	de		;0346
	ret			;0347
; ----------------------------------------------------------------------
; 0348H-0357H – VIDEO ROUTINE – “DSPPOS”
;   Works out horizontal cursor position based on (CURSOR) vid ram pointer
; ----------------------------------------------------------------------
DSPPOS:	ld	a,(CAST)	;0348 - get shadow copy of cassette port
	and	CAST32		;034b - mask of the 32 char mode bit
	ld	a,(CURSOR)	;034d - LSB of the current cursor position
	jr	z,NT32PS	;0350 - 64 characters per line mode?
	rrca			;0352 - divide by 2
	and	$1F		;0353 - Mask cursor position for 32 character
NT32PS:	and	$3F		;0355 - Mask cursor position for 64 character
	ret			;0357
; ----------------------------------------------------------------------
; 0358H-0360H – KEYBOARD ROUTINE – “ISCHAR”
;   Here is the routine to simulate the INKEY$ function. It performs exactly
;   the same function as 2BH but it restores all registers, whereas 2BH
;   destroys the DE Register Pair. This makes 35BH more useful than 2BH
; ----------------------------------------------------------------------
ISCHAR:	call	EXINC		;0358
	push	de		;035b
	call	_KBD		;035c
	pop	de		;035f
	ret			;0360
;
; ======================================================================
; 0361H – INPUT ROUTINE – “INLIN”
;
;   This is one of the general purpose input routines (see 5D9 and 1BB3 also).
;   This routine inputs a string from the keyboard, up to 240 characters,
;   and echoes them to the screen. It puts this data into a buffer located
;   at the address pointed to by the buffer pointer at 40A7H
; ----------------------------------------------------------------------
INLIN:	xor	a		;0361
	ld	(CHARC),a	;0362
	ld	(TTYPOS),a	;0365
	call	INLINE		;0368 - Go call the DOS link at 41AFH
	push	bc		;036b
	ld	hl,(BUFPNT)	;036c - starting address of the input buffer
	ld	b,240		;036f - length of the input buffer
	call	KEYIN		;0371 - keyboard input routine, until a CR, a BREAK
	push	af		;0374
	ld	c,b		;0375 - Move lenght of Input to C
	ld	b,0		;0376 - zero B, so BC has has lenght of Input
	add	hl,bc		;0378 - end of the Input
	ld	(hl),$00	;0379 - Save an end of the input terminator
	ld	hl,(BUFPNT)	;037b - back to start of the input buffer
	pop	af		;037e
	pop	bc		;037f
	dec	hl		;0380 - Decrement the input buffer pointer
	ret	c		;0381 - Return if the BREAK key was pressed
	xor	a		;0382 - Signal success
	ret			;0383
; ----------------------------------------------------------------------
; 0384H-038AH – KEYBOARD ROUTINE – “INCHR”
;   Waits for keypress
; ----------------------------------------------------------------------
INCHR:	call	ISCHAR		;0384
	or	a		;0387
	ret	nz		;0388
	jr	INCHR		;0389
; ----------------------------------------------------------------------
; 038BH-039BH – PRINTER ROUTINE – “FINLPT”
; ----------------------------------------------------------------------
FINLPT:	xor	a		;038b - DEV0VID
	ld	(PRTFLG),a	;038c - set current output device VIDEO
	ld	a,(LPTPOS)	;038f
	or	a		;0392
	ret	z		;0393
	ld	a,ENTER		;0394
	push	de		;0396
	call	OUTLPT		;0397
	pop	de		;039a
	ret			;039b
;
; =====================================================================
; 039CH-03C1H – PRINTER ROUTINE – “OUTLPT”
;
;  This is the LPRINT routine. All registers are saved.
;  The byte to be printed should be in the A register
; ----------------------------------------------------------------------
OUTLPT:	push	af		;039c
	push	de		;039d
	push	bc		;039e
	ld	c,a		;039f
	ld	e,$00		;03a0
	cp	FORMF		;03a2
	jr	z,LZRPOS	;03a4
	cp	LINEF		;03a6
	jr	nz,LZRNOT	;03a8
	ld	a,ENTER		;03aa
	ld	c,a		;03ac
LZRNOT:	cp	ENTER		;03ad
	jr	z,LZRPOS	;03af
	ld	a,(LPTPOS)	;03b1
	inc	a		;03b4
	ld	e,a		;03b5
LZRPOS:	ld	a,e		;03b6
	ld	(LPTPOS),a	;03b7
	ld	a,c		;03ba
	call	_PRT		;03bb
	pop	bc		;03be
	pop	de		;03bf
	pop	af		;03c0
	ret			;03c1
;
; ----------------------------------------------------------------------
; 03C2H-03E2H – DRIVER ENTRY ROUTINE – “CIO”
;   This routine is called from a RST 14 GET (with a device code of 01H in
;   Register B), RST 1C PUT (with a device code of 02H in Register B),
;   and RST 24 CTL (with a device code of 04H in Register B).
; ----------------------------------------------------------------------
CIO:	push	hl		;03c2 - Save HL, IX, DE registers on the stack
	push	ix		;03c3
	push	de		;03c5 - starting address of Device Drive
	pop	ix		;03c6 - moved from DE to IX via the stack
	push	de		;03c8
	ld	hl,CIORTN	;03c9 - return address for device driver call
	push	hl		;03cc - return address pushed to stack
	ld	c,a		;03cd - put character to process into C
	ld	a,(de)		;03ce - device type code from the DCB
	and	b		;03cf - Isolate device code bits, using B parameter
	cp	b		;03d0 - check for equality with passed device type
	jp	nz,CIOSS	;03d1 - if not same - jump to DOS device Driver (4033)
	cp	$02		;03d4 - clear status flags
	ld	l,(ix+1)	;03d6 - LSB of driver address
	ld	h,(ix+2)	;03d9 - MSB of driver address
	jp	(hl)		;03dc - Jump (and ret) to the driver address in HL
;
; Device driver returns here
CIORTN:	pop	de		;03dd - restore registers from the stack
	pop	ix		;03de - which were pushed in CIO code above
	pop	hl		;03e0
	pop	bc		;03e1 - restore BC, pushed before jump to CIO
	ret			;03e2
;
; ======================================================================
; 03E3H-0457H – KEYBOARD DRIVER – “KEY”
;
;   This is the keyboard driver. It scans the keyboard and converts
;   the bit pattern obtained to ASCII and stores it in the A register.
; ----------------------------------------------------------------------
KBDDRV:	ld	hl,KYBTSS	;03e3 - keyboard work area's - saved KB rows
	ld	bc,kbdmatrix+$01;03e6 - first keyboard matrix row
	ld	d,$00		;03e9 - track the keyboard Row
KEYLP:	ld	a,(bc)		;03eb - get keyboard Row
	ld	e,a		;03ec - save keyboard row
	xor	(hl)		;03ed - compare with saved row
	ld	(hl),e		;03ee - write new value to saved row
	and	e		;03ef - mask the bits that were just observed
	jr	nz,KEYDWN	;03f0 - we found a depressed key
	inc	d		;03f2 - advance to nex row
	inc	l		;03f3 - next saved KB row address
	rlc	c		;03f4 - next KB matrix row
	jp	p,KEYLP		;03f6 - Not reached Row 8 (bit 7) of Matrix
	ret			;03f9
; ----------------------------------------------------------------------
; 03FAH – Accept a KB Down-stroke and Convert it to ASCII – “KEYDWN”
;   On entry D contains the row counter
;   and A contains the data from the keyboard matrix,
; ----------------------------------------------------------------------
KEYDWN:	ld	e,a		;03fa - column data from the matrix (redundant)
;
#IFDEF VER13
        jp	KEYBOU		;03fb jump to the new keyboard debounce routine.
KYDRES:				;03fe return address for keybounce
;
#ELSE
	ld	a,d		;03fb - initial row counter from the matrix
	rlca			;03fc
	rlca			;03fd
#ENDIF
;
	rlca			;03fe - multiply row counter by 8, gives row offset
	ld	d,a		;03ff - save row counter
	ld	c,1		;0400 - start comparison at column number 1
KEYDLP:	ld	a,c		;0402 - contains the column bit for comparison
	and	e		;0403 - compare with colum data from the matrix
	jr	nz,KEYFND	;0404 - found matching colum
	inc	d		;0406 - increment the main counter for next column
	rlc	c		;0407 - shift the column bit to next column
	jr	KEYDLP		;0409 - loop
; ----------------------------------------------------------------------
; 040BH – Part of the Keyboard routine – “KEYFND”
;   We now have identified the key. Next we need to see if it is shifted
;   On entry D contains matrix character (0-63) ie. Row*8 + Column (0-7)
; ----------------------------------------------------------------------
KEYFND:	ld	a,(kbdmatrix+$80);040b - Value from SHIFT Matrix Row 3880H
	ld	b,a		;040e - Save the Shift Row
	ld	a,d		;040f - Matrix Character in range ($00-$3F)
	add	a,$40		;0410 - Offset it by 64 ($40-$7F)
	cp	$60		;0412 - Check to see which half of the matrix
	jr	nc,KEYNAL	;0414 - if in upper half of matrix Non-alpha
	rrc	b		;0416 - Get saved Shift Key rotated into C flag
	jr	nc,KEYRTN	;0418 - Shift not pressed, return alpha ($40-$5F)
	add	a,$20		;041a - Convert to shifted Alpha ($60-$7F)
	ld	d,a		;041c - save character
	ld	a,(kbdmatrix+$40);041d - value at keyboard memory row six
	and	$10		;0420 - Was it a Down Arrow
	jr	z,KEYRT2	;0422 - Not Shift-Down, Ret Lower Case ($60-$7F)
	ld	a,d		;0424 - get saved character ($60-$7F)
	sub	$60		;0425 - Convert to CTRL Key ($00-$1F)
	jr	KEYRTN		;0427 - Return the Control Key
; ----------------------------------------------------------------------
; 0429H – Part of the Keyboard routine – “KEYNAL”
;    If we are here, the character was not alpha so need
;    to check for numeric, shifted numeric, or special
;    On Entry A contains ($60-$7F)
; ----------------------------------------------------------------------
KEYNAL:	sub	$70		;0429 - Which half of Matrix Rows 5-6 or 7-8
	jr	nc,KEYSPL	;042b - If Rows 7-8 then special character
	add	a,$40		;042d - Re-Adjust A down to contain ($30-$3F)
	cp	$3C		;042f - Check if one of the last 4 characters
	jr	c,KEYINV	;0431 - skip if "0123456789" i.e. leave unchanged
	xor	$10		;0433 - If ",-+/" then flip bit 4, align to ASCII
KEYINV:	rrc	b		;0435 - Get saved Shift Key rotated into C flag
	jr	nc,KEYRTN	;0437 - If not shifted then return ($30-$3F)
	xor	$10		;0439 - Apply the Shift to the Character
	jr	KEYRTN		;043b - If Shifted Return ($20-2F)
				;noting Shift "0" returns a <space> $20
; ----------------------------------------------------------------------
; 043DH – Part of the Keyboard routine – “KEYSPL”
;    This routine does a special key conversion via a table
;    On Entry A contains ($00-$0F)
; ----------------------------------------------------------------------
KEYSPL:	rlca			;043d - times 2, as each table row is 2 bytes
	rrc	b		;043e - Get saved Shift Key rotated into C flag
	jr	nc,KEYNSF	;0440 - If not Shifted skip next instruction
	inc	a		;0442 - if shifted align to tables second Column
KEYNSF:	ld	hl,KEYTAB	;0443 - Base Address of lookup table
	ld	c,a		;0446 - get the offset address into BC
	ld	b,$00		;0447
	add	hl,bc		;0449 - and add it to the table base address
	ld	a,(hl)		;044a - get the character to return from the table
; ----------------------------------------------------------------------
; 044BH-044BH – Part of the Keyboard routine – “KEYRTN”
;   This routine will debounce the keyboard downstroke and return
; ----------------------------------------------------------------------
KEYRTN:	ld	d,a		;044b - save value for the key pressed from A
KEYRT2:	ld	bc,3500		;044c - delay count (3500)
	call	DELAY		;044f - delay about 51.3 ms
	ld	a,d		;0452 - restore value for the key pressed
	cp	$01		;0453 - Check to see if the BREAK key was pressed
	ret	nz		;0455 - Return if the BREAK key wasn’t pressed
	rst	28h		;0456 - Disk Basic break Key handling
	ret			;0457
;
; ======================================================================
; 0458H-058CH – VIDEO DISPLAY DRIVER – “DSPDRV”
;
;   This is the video driver. On entry, the character to be displayed
;   should be in the C register. On exit, A would contain the character
;   at the cursor (if called for an INPUT). This routine handles scrolling etc.
;
;   Register IX points to the DCB, so
;   IX+0 = the DCB type,
;   IX+1 = LSB of the Driver Address, IX+2 = MSB of the Driver Address,
;   IX+3 = LSB of the Cursor Position, IX+4 = MSB of the Cursor Position,
;   IX+5 = Cursor Character, cursor on off flag
;   IX+6 = “D”, and IX+7=”O”
; ----------------------------------------------------------------------
DSPDRV:
	ld	l,(ix+3)	;0458 - LSB of the current cursor position
	ld	h,(ix+4)	;045b - MSB of the current cursor position
	jr	c,DSPRD		;045e - Jump if get last character
	ld	a,(ix+5)	;0460 - cursor on/off flag
	or	a		;0463 - set flags
	jr	z,DSPGRP	;0464 - Jump if the cursor is off
	ld	(hl),a		;0466 - Display the character under the cursor
DSPGRP:	ld	a,c		;0467 - convert and display the charater
	cp	SPACE		;0468 - is it a control code <$20
	jp	c,DSPCTL	;046a - display control code
	cp	$80		;046d - is it a graphic >= $80
	jr	nc,DSPGRC	;046f - display graphic
#IFDEF LOWCASE
	jr	DSPCHR		;0471 - Disable all Alpha CHR translation
	DEFC 	LOWCASE_ENABLED = 1
	PUBLIC 	LOWCASE_ENABLED
	DEFS	$047D - $	;UNUSED Fill Deleted code bock (ELSE) with NOP's
#ELSE
	cp	$40		;0471 - is it number or symbol ASCII 20h - 40h
	jr	c,DSPCHR	;0473 - then display it
	sub	$40		;0475 - So now upper case A is 01h
	cp	$20		;0477 - is it upper case case
	jr	c,DSPCHR	;0479 - display it
	sub	$20		;047b - convert from lower to upper case
#ENDIF
;
; Output the character, it is not a control character, tab, or special characters
;
DSPCHR:	call	DSPOUT		;047d - Display the character in A (and scroll if necessary)
;
; Completion of the Display Routines, after characters have been printed.
;
DSPSKP:	ld	a,h		;0480 - the MSB of the current cursor position
	and	$03		;0481 - Convert Cursor Pos to Vid Mem Address, clear upper bits.
	or	$3C		;0483 - then force the MSB to be 3C-3Fh (Vid Ram)
	ld	h,a		;0485 - save it back.
	ld	d,(hl)		;0486 - get the value at the location of the cursor
	ld	a,(ix+5)	;0487 - cursor on off flag
	or	a		;048a - Check to see if the cursor is on or off
	jr	z,DSPRTN	;048b - Jump if the cursor is off
	ld	(ix+5),d	;048d - cursor is on, save the character being displayed as the flag
	ld	(hl),CURCHR	;0490 - Display the cursor character
DSPRTN:	ld	(ix+3),l	;0492 - Save LSB of current cursor position
	ld	(ix+4),h	;0495 - Save MSB of current cursor position
	ld	a,c		;0498 - the character that was displayed
	ret			;0499
; ----------------------------------------------------------------------
; 049AH – Read the character at the current position of the display – “DSPRD”
; ----------------------------------------------------------------------
DSPRD:	ld	a,(ix+5)	;049a - the cursor on/off flag
	or	a		;049d - Check to see if the cursor is on or off
	ret	nz		;049e - RET if cursor is on and covering the character
	ld	a,(hl)		;049f - If cursor off, get char at the current cursor position
	ret			;04a0
; ----------------------------------------------------------------------
; 04A1H – Go to the beginning of the line – “DSPBOL”
; ----------------------------------------------------------------------
DSPBOL:	ld	a,l		;04a1 - the LSB of the current position
	and	$C0		;04a2 - point to the beginning of the line, zero the lowest 6 bits
	ld	l,a		;04a4 - save it back
	ret			;04a5
; ----------------------------------------------------------------------
; 04A6H – Handle graphic (NON ASCII) characters – “DSPHRC”
;   Called for characters $80 - $FF
; ----------------------------------------------------------------------
DSPGRC:	cp	$C0		;04a6 - check for Space compression Character
	jr	c,DSPCHR	;04a8 - It is Not. It is normal graphic, so display graphic
	sub	$C0		;04aa - convert into the number of spaces to display
	jr	z,DSPSKP	;04ac - $C0 means display 0 spaces, so Finish
	ld	b,a		;04ae - load the number of spaces to print
; ----------------------------------------------------------------------
; 04AFH – Handle Space Compression characters – “DSPSPC”
; ----------------------------------------------------------------------
DSPSPC:	ld	a,SPACE		;04af - a space character
	call	DSPOUT		;04b1 - Display It
	djnz	DSPSPC		;04b4 - Dec B, If more spaces then loop back
	jr	DSPSKP		;04b6 - Finish Off
; ----------------------------------------------------------------------
; 04B8H – Turn the cursor on – “DSPCON”
; ----------------------------------------------------------------------
DSPCON:	ld	a,(hl)		;04b8 - get char at current cursor position
DSPCN2:	ld	(ix+5),a	;04b9 - save it as the cursor on/off flag
	ret			;04bc
; ----------------------------------------------------------------------
; 04BDH – Turn the cursor off – “DSPCOF”
; ----------------------------------------------------------------------
DSPCOF:	xor	a		;04bd - clear the flag to ZERO, indicating No cursor
	jr	DSPCN2		;04be - save the Flag, and return
; ----------------------------------------------------------------------
; 04C0H – Home the cursor – “DSPHOM”
; ----------------------------------------------------------------------
DSPHOM:	ld	hl,vidmem	;04c0 - starting address of video memory
	ld	a,(CAST)	;04c3 - Shadow of Cassette Port
	and	~CAST32		;04c6 - turn off the 32 char mode bit
	ld	(CAST),a	;04c8 - save shadow copy
	out	(vidcmt),a	;04cb - write to the cassette port
	ret			;04cd
; ----------------------------------------------------------------------
; 04CEH – Backspace – “DSPBSP”
; ----------------------------------------------------------------------
DSPBSP:	dec	hl		;04ce - move cursor back 1 character
	ld	a,(CAST)	;04cf - get shadow copy of Cassette port
	and	CAST32		;04d2 - check for 32 char mode
	jr	z,DSPBS2	;04d4 - 64 char mode sip forward
	dec	hl		;04d6 - back again if 32 char mode
DSPBS2:	ld	(hl),SPACE	;04d7 - Clear the character under cursor
	ret			;04d9
; ----------------------------------------------------------------------
; 04DAH – Cursor Left – “DSPLFT”
; ----------------------------------------------------------------------
DSPLFT:	ld	a,(CAST)	;04da - get shadow copy of Cassette port
	and	CAST32		;04dd - check for 32 char mode
	call	nz,DSPLF2	;04df - if 32 char mode, move back twice
DSPLF2:	ld	a,l		;04e2 - get the lower order address
	and	$3F		;04e3 - mask 64 char line for RET below
	dec	hl		;04e5 - move back 1
	ret	nz		;04e6 - Return if still on the same line
;
; ----------------------------------------------------------------------
; 04E7H – Cursor Down – “DSPDWN”
;  This is a space saver because if the cursor isn’t on the same line
;  it needs to move down, so jumping here is also jumping to a CURSOR DOWN
;  routine that was simply a fall-through from a wrap around
; ----------------------------------------------------------------------
DSPDWN:	ld	de,vidlin	;04e7 - 1 line of 64 characters
	add	hl,de		;04ea - add to the cursor position
	ret			;04eb
; ----------------------------------------------------------------------
; 04ECH – Cursor Right – “DSPRHT”
; ----------------------------------------------------------------------
DSPRHT:	inc	hl		;04ec - advance the cursor
	ld	a,l		;04ed - LSB of the current cursor position
	and	$3F		;04ee - Mask out the upper bits
	ret	nz		;04f0 - Return if cursor still on the same line
; ----------------------------------------------------------------------
; 04F1H – Cursor Up – “DSPUP”
;  Same trick as dealing with CURSOR DOWN if there was an overflow,
;  this does a CURSOR UP if you back up too far
; ----------------------------------------------------------------------
DSPUP:	ld   de,$10000-vidlin	;04f1 - negative video line length (-64)
	add	hl,de		;04f4 - subtract 64 from current position
	ret			;04f5
; ----------------------------------------------------------------------
; 04F6H – Set up 32-Character mode – “DSPETB”
; ----------------------------------------------------------------------
DSPETB:	ld	a,(CAST)	;04f6 - get shadow copy of Cassette port
	or	CAST32		;04f9 - Set the 32 Char mode bit
	ld	(CAST),a	;04fb - save shadow copy of cassette port
	out	(vidcmt),a	;04fd - output setting the HW register
	inc	hl		;0500 - Increment the current cursor position
	ld	a,l		;0501 - get lower order byte
	and	$FE		;0502 - mask out the LSB bit, not relevant for 32char
	ld	l,a		;0504 - write it back to L, adjusting cursor position
	ret			;0505
; ----------------------------------------------------------------------
; 0506H – Process control characters – “DSPCTL”
; ----------------------------------------------------------------------
DSPCTL:
	ld	de,DSPSKP	;0506 - Completion of video display routines
	push	de		;0509 - Save the return address on the STACK
	cp	BACKS		;050a - is a backspace 08h
	jr	z,DSPBSP	;050c - then process a backspace
	cp	LINEF		;050e - is less than a line feed 0A character
	ret	c		;0510 - then nothing further to check
	cp	CURON		;0511 - compare with cursor on 0Eh
	jr	c,DSPCR		;0513 - process a CR/LF which is 0Dh
	jr	z,DSPCON	;0515 - process a cursor on.
	cp	CUROFF		;0517 - cursor off
	jr	z,DSPCOF	;0519
	cp	MODE32		;051b - turn on the 32 character per line mode
	jr	z,DSPETB	;051d
	cp	ARLEFT		;051f - move cursor left
	jr	z,DSPLFT	;0521
	cp	ARIGHT		;0523 - move cursor right
	jr	z,DSPRHT	;0525
	cp	ARDOWN		;0527 - move cursor down
	jr	z,DSPDWN	;0529
	cp	ARUP		;052b - move cursor up
	jr	z,DSPUP		;052d
	cp	CHOME		;052f - cursor home, top left
	jr	z,DSPHOM	;0531
	cp	CLINE		;0533 - cursor to SOL
	jp	z,DSPBOL	;0535
	cp	ELINE		;0538 - erase to EOL
	jr	z,DSPEOL	;053a
	cp	CLRKEY		;053c - erase to EOF
	jr	z,DSPEOF	;053e
	ret			;0540
; ----------------------------------------------------------------------
; 0541H – Part of the Display routine – “DSPOUT”
;   Output the character held in Register A and move the cursor,
;   scrolling the screen if necessary
;   HL contains the current screen address
; ----------------------------------------------------------------------
DSPOUT:
	ld	(hl),a		;0541 - write the character to video ram
	inc	hl		;0542 - next screen position
	ld	a,(CAST)	;0543 - cassette port shadow byte
	and	CAST32		;0546 - mask out 32 char mode bit
	jr	z,DSPOT2	;0548 - if not 32 character mode, skip over
	inc	hl		;054a - Skip another screen location (32 char)
DSPOT2:
	ld	a,h		;054b
	cp	$40		;054c - past end of screen at (4000h)
	ret	nz		;054e - nothing to do
	ld	de,$FFC0	;054f - => -64, ie one line of characters
	add	hl,de		;0552 - move cursor back one line
	push	hl		;0553
; ----------------------------------------------------------------------
; 0554H – Part of the Display routine – “DSPROL”
;   Scroll the screen upward by one line
; ----------------------------------------------------------------------
DSPROL:	ld	de,vidmem	;0554 - starting address of video memory (3C00h)
	ld   hl,vidmem+vidlin	;0557 - second line of vid memory
	push	bc		;055a - Save BC
	ld	bc,15*vidlin	;055b - 15 Lines of Video Memory
	ldir			;055e - MOVE 15 LINES OF VIDEO MEMORY UP ONE LINE
	pop	bc		;0560 - Restore BC
	ex	de,hl		;0561
	jr	DSPERF		;0562 - clear the last line
; ----------------------------------------------------------------------
; 0564H – Part of the Display routine – “DSPCR”
;   Display a carriage return / line feed
; ----------------------------------------------------------------------
DSPCR:	ld	a,l		;0564 - LSB of the current cursor position
	and	$C0		;0565 - make it’s at the start of the current line
	ld	l,a		;0567 - put the value back.
	push	hl		;0568 - Save current cursor position
	ld	de,vidlin	;0569 - length of video display line (64 chars)
	add	hl,de		;056c - add line to current cursor pos
	ld	a,h		;056d - MSB of the current cursor position
	cp	$40		;056e - is past end of video memory (+1)
	jr	z,DSPROL	;0570 - if past the end, scroll the screen
	pop	de		;0572 - Throw away saved cursor position
; ----------------------------------------------------------------------
; 0573H – Part of the Display routine – “DSPEOL”
;   Erase to the end of the line
; ----------------------------------------------------------------------
DSPEOL:	push	hl		;0573 - Save cursor position on the STACK
	ld	d,h		;0574 - MSB of the current cursor position
	ld	a,l		;0575 - LSB of the current cursor position
	or	$3F		;0576 - Set he EOL by setting the lower bits
	ld	e,a		;0578 - EOL of the current line
	inc	de		;0579 - starting character of next line
	jr	DSPERA		;057a - blank to address in DE, and return
; ----------------------------------------------------------------------
; 057CH – Part of the Display routine – “DSPEOF”
;   Erase to the end of the frame. clear the video screen from (including)
;   position N – where N is an integer between 0 and 1023 (decimal),
;   inclusive, to the end of the display, Load the HL Register with the
;   value 3C00H + N and then CALL DSPEOF
; ----------------------------------------------------------------------
DSPEOF:	push	hl		;057c - Save cursor position on the STACK
DSPERF:	ld      de,vidmem+1024  ;057d - end of video memory (4000H)
DSPERA:	ld	(hl),SPACE	;0580 - write a space to cursor
	inc	hl		;0582 - next position
	ld	a,h		;0583 - MSB of the video memory pointer
	cp	d		;0584 - compare with end of VID ram ($40)
	jr	nz,DSPERA	;0585 - Loop back if not finished
	ld	a,l		;0587 - LSB of the video memory pointer
	cp	e		;0588 - compare with end of VID ram ($0)
	jr	nz,DSPERA	;0589 - Loop back if not finished
	pop	hl		;058b - retrieve the saved cusor position
	ret			;058c
;
; ======================================================================
; 058DH – PRINTER DRIVER – “PRT”
;
;   This is the Printer Driver. On entry, Register C to hold the character
;   to be sent to the printer, and [IX] should point to the DCB,
; ----------------------------------------------------------------------
PRTDRV:	ld	a,c		;058d
	or	a		;058e
	jr	z,PRTSTA	;058f - If char=0 then get the printer status and return
	cp	VERTAB		;0591 - is a skip to the top of the form Vertical Tab
	jr	z,PRTVT		;0593 - Jump if it is a Vertical Tab
	cp	FORMF		;0595 - is conditional skip to the top of the form Form Feed
	jr	nz,PRTIT	;0597 - if not form feed - jump and print char
	xor	a		;0599
	or	(ix+3)		;059a
	jr	z,PRTIT		;059d - Jump if zero lines are to be skipped
PRTVT:	ld	a,(ix+3)	;059f - number of lines on the page
	sub	(ix+4)		;05a2 - number of lines printed
	ld	b,a		;05a5 - number of lines left to print
PRTFF:	call	PRTSTA		;05a6 - Call the GET PRINTER STATUS routine
	jr	nz,PRTFF	;05a9 - Loop back until the printer is ready
	ld	a,LINEF		;05ab - We print line feed character(s)
#IFNDEF EACA80
	ld	(prtstat),a	;05ad - Send the character to the printer port 37E8H
#ELSE
	nop			;05ad
	out	(prtport),a	;05ae - On Dick Smith System-80 (EACA) use IO port
#ENDIF
	djnz	PRTFF		;05b0 - Loop back until all of the lines have been skipped
	jr	PRTOP		;05b2 - all lines skipped, reset the line counter and ret
; ----------------------------------------------------------------------
; Printing of normal character starts here
; ----------------------------------------------------------------------
PRTIT:	push	af		;05b4
PRTIT2:	call	PRTSTA		;05b5 - Call the GET PRINTER STATUS routine
	jr	nz,PRTIT2	;05b8 - Loop back until the printer is ready
	pop	af		;05ba
#IFNDEF EACA80
	ld	(prtstat),a	;05ad - Send the character to the printer port 37E8H
#ELSE
	nop			;05bb
	out	(prtport),a	;05bc - On Dick Smith System-80 (EACA) use IO port
#ENDIF
	cp	ENTER		;05be
	ret	nz		;05c0
	inc	(ix+4)		;05c1
	ld	a,(ix+4)	;05c4
	cp	(ix+3)		;05c7
	ld	a,c		;05ca
	ret	nz		;05cb
PRTOP:	ld	(ix+4),0	;05cc
	ret			;05d0
;
; ======================================================================
; 05D1H – Get printer status routine – “PRTSTA”
;
;   Returns the status of the line printer in the status register as
;   zero if the printer is ready, and non-zero if not ready.
; ----------------------------------------------------------------------
PRTSTA:
#IFNDEF EACA80
	ld	a,(prtstat)	;05d1 - Get the status value from the printer (37E8H)
#ELSE
	nop			;05d1
	in	a,(prtport)	;05d2 - On Dick Smith System-80 (EACA) use IO port
#ENDIF
	and	$F0		;05d4
	cp	$30		;05d6
	ret			;05d8
;
; ======================================================================
; 05D9H – Wait For Next Line – “KEYIN”
;
;   Accepts keyboard input and stores each character in a
;   buffer supplied by caller. Input continues until either a
;   carriage return or a BREAK is typed, or until the buffer is
;   full. All edit control codes are recognized, e.g. TAB,
;   BACKSPACE, etc. The calling sequence is: On exit the
;   registers contain
;
;   On exit the registers contain: HL=Buffer address, B=num chars transmitted
;   excluding last, C=Orginal buffer size, A=Last character received
;   if a carriage return or BREAK is typed.
;   Carry Set if break key was terminator, reset otherwise.
;   If the buffer is full, the A Register will contain the buffer size.
; ----------------------------------------------------------------------
KEYIN:	push	hl		;05d9
	ld	a,CURON		;05da - turn on the cursor character
	call	_DSP		;05dc
	ld	c,b		;05df
KLNNXT:	call	_KEY		;05e0
	cp	SPACE		;05e3
	jr	nc,KLNCHR	;05e5
	cp	ENTER		;05e7 - ENTER
	jp	z,KLNCR		;05e9
	cp	CLRKEY		;05ec - CLEAR
	jr	z,KLNCLR	;05ee
	cp	BREAK		;05f0 - BREAK
	jr	z,KLNBRK	;05f2
	ld	de,KLNNXT	;05f4
	push	de		;05f7
	cp	BACKS		;05f8 - Backspace (left arrow)
	jr	z,KLNBSP	;05fa
	cp	ARLEFT		;05fc - Shifted left arrow
	jr	z,KLNCAN	;05fe
	cp	TAB		;0600 - TAB (right arrow)
	jr	z,KLNHT		;0602
	cp	ARIGHT		;0604 - Shifted Right Arrow
	jr	z,KLNETB	;0606
	cp	LINEF		;0608
	ret	nz		;060a
	pop	de		;060b
; ----------------------------------------------------------------------
; Printable Character
; ----------------------------------------------------------------------
KLNCHR:	ld	(hl),a		;060c
	ld	a,b		;060d
	or	a		;060e
	jr	z,KLNNXT	;060f
	ld	a,(hl)		;0611
	inc	hl		;0612
	call	_DSP		;0613
	dec	b		;0616
	jr	KLNNXT		;0617
; ----------------------------------------------------------------------
; 0619H – Part of the Display routine – “KLNCLR”
;   Clear the screen
; ----------------------------------------------------------------------
KLNCLR:	call	CLS		;0619
	ld	b,c		;061c
	pop	hl		;061d
	push	hl		;061e
	jp	KLNNXT		;061f
; ----------------------------------------------------------------------
; 0622H – Part of the Display routine – “KLNCNL”
;   Cancel the accumulated line
; ----------------------------------------------------------------------
KLNCNL:	call	KLNBSP		;0622
	dec	hl		;0625
	ld	a,(hl)		;0626
	inc	hl		;0627
	cp	LINEF		;0628
	ret	z		;062a
KLNCAN:	ld	a,b		;062b
	cp	c		;062c
	jr	nz,KLNCNL	;062d
	ret			;062f
; ----------------------------------------------------------------------
; 0630H – Part of the Display routine – “KLNBSP”
;   Backspace one character. On entry Register B to hold the number
;   of characters received, and Register C to hold the size of the buffer
; ----------------------------------------------------------------------
KLNBSP:	ld	a,b		;0630
	cp	c		;0631
	ret	z		;0632
	dec	hl		;0633
	ld	a,(hl)		;0634
	cp	LINEF		;0635
	inc	hl		;0637
	ret	z		;0638
	dec	hl		;0639
	ld	a,BACKS		;063a
	call	_DSP		;063c
	inc	b		;063f
	ret			;0640
; ----------------------------------------------------------------------
; 0641H – Part of the Display routine – “KLNETB”
;   Turn on 32 Character Mode
; ----------------------------------------------------------------------
KLNETB:	ld	a,MODE32	;0641 - turn on the 32 character per line mode character
	jp	_DSP		;0643
; ----------------------------------------------------------------------
; 0646H – Part of the Display routine – “KLNHT”
;   Process a horizontal tab
; ----------------------------------------------------------------------
KLNHT:	call	DSPPOS		;0646
	and	$07		;0649
	cpl			;064b
	inc	a		;064c
	add	a,$08		;064d
	ld	e,a		;064f
KLNHTL:	ld	a,b		;0650
	or	a		;0651
	ret	z		;0652
	ld	a,SPACE		;0653
	ld	(hl),a		;0655
	inc	hl		;0656
	push	de		;0657
	call	_DSP		;0658
	pop	de		;065b
	dec	b		;065c
	dec	e		;065d
	ret	z		;065e
	jr	KLNHTL		;065f
; ----------------------------------------------------------------------
; 0661H – Part of the Display routine – “KLNBRK”
;   Process a Carriage Return and Automatic Line Feed
; ----------------------------------------------------------------------
KLNBRK:	scf			;0661
KLNCR:	push	af		;0662
	ld	a,ENTER		;0663
	ld	(hl),a		;0665
	call	_DSP		;0666
	ld	a,CUROFF	;0669 - turn off the cursor character
	call	_DSP		;066b
	ld	a,c		;066e
	sub	b		;066f
	ld	b,a		;0670
	pop	af		;0671
	pop	hl		;0672
	ret			;0673
;
; ----------------------------------------------------------------------
; 0674H-06D1H – INITIALIZATION ROUTINE – "INIT"
;   System initialisation.
;   - Enter with CMT/Video port init value in A.
;     On reset, A=0: 64 char video mode, CMT motor relay off, CMT out = 0.85 V.
; ----------------------------------------------------------------------
INIT:
	out	(vidcmt),a	;0674 - reset the Video cassette latch, A=0
;
INITA1:	ld	hl,INITR	;0676 - starting address of the RST’s and DCB’s
	ld	de,RAM		;0679 - starting address of the RAM comms region
	ld	bc,$36		;067c - move 54 bytes
	ldir			;067f - Move 6D2-707 to 4000-4035
;
	dec	a		;0681 - count down by 2 starting at 0
	dec	a		;0682 - so effective loop
	jr	nz,INITA1	;0683 - Loop back until block move occurred 128 times
;
	ld	b,$27		;0685 - 39 bytes of memory need to be zerod
CLRAM:	ld	(de),a		;0687 - zero byte in memory starting at 4036h
	inc	de		;0688 - next address
	djnz	CLRAM		;0689 - loop until filled zero's till 4062h
; ----------------------------------------------------------------------
;  Check for a manual override
; ----------------------------------------------------------------------
	ld	a,(kbdmatrix+$40);068b - value at keyboard BREAK KEY
	and	$04		;068e - if the BREAK key is being pressed
	jp	nz,INIT2	;0690 - Jump if the BREAK key was pressed
;
	; This is the beginning of the routine which boots a diskette
	ld	sp,TMPSTK	;0693 - $407D since Disk load will overite > $4200
#IFDEF FREHDBT
	; FreHD includes these 3 bytes by removing code below (06ac)
	call	HDBOOT		;0696 - Call to the FreHD hd boot routines.
#ENDIF
	ld	a,(diskstat)	;0696 - status of the disk controller (37ECH)
	inc	a		;0699 - FF => 0, 0 => 1
	cp	$02		;069a - is disk controller present.
	jp	c,INIT2		;069c - Jump to Level II Init if no disk controller
;
;   fallthrough for floppy boot
; ----------------------------------------------------------------------
; 069FH-06CBH – Bootstrap from Diskette – "BOOT"
; Now we know (can assume) there is a disk controller and we should boot it.
; ----------------------------------------------------------------------
;
BOOT:	ld	a,$01		;069f - Drive 0
	ld	(dskselect),a	;06a1 - Select Drive, turning motor on
;
	ld	hl,diskstat	;06a4 - address of the disk command/status Register 37ECH
	ld	de,diskdata	;06a7 - address of the disk data Register (37EFH)
	ld	(hl),$03	;06aa - command 03H (RESTORE and POSITION TO TRACK 0)
#IFNDEF FREHDBT
	; FreHD excludes  these 3 bytes for call HDBOOT above (696h)
	; noting it is expected tha BC = 0000 at this point of the execution
	ld	bc,$0000	;06ac
#ENDIF
	call	DELAY		;06af - delay (BC times 14.65) about 3 seconds
;
BOOTDL:	bit	0,(hl)		;06b2 - is the diskette controller is busy
	jr	nz,BOOTDL	;06b4 - Wait until it is ready
;
	xor	a		;06b6
	ld	(disksect),a	;06b7 - set the disk sector register with 0
	ld	bc,MEMEND	;06ba - address to read sector data (4200H)
	ld	a,$8C		;06bd - command to read single IBM formatted sector
	ld	(hl),a		;06bf - send command to FDC register
;
BOOTLP:	bit	1,(hl)		;06c0 - check to see if there is data available
	jr	z,BOOTLP	;06c2 - loop indefinitely until data ready
;
BOOTRD:	ld	a,(de)		;06c4 - load byte from disk data register
	ld	(bc),a		;06c5 - write byte to ram.
	inc	c		;06c6 - next mem address
	jr	nz,BOOTLP	;06c7 - Loop until whole 256 byte sector has been read
	jp	MEMEND		;06c9 - Hand execution to the boot sector code $4200
;
; ----------------------------------------------------------------------
; 06CCH-06CEH – (Model 1 Only!) - re-entry point into BASIC – "RESETR"
;  This is the best re-entry point to BASIC on the Model I.
;  This is an alternative re-entry point into BASIC.
;  A JP 6CCH is often better than a jump to 1A19H.
; ----------------------------------------------------------------------
	ASSERT	$ == $06CC, "Segment: BASIC Entry Point Should start at $06CC"
;
RESETR:	ld	bc,STPRDY	;06cc - Address of 1A18
	jp	ERESET		;06cf - Jumps to 19AE
; ----------------------------------------------------------------------
; 06D2H-0707H – ROM STORAGE LOCATION FOR DATA TO BE MOVED TO RAM
;   BY THE INITIALIZATION PROCESS – “INITR”
;   Note These $36 bytes are moved to RAM at address $4000 during init
; ----------------------------------------------------------------------
INITR:
; RST Code vectors, each is a 3 byte instruction
	jp	SYNCHR		;4000 (mRST1) - RST 00H
	jp	CHRGTR		;4003 (mRST2) - RST 10H
	jp	DCOMPR		;4006 (mRST3) - RST 18H
	jp	GETYPR		;4009 (mRST4) - RST 20H
	ret			;400C (mRST5) - RST 28H
	NOP2
	ret			;400F (mRST6) - RST 30H
	NOP2
	ei			;4012 (mRST7) - RST 38H (Interrupt)
	ret
	nop
; Keyboard DCB
	DEFB	1		; 4015 (mKDCB) - Device Type = 1 for KB (Read only)
	DEFW	KBDDRV		; 4016 - keyboard driver address
	DEFB	0		; 4017 - Not used on Model 1
	DEFB	0		; 4018 - Not used on Model 1
	DEFB	0		; 4019 - Not used on Model 1
	DEFB	"KI"
; Display DCB
	DEFB	7		; 401D (mDDCB) - Device Type = 7 for VID
	DEFW	DSPDRV		; 401E - DISPLAY driver address
	DEFW	vidmem		; 4020 (CURSOR) - Cursor Position (3C00H to 3FFFH)
	DEFB	0		; 4022 - Character "covered" on video by Cursor
	DEFB	"DO"
; Printer DCB
	DEFB	6		; 4025 (mPDCB) - Device Type = 6 for Printer
	DEFW	PRTDRV		; 4026 - printer driver address
	DEFB	67		; 4028 - lines per page
	DEFB	0		; 4029 - Current Line Number
	DEFB	0		; 402A - Not used on Model 1
	DEFB	"PR"
;
; Normal Disk Operating System re-entry vector.
	jp	$5000		; 402D - MAKE SYS1 (10) DOS REQUEST,
				; typically JP 4400H
; Abnormal DOS re-entry
	rst	00h		; 4030 - DOS REQUEST CODE FOR SYS1
	NOP2			; typically LD A,A3 followed by RST 28
; DOS Device Vectoring Routine
	ld	a, 0		; 4033 (CIOSS) - CALL DOS DEVICE DRIVER (CIOSS)
	ret			; typically will JP 44BBh
;
; ======================================================================
; ======================================================================
;
; LEVEL 2 BASIC ROUTINES $0708 - $2B28
;
INCLUDE	"LEVEL2BASIC-0708.Z80"
;
ASSERT $ == $2B29, "Segment: Continuation at $2B29"
;
; ======================================================================
; ======================================================================
;
; ----------------------------------------------------------------------
; 2B29-2B2D – LEVEL II BASIC LLIST ROUTINE – “LLIST”
;   This routine sets the output device flag to PRINTER and then
;   flows through to the LIST command.
; ----------------------------------------------------------------------
LLIST:	ld	a,DEV1PRT	;2b29 - the output device code for the printer (1)
	ld	(PRTFLG),a	;2b2b - Save the current output device type number
; ----------------------------------------------------------------------
; 2B2E-2B74 – LEVEL II BASIC LIST ROUTINE – “LIST”
;   On entry the STACK has the return address, then the first basic line
;   number to be listed, then the last basic line number to be listed.
; ----------------------------------------------------------------------
LIST:	pop	bc		;2b2e
	call	SCNLINE		;2b2f
	push	bc		;2b32
LIST4:	ld	hl,$FFFF	;2b33
	ld	(CURLIN),hl	;2b36
	pop	hl		;2b39
	pop	de		;2b3a
	ld	c,(hl)		;2b3b
	inc	hl		;2b3c
	ld	b,(hl)		;2b3d
	inc	hl		;2b3e
	ld	a,b		;2b3f
	or	c		;2b40
	jp	z,READY		;2b41
	call	EXCHDS		;2b44
	call	ISCNTN		;2b47
	push	bc		;2b4a
	ld	c,(hl)		;2b4b
	inc	hl		;2b4c
	ld	b,(hl)		;2b4d
	inc	hl		;2b4e
	push	bc		;2b4f
	ex	(sp),hl		;2b50
	ex	de,hl		;2b51
	CPDEHL			;2b52
	pop	bc		;2b53
	jp	c,STPRDY	;2b54
	ex	(sp),hl		;2b57
	push	hl		;2b58
	push	bc		;2b59
	ex	de,hl		;2b5a
	ld	(DOT),hl	;2b5b
	call	LINPRT		;2b5e
	ld	a,SPACE		;2b61
	pop	hl		;2b63
	call	OUTDO		;2b64
	call	BUFLIN		;2b67
	ld	hl,(BUFPNT)	;2b6a
	call	LISPRT		;2b6d
	call	CRDO		;2b70
	jr	LIST4		;2b73
; ----------------------------------------------------------------------
; 2B75-2B7D – DISPLAY MESSAGE ROUTINE – “LISPRT”
;  Output a string to device indicated by device type flag stored
;  at 409CH. On entry, HL registers must point to address of start of string.
;  String must end with zero byte. Calls routine at 032AH
;  (note warning for that routine)
; ----------------------------------------------------------------------
LISPRT:	ld	a,(hl)		;2b75
	or	a		;2b76
	ret	z		;2b77
	call	OUTDO		;2b78
	inc	hl		;2b7b
	jr	LISPRT		;2b7c
; ----------------------------------------------------------------------
; 2B7E-2BC5 – UNTOKENIZE ROUTINE – “BUFLIN”
; ----------------------------------------------------------------------
BUFLIN:	push	hl		;2b7e
	ld	hl,(BUFPNT)	;2b7f
	ld	b,h		;2b82
	ld	c,l		;2b83
	pop	hl		;2b84
	ld	d,$FF		;2b85
	jr	PLOOP2		;2b87
PLOOP:	inc	bc		;2b89
	dec	d		;2b8a
	ret	z		;2b8b
PLOOP2:	ld	a,(hl)		;2b8c
	or	a		;2b8d
	inc	hl		;2b8e
	ld	(bc),a		;2b8f
	ret	z		;2b90
	jp	p,PLOOP		;2b91
	cp	TKSNQT		;2b94 - single quote token
	jr	nz,NRQTTK	;2b96
	dec	bc		;2b98
	dec	bc		;2b99
	dec	bc		;2b9a
	dec	bc		;2b9b
	inc	d		;2b9c
	inc	d		;2b9d
	inc	d		;2b9e
	inc	d		;2b9f
NRQTTK:	cp	TKELSE		;2ba0 - else token
	call	z,DCXBRT	;2ba2
	sub	$7F		;2ba5
	push	hl		;2ba7
	ld	e,a		;2ba8
	ld	hl,RESLST	;2ba9 - starting address of the reserved words list
LOPRES:	ld	a,(hl)		;2bac
	or	a		;2bad
	inc	hl		;2bae
	jp	p,LOPRES	;2baf
	dec	e		;2bb2
	jr	nz,LOPRES	;2bb3
	and	$7F		;2bb5
MORPUR:	ld	(bc),a		;2bb7
	inc	bc		;2bb8
	dec	d		;2bb9
	jp	z,PPSWRT	;2bba
	ld	a,(hl)		;2bbd
	inc	hl		;2bbe
	or	a		;2bbf
	jp	p,MORPUR	;2bc0
	pop	hl		;2bc3
	jr	PLOOP2		;2bc4
; ----------------------------------------------------------------------
; DELETE
; ----------------------------------------------------------------------
DELETE:	call	SCNLINE		;2bc6
	pop	de		;2bc9
	push	bc		;2bca
	push	bc		;2bcb
	call	FNDLIN		;2bcc
	jr	nc,FCERRG	;2bcf
	ld	d,h		;2bd1
	ld	e,l		;2bd2
	ex	(sp),hl		;2bd3
	push	hl		;2bd4
	CPDEHL			;2bd5
FCERRG:	jp	nc,FCERR	;2bd6
	ld	hl,m_REDDY	;2bd9
	call	STROUT		;2bdc
	pop	bc		;2bdf
	ld	hl,FINI		;2be0
	ex	(sp),hl		;2be3
DELDEL:	ex	de,hl		;2be4
	ld	hl,(VARTAB)	;2be5
MLOOP:	ld	a,(de)		;2be8
	ld	(bc),a		;2be9
	inc	bc		;2bea
	inc	de		;2beb
	CPDEHL			;2bec
	jr	nz,MLOOP	;2bed
	ld	h,b		;2bef
	ld	l,c		;2bf0
	ld	(VARTAB),hl	;2bf1
	ret			;2bf4
; ----------------------------------------------------------------------
; 2BF5-2C1E – LEVEL II BASIC CSAVE ROUTINE – “CSAVE”
; ----------------------------------------------------------------------
CSAVE:	call	CWRTON		;2bf5
	call	FRMEVL		;2bf8
	push	hl		;2bfb
	call	ASC2		;2bfc
	ld	a,$D3		;2bff - the filename header byte (=D3H which is a “S” with the sign bit on)
	call	CASOUT		;2c01
	call	TWOCSO		;2c04
	ld	a,(de)		;2c07
	call	CASOUT		;2c08
	ld	hl,(TXTTAB)	;2c0b
	ex	de,hl		;2c0e
	ld	hl,(VARTAB)	;2c0f
LOPSCO:	ld	a,(de)		;2c12
	inc	de		;2c13
	call	CASOUT		;2c14
	CPDEHL			;2c17
	jr	nz,LOPSCO	;2c18
	call	CTOFF		;2c1a
	pop	hl		;2c1d
	ret			;2c1e
; ----------------------------------------------------------------------
; 2C1F-2CA4 – LEVEL II BASIC CLOAD ROUTINE – “CLOAD”
; ----------------------------------------------------------------------
;
#IFDEF VER13
;
CLOAD:	sub	$B2		;2C1F Test for CLOAD? * CLOAD routine
	jr	z,CLOADP	;2C21 Jmp if CLOAD?
	xor	a		;2C23 Signal CLOAD
	;
	DEFB	LDBCNN		; Trick LD BC,NN, skipping next 2 instructions
	;
CLOADP:	cpl			;2C25 CPL A=-1 if CLOAD?, 0000 if CLOAD
	inc	hl		;2C26 INC HL position to file name Save CLOAD? / CLOAD flag
	push	af		;2C27
	ld	a,(hl)		;2C28 Get next element from code string. Should be file name
	or	a		;2C29 Set status flags
	jr	z,CLOADR	;2C2A Jmp if end of line
	call	FRMEVL		;2C2C Evaluate expression (get file name)
	call	ASC2		;2C2F Get addr of file name into DE
CLOADQ:	ld	a,(de)		;2C32 Get file name
CLOADR:	ld	l,a		;2C33 And move it to L-reg
	pop	af		;2C34 Restore CLOAD? / CLOAD flags
	or	a		;2C35 Set status register according to flags
	ld	h,a		;2C36 H=CLOAD?/CLOAD flag, L=file name
	ld	(FACLO),hl	;2C37 Save flag and file name in WRA1
	call	z,SCRTCH	;2C3A If CLOAD call NEW routine to initialize system variables
	ld	hl,$0000	;2C3D This will cause the drive to be selected when
	call	CSRDON 		;2C40 We look for leader and synch byte
;
#ELSE
;
CLOAD:	call	CSRDON		;2c1f
	ld	a,(hl)		;2c22
	sub	$B2		;2c23
	jr	z,CLOADP	;2c25
	xor	a		;2c27
;
	DEFB	LDBCNN		;2c28 - Z80 Trick - LD BC,nnnn - skip next 2 bytes
;
CLOADP:	cpl			;2c29
	inc	hl		;2c2a
	push	af		;2c2b
	dec	hl		;2c2c
	GETCHR			;2c2d - rst 10h
	ld	a,$00		;2c2e
	jr	z,CLNONM	;2c30
	call	FRMEVL		;2c32
	call	ASC2		;2c35
	ld	a,(de)		;2c38
CLNONM:	ld	l,a		;2c39
	pop	af		;2c3a
	or	a		;2c3b
	ld	h,a		;2c3c
	ld	(FACLO),hl	;2c3d
	call	z,SCRTCH	;2c40
;
#ENDIF
	ld	hl,(FACLO)	;2c43
	ex	de,hl		;2c46
LOPCLK:	ld	b,$03		;2c47
LOPCL2:	call	CASIN		;2c49
	sub	$D3		;2c4c
	jr	nz,LOPCLK	;2c4e
	djnz	LOPCL2		;2c50
	call	CASIN		;2c52
	inc	e		;2c55
	dec	e		;2c56
	jr	z,NONAMC	;2c57
	cp	e		;2c59
	jr	nz,SKPFIL	;2c5a
NONAMC:	ld	hl,(TXTTAB)	;2c5c
; ----------------------------------------------------------------------
; This loop is going to read a byte, compare it to the next byte in the
; program memory, jump away if it doesn’t match AND CLOAD? was chosen,
; write	(or overwrite) that byte to memory, check for a zero, and loop
; back	IF no zero was found.
; ----------------------------------------------------------------------
DOCRS:	ld	b,$03		;2c5f - number of zeros to look for to stop the load
DOCSMR:	call	CASIN		;2c61
	ld	e,a		;2c64
	sub	(hl)		;2c65
	and	d		;2c66
	jr	nz,NOGOOD	;2c67 - if CLOAD? was selected but the bytes don’t match
	ld	(hl),e		;2c69 - save the character we read to memory pointer in HL
	call	REASON		;2c6a - Make sure there is more room, if not a ?OM ERROR
	ld	a,(hl)		;2c6d
	or	a		;2c6e
	inc	hl		;2c6f
	jr	nz,DOCRS	;2c70 - Loop if the byte in Register A isn’t equal to zero
	call	BCASIN		;2c72
	djnz	DOCSMR		;2c75 - Do that loop until three zeros in a row have been read
	ld	(VARTAB),hl	;2c77 - Save the new end of the BASIC program pointer.
	ld	hl,m_REDDY	;2c7a
	call	STROUT		;2c7d
	call	CTOFF		;2c80
	ld	hl,(TXTTAB)	;2c83 - the start of the BASIC program pointer.
	push	hl		;2c86 - Save the BASIC program pointer to the STACK, for FINI
	jp	FINI		;2c87 - reinitialize the BASIC interpreter and continue
NOGOOD:	ld	hl,NOOKCS	;2c8a
	call	STROUT		;2c8d
	jp	STPRDY		;2c90
SKPFIL:	ld	(vidmem+$3E),a	;2c93
ZERSRF:	ld	b,$03		;2c96
GETCHZ:	call	CASIN		;2c98
	or	a		;2c9b
	jr	nz,ZERSRF	;2c9c
	djnz	GETCHZ		;2c9e
	call	CSRDON3		;2ca0
	jr	LOPCLK		;2ca3
; ----------------------------------------------------------------------
;
; ======================================================================
; ======================================================================
;
; LEVEL 2 BASIC ROUTINES $2CA5 - $2B28
;
INCLUDE	"LEVEL2BASIC-2CA5.Z80"
;
ASSERT $ == $2FFB, "Segment: Continuation at $2FFB"
;
; ======================================================================
; ======================================================================
;
; ----------------------------------------------------------------------
; 2FFB - 2FFF - UNUSED bytes - serves no purpose used for checksum
	DEFB	$DE, $C3, $C3, $44, $B2
;
; ======================================================================
; THE END OF THE LEVEL II BASIC ROMS
; ======================================================================
;                END OF CODE
; ======================================================================
;
; ======================================================================
;
; PADDING to create 16KB ROM Image, to allow append multiple
; versions into a larger (modern) paged ROM file.
;
#IFDEF	SIZE16K
	DEFS	(4000h - $),$FF
#ENDIF
;
; ======================================================================
