;
; ======================================================================
; Shared LEVEL2 BASIC code for TRS-80 MODEL 1 & MODEL 3
; ======================================================================
;
ASSERT $ == $012D, "Segment: Level 2 Basic - Should start at $012D"
;
; DEFINES USED INTERNALLY
;
; BUGFIX32 - No Dependancies (MODEL 3 ONLY)
;
; ======================================================================
;
; ----------------------------------------------------------------------
; 012DH – ?L3 ERROR ENTRY POINT – "L3ERR"
; ----------------------------------------------------------------------
L3ERR:	ld	e,ERRL3		;012d - Load Register E with the ?L3 ERROR code of 2CH
	jp	ERROR		;012f
;
; ----------------------------------------------------------------------
; 0132H-0134H –	LEVEL II BASIC POINT COMMAND ENTRY POINT – "POINT"
; ----------------------------------------------------------------------
POINT:	GETCHR			;0132 - rst 10h
	xor	a		;0133
;
; Z-80 Trick! The byte at this memory location, 01H, is there to turn the real instruction
; that follows (the operative action of the SET command) into a harmless LD BC,xxxx.
; This way, they didn’t have to jump over SET or RESET to get to the common graphics code.
; If parsing straight down, this loads BC with 0380H and then moves to 0136H. But if jump
; straight to 0136H, you skip that 01H opcode, and get a real instruciton of 3EH 80H
	DEFB	LDBCNN		;0134
;
; ----------------------------------------------------------------------
; 0135H-0137H – LEVEL II BASIC SET COMMAND ENTRY POINT – “SET”
; ----------------------------------------------------------------------
SET:	ld	a,$80		;0135
	DEFB	LDBCNN		;0137 - See comment above about what this does
;
; ----------------------------------------------------------------------
; 0138H-0139H – LEVEL II BASIC RESET COMMAND ENTRY POINT – “RESET”
; ----------------------------------------------------------------------
RESET:	ld	a,$01		;0138
;
; ----------------------------------------------------------------------
; 013AH-019CH GRAPHICS ROUTINE - Common Code for SET RESET and POINT
;   A will be 0 if POINT, 80H if SET and 1 for RESET.
; ----------------------------------------------------------------------
;
	push	af		;013a
	SYNTAX	('(')		;013b - rst 08h - all commands start with a (
	call	GETBYT		;013d - get a numeric value X coordinate
	cp	128		;0140 - compare X coordinate with 128
	jp	nc,FCERR	;0142 - if greater equal to 127 then an error
	push	af		;0145 - Save coordinate’s X value on the STACK
	SYNTAX	(',')		;0146 - rst 08h - then a comma
	call	GETBYT		;0148 - get a numeric value Y coordinate
	cp	48		;014b - compare Y coordinate with 48
	jp	nc,FCERR	;014d - if greater equal to 48 then an error
	ld	d,$FF		;0150
LOPMD3:	inc	d		;0152
	sub	$03		;0153
	jr	nc,LOPMD3	;0155
	add	a,$03		;0157
	ld	c,a		;0159
	pop	af		;015a
	add	a,a		;015b
	ld	e,a		;015c
#IFDEF BUGFIX32
	srl   	d
	rr    	e
	srl   	d
	rr    	e
	nop			; this routine saves 1 byte, used in following code
#ELSE
	ld	b,$02		;015d
SHFTW:	ld	a,d		;015f
	rra			;0160
	ld	d,a		;0161
	ld	a,e		;0162
	rra			;0163
	ld	e,a		;0164
	djnz	SHFTW		;0165
#ENDIF
	ld	a,c		;0167
	adc	a,a		;0168
	inc	a		;0169
	ld	b,a		;016a
	xor	a		;016b
	scf			;016c
PWR2:	adc	a,a		;016d
	djnz	PWR2		;016e
	ld	c,a		;0170
	ld	a,d		;0171
	or	$3C		;0172 - Set the bits of the MSB of the video memory offset
	ld	d,a		;0174 - revised MSB of the video memory pointer
	ld	a,(de)		;0175 - the char at the location of the video memory pointer
#IFDEF BUGFIX32
	ld	b,$80		;017a - set graphic blank (assume at this point)
	cp	64		; COMPARE
	;
	; It works because as signed values the graphics characters are -128 .. -65.
	; Subtract 64 as the compare does and they will overflow due to the result
	; (-192 .. -129) not fitting in a signed byte.
	; The special characters are -64 .. -1 and don't overflow.
	; And none of the ASCII characters from 0 .. 127 overflow either.
	;
	jp	nv,GFXFIX	; if Not Graphic then keep $80
	ld	b,a		;017c - otherwise use he value in A as it is valid
GFXFIX:
#ELSE
	;
	; The following code is bugged. What it is supposed to do is see if the character
	; on the screen in the location to be modified is already a graphic, to build upon,
	; or not, to erase and then build. It does this by checking to see if the character
	; is ≥128, which is fine for the Model I. But on the Model III, there are valid
	; characters above 192, and if one of those is present, it thinks its a graphic
	; character and just flips bits, changing the character but not actually putting up a graphic.
	;
	or	a		;0176 - set flags for char in vid memory location
	jp	m,FND4		;0177 - sign bit HIGH, graphic character, skip next opcode
	ld	a,$80		;017a - set graphic blank
FND4:	ld	b,a		;017c - saving it into B
#ENDIF
	pop	af		;017d
	or	a		;017e
	ld	a,b		;017f
	jr	z,TBIT		;0180
	ld	(de),a		;0182
	jp	m,SBIT		;0183
	ld	a,c		;0186
	cpl			;0187
	ld	c,a		;0188
	ld	a,(de)		;0189
	and	c		;018a
FINSTB:	ld	(de),a		;018b
FINPTB:	SYNTAX	(')')		;018c - rst 08h
	ret			;018e
SBIT:	or	c		;018f
	jr	FINSTB		;0190
TBIT:	and	c		;0192
	add	a,$FF		;0193
	sbc	a,a		;0195
	push	hl		;0196
	call	CONIA		;0197
	pop	hl		;019a
	jr	FINPTB		;019b
;
; ----------------------------------------------------------------------
; 019DH-01C8H – LEVEL II BASIC INKEY$ ROUTINE – “INKEY”
ASSERT $ = $019D, "Routine INKEY$ should have correct entry point"
; ----------------------------------------------------------------------
INKEY:	GETCHR			;019d - rst 10h
; ----------------------------------------------------------------------
; 019E - Create 1 character string from keyboard input (TAS)
; ----------------------------------------------------------------------
	push	hl		;019e
	ld	a,(CHARC)	;019f
	or	a		;01a2
	jr	nz,BUFCIN	;01a3
	call	ISCHAR		;01a5
	or	a		;01a8
	jr	z,NULRT		;01a9
BUFCIN:	push	af		;01ab
	xor	a		;01ac
	ld	(CHARC),a	;01ad
	inc	a		;01b0
	call	STRINI		;01b1
	pop	af		;01b4
	ld	hl,(DSCTMP+1)	;01b5
	ld	(hl),a		;01b8
	jp	PUTNEW		;01b9
NULRT:	ld	hl,m_REDDY-1	;01bc
	ld	(FACLO),hl	;01bf
	ld	a,VTSTR		;01c2 - String Value Type
	ld	(VALTYP),a	;01c4
	pop	hl		;01c7
	ret			;01c8
;
; ======================================================================
; 01C9H – LEVEL II BASIC CLS ROUTINE – "CLS"
;
;   Clear the screen, select 64 characters and home the cursor.
;   All registers are used.
; ----------------------------------------------------------------------
CLS:	ld	a,CHOME		;01c9 - ascii for cursor Home
	call	OUT2D		;01cb - display it
	ld	a,CLRKEY	;01ce - ascii for erase to end of frame
	jp	OUT2D		;01d0 - call and return
;
; ======================================================================
; 01D3H – LEVEL II BASIC REFRESH RANDOM ROUTINE – “RANDOM”
;
;   This is part of the RANDOM routine which takes a value out of the
;   REFRESH register, stores it in location 40ABH and then returns.
;   A call to 01D3H reseeds the random number seed (location 40AB)
;   with the current contents of the refresh register.
; ----------------------------------------------------------------------
RANDOM:	ld	a,r		;01d3 - R (refresh) Reg - semi random number.
	ld	(RNDX+1),a	;01d5
	ret			;01d8
;
