; ======================================================================
; Shared LEVEL2 BASIC code for TRS-80 MODEL 1 & MODEL 3
; ======================================================================
;
	ASSERT $ == $0708, "Segment: Level 2 Basic - Should start at $0708"
;
; DEFINES USED INTERNALLY
;
; BUGFIX1 - Dependancy on DSPLINLTH (provided externally)
; BUGFIX2 - Dependancy on RND0FIX (provided externally)
; BUGFIX5 - No Dependancies
; BUGFIX7 - Dependancy on INFINEFIX (provided externally)
; BUGFIX7C - Dependancy on TABERFIX (provided externally)
; BUGFIX8 - No Dependancies
; BUGFIX11 - Dependancy on INTNXTOVER (provided externally)
;
; VER12 - Downgrade Model 1 from Rev 1.3 to Revision 1.2
; EACA80 - Applies Dick Smith System 80 Changes (minor)
; MODEL3ROM - Upgrades to Model 3
;
; NOCASSETTE - Disables BASIC Calls to Cassette Routines
;
; ======================================================================
; MATH ROUTINES
; ======================================================================
;
; ----------------------------------------------------------------------
; 0708H-070FH – SINGLE PRECISION ADDITION,
;   ACCumulator = (HL) + ACCumulator – “FADDH”
; ----------------------------------------------------------------------
FADDH:	ld	hl,FHALF	;0708
FADDS:	call	MOVRM		;070b
	jr	FADD		;070e
; ----------------------------------------------------------------------
; 0710H-0712H – SINGLE PRECISION SUBTRACTION,
;   ACCumulator = (HL) – ACCumulator - “FSUBS”
; ----------------------------------------------------------------------
FSUBS:	call	MOVRM		;0710
;
; ======================================================================
; 0713H – LEVEL II BASIC SINGLE PRECISION SUBTRACTION - “FSUB”
;
;   Subtracts the single precision value in (BC:DE) from the
;   single precision value in WRA1. The difference is left in WRA1.
; ----------------------------------------------------------------------
FSUB:	call	NNEG		;0713
;
; ======================================================================
; 0716H – LEVEL II BASIC SINGLE PRECISION ADDITION - “FADD”
;
;   Add the single precision value in (BC:DE) to the single
;   precision value in WRA1. The sum is left in WRA1
; ----------------------------------------------------------------------
FADD:	ld	a,b		;0716
	or	a		;0717
	ret	z		;0718
	ld	a,(FAC)		;0719
	or	a		;071c
	jp	z,MOVFR		;071d - Move single in BC:DE into ACC
	sub	b		;0720
	jr	nc,FADD1	;0721
	cpl			;0723
	inc	a		;0724
	ex	de,hl		;0725
	call	PUSHF		;0726
	ex	de,hl		;0729
	call	MOVFR		;072a - Move single in BC:DE into ACC
	pop	bc		;072d
	pop	de		;072e
FADD1:	cp	$19		;072f
	ret	nc		;0731
	push	af		;0732
	call	UNPACK		;0733
	ld	h,a		;0736
	pop	af		;0737
	call	SHIFTR		;0738
	or	h		;073b
	ld	hl,FACLO	;073c
	jp	p,FADD3		;073f
	call	FADDA		;0742
	jp	nc,ROUND	;0745 - Round a Single Number
	inc	hl		;0748
	inc	(hl)		;0749
	jp	z,OVERR		;074a
	ld	l,$01		;074d
	call	SHRADD		;074f
	jr	ROUND		;0752 - Round a Single Number
FADD3:	xor	a		;0754
	sub	b		;0755
	ld	b,a		;0756
	ld	a,(hl)		;0757
	sbc	a,e		;0758
	ld	e,a		;0759
	inc	hl		;075a
	ld	a,(hl)		;075b
	sbc	a,d		;075c
	ld	d,a		;075d
	inc	hl		;075e
	ld	a,(hl)		;075f
	sbc	a,c		;0760
	ld	c,a		;0761
FADFLT:	call	c,NGER		;0762
; ----------------------------------------------------------------------
; Normalizes BC:DE. In doing so, ABCDE and HL are all modified.
;   This routine shifts the mantissa left until the MSB is a 1.
; ----------------------------------------------------------------------
NORMAL:	ld	l,b		;0765
	ld	h,e		;0766
	xor	a		;0767
NORM1:	ld	b,a		;0768
	ld	a,c		;0769
	or	a		;076a
	jr	nz,NORM3	;076b
	ld	c,d		;076d
	ld	d,h		;076e
	ld	h,l		;076f
	ld	l,a		;0770
	ld	a,b		;0771
	sub	$08		;0772
	cp	$E0		;0774
	jr	nz,NORM1	;0776
; ----------------------------------------------------------------------
; This routine will ZERO out the ACCumulator,
;   changing only Register A in the process. A will exit as 0.
; ----------------------------------------------------------------------
ZERO:	xor	a		;0778
ZERO0:	ld	(FAC),a		;0779
	ret			;077c
; ----------------------------------------------------------------------
; 077DH-07A7H – SINGLE PRECISION MATH SUPPORT ROUTINE – “NORM2”
; ----------------------------------------------------------------------
NORM2:	dec	b		;077d
	add	hl,hl		;077e
	ld	a,d		;077f
	rla			;0780
	ld	d,a		;0781
	ld	a,c		;0782
	adc	a,a		;0783
	ld	c,a		;0784
NORM3:	jp	p,NORM2		;0785
	ld	a,b		;0788
	ld	e,h		;0789
	ld	b,l		;078a
	or	a		;078b
	jr	z,ROUND		;078c
	ld	hl,FAC		;078e
	add	a,(hl)		;0791
	ld	(hl),a		;0792
	jr	nc,ZERO		;0793
	ret	z		;0795
; ----------------------------------------------------------------------
; 0796H-07A7H – SINGLE PRECISION MATH ROUTINE – “ROUND”
; The "ROUND" routine rounds the result in BC:DE and puts the result into the ACCumulator.
; All registers are affected. BC:DE is rounded up or down based on the MSB of Register B.
; ----------------------------------------------------------------------
ROUND:	ld	a,b		;0796
ROUNDB:	ld	hl,FAC		;0797
	or	a		;079a
	call	m,ROUNDA	;079b
	ld	b,(hl)		;079e
	inc	hl		;079f
	ld	a,(hl)		;07a0
	and	$80		;07a1
	xor	c		;07a3
	ld	c,a		;07a4
	jp	MOVFR		;07a5 - Save the number into the ACCumulator
; ----------------------------------------------------------------------
; 07A8H-07B6H – SINGLE PRECISION MATH SUPPORT ROUTINE – “ROUNDA”
;   This is a subroutine within the ROUND round. This will add one to C/D/E.
; ----------------------------------------------------------------------
ROUNDA:	inc	e		;07a8
	ret	nz		;07a9
	inc	d		;07aa
	ret	nz		;07ab
	inc	c		;07ac
	ret	nz		;07ad
	ld	c,$80		;07ae
	inc	(hl)		;07b0
	ret	nz		;07b1
; ----------------------------------------------------------------------
; 07B2H – ?OV ERROR ENTRY POINT – “OVERR”
; ----------------------------------------------------------------------
OVERR:	ld	e,ERROV		;07b2
	jp	ERROR		;07b4
; ----------------------------------------------------------------------
; 07B7H-07C2H SINGLE PRECISION MATH ROUTINE – “FADDA”
;   This routine adds (HL+2),)(HL+1),(HL+0) to C,D,E.
; ----------------------------------------------------------------------
FADDA:	ld	a,(hl)		;07b7
	add	a,e		;07b8
	ld	e,a		;07b9
	inc	hl		;07ba
	ld	a,(hl)		;07bb
	adc	a,d		;07bc
	ld	d,a		;07bd
	inc	hl		;07be
	ld	a,(hl)		;07bf
	adc	a,c		;07c0
	ld	c,a		;07c1
	ret			;07c2
; ----------------------------------------------------------------------
; 07C3H-07D6H – SINGLE PRECISION MATH ROUTINE – NEGR
;   This routine negates the number in C/D/E/B.
; ----------------------------------------------------------------------
NGER:	ld	hl,FACSGN	;07c3
	ld	a,(hl)		;07c6
	cpl			;07c7
	ld	(hl),a		;07c8
	xor	a		;07c9
	ld	l,a		;07ca
	sub	b		;07cb
	ld	b,a		;07cc
	ld	a,l		;07cd
	sbc	a,e		;07ce
	ld	e,a		;07cf
	ld	a,l		;07d0
	sbc	a,d		;07d1
	ld	d,a		;07d2
	ld	a,l		;07d3
	sbc	a,c		;07d4
	ld	c,a		;07d5
	ret			;07d6
; ----------------------------------------------------------------------
; 07D7H-07F7H – SINGLE PRECISION MATH ROUTINE – “SHIFTR”
;   This routine will shift the number in C/D/E right the number of times
;   held in Register A. The general idea is to shift right 8 places
;   as many times as is possible within the number of times in A,
;   and then jump out to shift single bits once you can't shift 8
;   at a time anymore. Alters everything except Register H.
; ----------------------------------------------------------------------
SHIFTR:	ld	b,$00		;07d7
SHIFTR1: sub	$08		;07d9
	jr	c,SHFTR2	;07db
	ld	b,e		;07dd
	ld	e,d		;07de
	ld	d,c		;07df
	ld	c,$00		;07e0
	jr	SHIFTR1		;07e2
; ----------------------------------------------------------------------
; 07E4 – SINGLE PRECISION MATH ROUTINE – “SHFTR2”
;   This routine will shift the number in C/D/E right the number
;   of times held in Register A, but one byte at a time.
; ----------------------------------------------------------------------
SHFTR2:	add	a,$09		;07e4
	ld	l,a		;07e6
SHFTR3:	xor	a		;07e7
	dec	l		;07e8
	ret	z		;07e9
	ld	a,c		;07ea
SHRADD:	rra			;07eb
	ld	c,a		;07ec
	ld	a,d		;07ed
	rra			;07ee
	ld	d,a		;07ef
	ld	a,e		;07f0
	rra			;07f1
	ld	e,a		;07f2
	ld	a,b		;07f3
	rra			;07f4
	ld	b,a		;07f5
	jr	SHFTR3		;07f6
;
; ----------------------------------------------------------------------
; 07F8H-07FBH – SINGLE PRECISION CONSTANT STORAGE LOCATION – “FONE”
; ----------------------------------------------------------------------
FONE:	DEFB	0, 0, 0, $81	; store a value of 1.0
	; Note: This constant exists $1604, so possibly could be replaced?
;
; ----------------------------------------------------------------------
; 07FCH-0808H – SINGLE PRECISION CONSTANTS STORAGE LOCATION 2 – “LOGCN2”
; ----------------------------------------------------------------------
LOGCN2:	DEFB	3			; count of numbers in table
	DEFB	$AA, $56, $19, $80	; 0.598978650
	DEFB	$F1, $22, $76, $80	; 0.961470632
	DEFB	$45, $AA, $38, $82	; 2.88539129
;
; ======================================================================
; 0809H – LEVEL II BASIC LOG ROUTINE – “FNLOG”
;
;   Computes the natural log (base E) of the single precision value in
;   WRA1. The result is returned as a single precision value in WRA1.
; ----------------------------------------------------------------------
FNLOG:	call	SIGN		;0809
	or	a		;080c
	jp	pe,FCERR	;080d
	ld	hl,FAC		;0810
	ld	a,(hl)		;0813
	ld	bc,$8035	;0814
	ld	de,$04F3	;0817
	sub	b		;081a
	push	af		;081b
	ld	(hl),b		;081c
	push	de		;081d
	push	bc		;081e
	call	FADD		;081f
	pop	bc		;0822
	pop	de		;0823
	inc	b		;0824
	call	FDIV		;0825
	ld	hl,FONE		;0828
	call	FSUBS		;082b
	ld	hl,LOGCN2	;082e
	call	POLYX		;0831
	ld	bc,$8080	;0834
	ld	de,$0000	;0837
	call	FADD		;083a
	pop	af		;083d
	call	FINLOG		;083e
MULLN2:	ld	bc,$8031	;0841
	ld	de,$7218	;0844
; fall into the multiplication routine.
;
; ======================================================================
; 0847H – LEVEL II BASIC SINGLE PRECISION MULTIPLICATION, – “FMULT”
;
;   Single-precision multiplication (ACCumulator=BC:DE*ACC or ACC = ARG * FAC)).
;   Multiplies the current value in the ACCumulator by the value in (BC:DE).
;   the product is left in the ACCumulator.
; ----------------------------------------------------------------------
FMULT:	call	SIGN		;0847
	ret	z		;084a
	ld	l,$00		;084b
	call	MULDIV		;084d
	ld	a,c		;0850
	ld	(FMLTT1),a	;0851
	ex	de,hl		;0854
	ld	(FMLTT2),hl	;0855
	ld	bc,$0000	;0858
	ld	d,b		;085b
	ld	e,b		;085c
	ld	hl,NORMAL	;085d
	push	hl		;0860
	ld	hl,FMULT2	;0861
	push	hl		;0864
	push	hl		;0865
	ld	hl,FACLO	;0866
FMULT2:	ld	a,(hl)		;0869
	inc	hl		;086a
	or	a		;086b
	jr	z,FMULT3	;086c
	push	hl		;086e
	ld	l,$08		;086f
FMULT4:	rra			;0871
	ld	h,a		;0872
	ld	a,c		;0873
	jr	nc,FMULT5	;0874
	push	hl		;0876
	ld	hl,(FMLTT2)	;0877
	add	hl,de		;087a
	ex	de,hl		;087b
	pop	hl		;087c
	ld	a,(FMLTT1)	;087d
	adc	a,c		;0880
FMULT5:	rra			;0881
	ld	c,a		;0882
	ld	a,d		;0883
	rra			;0884
	ld	d,a		;0885
	ld	a,e		;0886
	rra			;0887
	ld	e,a		;0888
	ld	a,b		;0889
	rra			;088a
	ld	b,a		;088b
	dec	l		;088c
	ld	a,h		;088d
	jr	nz,FMULT4	;088e
POPHRT:	pop	hl		;0890
	ret			;0891
FMULT3:	ld	b,e		;0892
	ld	e,d		;0893
	ld	d,c		;0894
	ld	c,a		;0895
	ret			;0896
;
; ----------------------------------------------------------------------
; 0897H-08A1H – SINGLE PRECISION MATH ROUTINE – “DIV10”
;   This routine divides the ACCumulator by 10. Every Register is used.
; ----------------------------------------------------------------------
DIV10:	call	PUSHF		;0897
	ld	hl,FTEN		;089a
	call	MOVFM		;089d
FDIVT:	pop	bc		;08a0
	pop	de		;08a1
; ----------------------------------------------------------------------
; 08A2H-0903H – LEVEL II BASIC SINGLE PRECISION DIVISION – “FDIV”
;   Single-precision division (ACCumulator=BC:DE/ACCumulator or
;   ACC = ARG / ACC). If ACCumulator=0 a ” /0 ERROR ” will result.
; ----------------------------------------------------------------------
FDIV:	call	SIGN		;08a2
	jp	z,DV0ERR	;08a5
	ld	l,$FF		;08a8
	call	MULDIV		;08aa
	inc	(hl)		;08ad
	inc	(hl)		;08ae
	dec	hl		;08af
	ld	a,(hl)		;08b0
	ld	(FDIVA+1),a	;08b1
	dec	hl		;08b4
	ld	a,(hl)		;08b5
	ld	(FDIVB+1),a	;08b6
	dec	hl		;08b9
	ld	a,(hl)		;08ba
	ld	(FDIVC+1),a	;08bb
	ld	b,c		;08be
	ex	de,hl		;08bf
	xor	a		;08c0
	ld	c,a		;08c1
	ld	d,a		;08c2
	ld	e,a		;08c3
	ld	(FDIVG+1),a	;08c4
FDIV1:	push	hl		;08c7
	push	bc		;08c8
	ld	a,l		;08c9
	call	FDIVC		;08ca - subtraction rountine in RAM buffer
	sbc	a,$00		;08cd
	ccf			;08cf
	jr	nc,FDIV2	;08d0
	ld	(FDIVG+1),a	;08d2
	pop	af		;08d5
	pop	af		;08d6
;
	scf			;08d7 - Z80 Trick - Set Carry Flag
	DEFB	JPNCNN		;08d8 - JP NC,nnnn - skip next 2 instruction
;
FDIV2:	pop	bc		;08d9
	pop	hl		;08da
	ld	a,c		;08db
	inc	a		;08dc
	dec	a		;08dd
	rra			;08de
	jp	m,ROUNDB	;08df
	rla			;08e2
	ld	a,e		;08e3
	rla			;08e4
	ld	e,a		;08e5
	ld	a,d		;08e6
	rla			;08e7
	ld	d,a		;08e8
	ld	a,c		;08e9
	rla			;08ea
	ld	c,a		;08eb
	add	hl,hl		;08ec
	ld	a,b		;08ed
	rla			;08ee
	ld	b,a		;08ef
	ld	a,(FDIVG+1)	;08f0
	rla			;08f3
	ld	(FDIVG+1),a	;08f4
	ld	a,c		;08f7
	or	d		;08f8
	or	e		;08f9
	jr	nz,FDIV1	;08fa
	push	hl		;08fc
	ld	hl,FAC		;08fd
	dec	(hl)		;0900
	pop	hl		;0901
	jr	nz,FDIV1	;0902
	jp	OVERR		;0904
; ----------------------------------------------------------------------
; 0907H-0913H – DOUBLE PRECISION MATH ROUTINE – “MULDVS”
;   This routine is to check for special cases and to add exponents for
;   the FMULT and FDIV routines. Registers A, B, H and L are modified.
; ----------------------------------------------------------------------
MULDVS:	ld	a,$FF		;0907
;
	DEFB	LDLNN		;0909 - Z80 Trick - LD L,nn - skip next instruction
;
MULDVA:	xor	a		;090a
	ld	hl,ARG-1	;090b
	ld	c,(hl)		;090e
	inc	hl		;090f
	xor	(hl)		;0910
	ld	b,a		;0911
	ld	l,$00		;0912
; ----------------------------------------------------------------------
; 0914H-0930H – SINGLE PRECISION MATH ROUTINE – “MULDIV”
; ----------------------------------------------------------------------
MULDIV:	ld	a,b		;0914
	or	a		;0915
	jr	z,MULDV2	;0916
	ld	a,l		;0918
	ld	hl,FAC		;0919
	xor	(hl)		;091c
	add	a,b		;091d
	ld	b,a		;091e
	rra			;091f
	xor	b		;0920
	ld	a,b		;0921
	jp	p,MULDV1	;0922
	add	a,$80		;0925
	ld	(hl),a		;0927
	jp	z,POPHRT	;0928 - Routine to Pop HL and Return
	call	UNPACK		;092b
	ld	(hl),a		;092e
DCXHRT:	dec	hl		;092f
	ret			;0930
; ----------------------------------------------------------------------
; 0931H-093DH – SINGLE PRECISION MATH ROUTINE – “MLDVEX”
;   This routine is called from EXP. If jumped here will checks if ACC=0.
;   If so, the Z flag will be set
; ----------------------------------------------------------------------
MLDVEX:	call	SIGN		;0931
	cpl			;0934
	pop	hl		;0935
MULDV1:	or	a		;0936
MULDV2:	pop	hl		;0937
	jp	p,ZERO		;0938
	jp	OVERR		;093b
; ----------------------------------------------------------------------
; 093EH-0954H – SINGLE PRECISION MATH ROUTINE – “MUL10”
;   This routine multiplies the ACCumulator by 10. Every register is modified.
; ----------------------------------------------------------------------
MUL10:	call	MOVRF		;093e - loads the SINGLE in ACC into BC:DE
	ld	a,b		;0941 - exponent
	or	a		;0942
	ret	z		;0943 - RET if exponent is 0, nothing to do
	add	a,$02		;0944 - multiply exponent by 4
	jp	c,OVERR		;0946 - OV error if too big
	ld	b,a		;0949 - Put back
	call	FADD		;094a - Multiply by 5, by adding 4X valuse back
	ld	hl,FAC		;094d - exponent register
	inc	(hl)		;0950 - inc the exponent -> Multiply by 2
	ret	nz		;0951 - RET
	jp	OVERR		;0952 - otherwise overflow
; ----------------------------------------------------------------------
; 0955H-0963H – SINGLE DOUBLE MATH ROUTINE – “SIGN” (Accumulator)
;   Puts the SIGN of the ACCumulator into Register A.
;   Only Register A is modified by this routine;
;   the ACCumulator is left untouched.
; ----------------------------------------------------------------------
SIGN:	ld	a,(FAC)		;0955
	or	a		;0958
	ret	z		;0959
	ld	a,(FAC-1)	;095a
;
	DEFB	CPNN		;095d - Z80 Trick - CP nn - skip next bytye
;
FCOMPS:	cpl			;095e
; ----------------------------------------------------------------------
ICOMPS:	rla			;095f - sign bit in Register A into the CARRY FLAG
SIGNS:	sbc	a,a		;0960 - If the CARRY FLAG is 0 (i.e., POSITIVE), make Register A = 0.
				;       If the CARRY FLAG is 1 (i.e., NEGATIVE), make Register A = FFH
	ret	nz		;0961 - Return If the CARRY FLAG was 1, (negative)
	inc	a		;0962 - Register A will be equal to 1
	ret			;0963
; ----------------------------------------------------------------------
; 0964H-0976H – MATH CONVERSION ROUTINE – “FLOAT”
;   This routine will take a signed integer held in Register A and
;   turn it into a floating point number. All registers are modified.
; ----------------------------------------------------------------------
FLOAT:	ld	b,$88		;0964
	ld	de,0		;0966
; ----------------------------------------------------------------------
; This routine will float the singed number in B/A/D/E.
; All registers are modified.
; ----------------------------------------------------------------------
FLOATR:	ld	hl,FAC		;0969
	ld	c,a		;096c
	ld	(hl),b		;096d
	ld	b,0		;096e
	inc	hl		;0970
	ld	(hl),$80	;0971
	rla			;0973
	jp	FADFLT		;0974
;
; ======================================================================
; 0977H – LEVEL II BASIC ABS() ROUTINE – “FNABS”
;
;   ABS routine (ACCumulator=ABS(ACCumulator)) input and output can be integer,
;   single-precision or double-precision, depending on what is placed in the NTF
; ----------------------------------------------------------------------
FNABS:	call	VSIGN		;0977
	ret	p		;097a
; ----------------------------------------------------------------------
; This routine will negate any value in the ACCumulator. Every Register is affected.
; ----------------------------------------------------------------------
VNEG:	GETYPE			;097b - RST 20 - check the current number type
	jp	m,INEG		;097c
	jp	z,TMERR		;097f
; ----------------------------------------------------------------------
; This routine will negate the single or double precision number in the ACCumulator.
; Registers A, H, and L are affected.
; ----------------------------------------------------------------------
NNEG:	ld	hl,FAC-1	;0982
	ld	a,(hl)		;0985
	xor	$80		;0986
	ld	(hl),a		;0988
	ret			;0989
;
; ----------------------------------------------------------------------
; 098AH-0993H – LEVEL II BASIC SGN() ROUTINE – “FNSGN”
;   SGN function (ACCumulator=SGN(ACCumulator)). After execution, NTF=2
;   and ACCumulator=-l, 0 or 1 depending on sign and value of ACC before
;   execution. Registers A, H, and L are affected.
; ----------------------------------------------------------------------
FNSGN:	call	VSIGN		;098a
; ----------------------------------------------------------------------
; This routine will convert a signed number (held in Register A) into an integer.
; ----------------------------------------------------------------------
CONIA:	ld	l,a		;098d
	rla			;098e
	sbc	a,a		;098f
	ld	h,a		;0990
	jp	MAKINT		;0991 - Move INT in HL into the ACCumulator
;
; ----------------------------------------------------------------------
; 0994H – MATH COMPARE ROUTINE – “VSIGN” (Accumulator)
;   This routine checks the sign of the ACCumulator. NTF must be set.
;   After execution A register=00 if ACCumulator=0, A=01 if ACC > 0
;   or A=FFH if A < 1. The Flags are also valid.
; ----------------------------------------------------------------------
VSIGN:	GETYPE			;0994 - RST 20 - check the current number type
	jp	z,TMERR		;0995
	jp	p,SIGN		;0998
; ----------------------------------------------------------------------
; 099BH - MATH COMPARE ROUTINE - INTEGER SIGN (Accumulator)
;   Finds the sign of the Integer value held in the Accumulator
; ----------------------------------------------------------------------
ISIGNA:	ld	hl,(FACLO)	;099b
;
; ----------------------------------------------------------------------
; 099EH - MATH COMPARE ROUTINE - INTEGER SIGN (HL)
;   Finds the sign of the value held at (HL). Only Register A is altered.
; ----------------------------------------------------------------------
ISIGN:	ld	a,h		;099e
	or	l		;099f
	ret	z		;09a0
	ld	a,h		;09a1
	jr	ICOMPS		;09a2
; ----------------------------------------------------------------------
; 09A4H – SINGLE PRECISION MATH ROUTINE – “PUSHF” - MOVE
;   Moves the single precision value in the ACCumulator to the STACK
;   It is Assumed that ACCumulator contains a single precision value
;   A, BC and HL are unchanged by this function.
; ----------------------------------------------------------------------
PUSHF:	ex	de,hl		;09a4
	ld	hl,(FACLO)	;09a5
	ex	(sp),hl		;09a8
	push	hl		;09a9
	ld	hl,(FAC-1)	;09aa
	ex	(sp),hl		;09ad
	push	hl		;09ae
	ex	de,hl		;09af
	ret			;09b0
;
; ----------------------------------------------------------------------
; 09B1H – SINGLE PRECISION MATH ROUTINE – “MOVFM” - MOVE
;   This routine moves a number from memory (pointed to by HL) into the ACC
;   All registers except Register A are affected, with HL = HL + 4 on exit.
; ----------------------------------------------------------------------
MOVFM:	call	MOVRM		;09b1
; ----------------------------------------------------------------------
; 09B4H – SINGLE PRECISION MATH ROUTINE – “MOVFR” - MOVE
;   Store the single precision value in BC:DE into ACC. Destroys value in BC:DE.
; ----------------------------------------------------------------------
MOVFR:	ex	de,hl		;09b4
	ld	(FACLO),hl	;09b5
	ld	h,b		;09b8
	ld	l,c		;09b9
	ld	(FAC-1),hl	;09ba
	ex	de,hl		;09bd
	ret			;09be
; ----------------------------------------------------------------------
; 09BFH – SINGLE PRECISION MATH ROUTINE – “MOVRF” - MOVE
;   It loads four bytes from ACCumulator (single) into the BC:DE Register Pairs.
;   Only Register A is unchanged.
; ----------------------------------------------------------------------
MOVRF:	ld	hl,FACLO	;09bf
; ----------------------------------------------------------------------
; 09C2H – SINGLE PRECISION MATH ROUTINE – “MOVRM” - MOVE
;   It loads four byte Single, pointed by HL, into the BC:DE Register Pairs.
;   HL is incremented. Only Register A and Flags are unchanged.
; ----------------------------------------------------------------------
MOVRM:	ld	e,(hl)		;09c2
	inc	hl		;09c3
GETBCD:	ld	d,(hl)		;09c4
	inc	hl		;09c5
	ld	c,(hl)		;09c6
	inc	hl		;09c7
	ld	b,(hl)		;09c8
INXHRT:	inc	hl		;09c9
	ret			;09ca
; ----------------------------------------------------------------------
; 09CBH – SINGLE PRECISION MATH ROUTINE – “MOVMF” - MOVE
;   Copy a Single Precision value from ACCumulator to memory address
;   pointed to by HL. Modifies all Registers except for C
; ----------------------------------------------------------------------
MOVMF:	ld	de,FACLO	;09cb
; ----------------------------------------------------------------------
; 09CEH – SINGLE PRECISION MATH ROUTINE – “MOVE” - MOVE
;   Copy a Single Precision value from from the location pointed to by DE
;   into the location pointed to by HL. Modifies all Registers except for C
; ----------------------------------------------------------------------
MOVE:	ld	b,VTSNG		;09ce - Move 4 bytes
	jr	MOVE1		;09d0
; ----------------------------------------------------------------------
; 09D2H – MOVE VALUE FROM HL TO DE - “MOVVFM”
;   moves the number of bytes specified in the variable type flag
;   from the address in HL to the address in DE. Uses A, B, DE and HL.
; ----------------------------------------------------------------------
MOVVFM:	ex	de,hl		;09d2
; ----------------------------------------------------------------------
; 09D3H – MOVE VALUE FROM DE TO HL - “VMOVE”
;   moves the number of bytes specified in the variable type flag (VALTYP)
;   from the address in DE to the address in HL. Uses A, B, DE and HL.
; ----------------------------------------------------------------------
VMOVE:	ld	a,(VALTYP)	;09d3
; ----------------------------------------------------------------------
; 09D6H – MOVE VALUE FROM DE TO HL - “VMOVEA”
;   moves the number of bytes specified in A register
;   from the address in DE to the address in HL. Uses A, B, DE and HL.
; ----------------------------------------------------------------------
VMOVEA:	ld	b,a		;09d6
; ----------------------------------------------------------------------
; 09D7H – MOVE VALUE FROM DE TO HL - “MOVE1”
;   moves the number of bytes specified in B register
;   from the address in DE to the address in HL. Uses A, B, DE and HL.
; ----------------------------------------------------------------------
MOVE1:	ld	a,(de)		;09d7
	ld	(hl),a		;09d8
	inc	de		;09d9
	inc	hl		;09da
	dec	b		;09db
	jr	nz,MOVE1	;09dc
	ret			;09de
; ----------------------------------------------------------------------
; 09DFH-09F3H – SINGLE PRECISION MATH ROUTINE – “UNPACK”
;   This routine “UNPACKS” the ACCumulator and the Registers.
;   Registers A, C, H, and L are altered.
; ----------------------------------------------------------------------
UNPACK:	ld	hl,FAC-1	;09df
	ld	a,(hl)		;09e2
	rlca			;09e3
	scf			;09e4
	rra			;09e5
	ld	(hl),a		;09e6
	ccf			;09e7
	rra			;09e8
	inc	hl		;09e9
	inc	hl		;09ea
	ld	(hl),a		;09eb
	ld	a,c		;09ec
	rlca			;09ed
	scf			;09ee
	rra			;09ef
	ld	c,a		;09f0
	rra			;09f1
	xor	(hl)		;09f2
	ret			;09f3
; ----------------------------------------------------------------------
; 09F4H-09FBH – MOVE FROM ACCUM2 TO ACCUM – “VMOVFA”
;   Copy any precision value from ACCUM2 to ACCUM.
;   Precision and number of bytes moved determined by NTF.
; ----------------------------------------------------------------------
VMOVFA:	ld	hl,ARGLO	;09f4 - Source Address Register 2
; ----------------------------------------------------------------------
; 09F7 – MOVE FROM (HL) TO ACCUM – “VMOVFA”
;   Copy any precision value from address pointed to by HL to ACCUM
;   Precision and number of bytes moved determined by NTF.
; ----------------------------------------------------------------------
VMOVFM:	ld	de,MOVVFM	;09f7 - Pointer to Move from HL to DE
	jr	VMOVMF		;09fa
; ----------------------------------------------------------------------
; 09FCH – MOVE FROM ACCUM TO ACCUM2 – “VMOVAF”
;   Copy any precision value from ACCUM to ACCUM2.
;   Precision and number of bytes moved determined by NTF.
;   All Registers except C are affected.
; ----------------------------------------------------------------------
VMOVAF:	ld	hl,ARGLO	;09fc - Target address of Register 2
; ----------------------------------------------------------------------
; 09FFH – MOVE FROM ACCUM TO (HL) – “VMOVAF”
;   Copy any precision value from ACCUM to address pointed to by HL.
;   Precision and number of bytes moved determined by NTF.
;   All Registers except C are affected.
; ----------------------------------------------------------------------
	ld	de,VMOVE	;09ff - Pointer to Move from DE to HL
VMOVMF:	push	de		;0a02 - saved as return address
VDFACS:	ld	de,FACLO	;0a03 - Register 1 Single - Address
	GETYPE			;0a06 - RST 20 - check the current number type
	ret	c		;0a07 - Process 4 bytes - return to VMOVE
	ld	de,DFACLO	;0a08 - Register 1 Double - Address
	ret			;0a0b - return via move operation
;
; ======================================================================
; 0A0CH – LEVEL II BASIC SINGLE PRECISION COMPARE – “FCOMP”
;
;   This routine will compare two single precision numbers.
;   On Exit, A=1 if ARG < ACCumulator, A=0 if ARG=Accmulator,
;   and A=-1 if ARG > ACCumulator. This routine exits with the CF on.
;   Alters Registers A, H, and L.
; ----------------------------------------------------------------------
FCOMP:	ld	a,b		;0a0c
	or	a		;0a0d
	jp	z,SIGN		;0a0e
	ld	hl,FCOMPS	;0a11 - Load Register Pair HL with a return address to the FCOMPS routine
	push	hl		;0a14
	call	SIGN		;0a15
	ld	a,c		;0a18
	ret	z		;0a19
	ld	hl,FAC-1	;0a1a
	xor	(hl)		;0a1d
	ld	a,c		;0a1e
	ret	m		;0a1f
	call	FCOMP2		;0a20
FCOMPD:	rra			;0a23
	xor	c		;0a24
	ret			;0a25
FCOMP2:	inc	hl		;0a26
	ld	a,b		;0a27
	cp	(hl)		;0a28
	ret	nz		;0a29
	dec	hl		;0a2a
	ld	a,c		;0a2b
	cp	(hl)		;0a2c
	ret	nz		;0a2d
	dec	hl		;0a2e
	ld	a,d		;0a2f
	cp	(hl)		;0a30
	ret	nz		;0a31
	dec	hl		;0a32
	ld	a,e		;0a33
	sub	(hl)		;0a34
	ret	nz		;0a35
	pop	hl		;0a36
	pop	hl		;0a37
	ret			;0a38
;
; ======================================================================
; 0A39H – LEVEL II BASIC INTEGER COMPARISON ROUTINE – “ICOMP”
;
;   Integer compare. Compares HL with DE. After execution,
;     A=0   if HL=DE,
;     A=1   if HL>DE
;     A=FFH if HL<DE.
;   The S and Z flags are valid.
; ----------------------------------------------------------------------
ICOMP:	ld	a,d		;0a39
	xor	h		;0a3a
	ld	a,h		;0a3b
	jp	m,ICOMPS	;0a3c
	cp	d		;0a3f
	jp	nz,SIGNS	;0a40
	ld	a,l		;0a43
	sub	e		;0a44
	jp	nz,SIGNS	;0a45
	ret			;0a48
; ----------------------------------------------------------------------
; 0A49H-0A77H – DOUBLE PRECISION COMPARISON ROUTINE – “DCOMPD”
;   Double-precision compare. Compares ACCumulator with the ARG
;   (a/k/a REG 2). After execution the A Register will contain:
;   A=0 if ACCumulator=ARG (a/k/a REG 2), A=1 if ACC > ARG (a/k/a REG 2)
;   or A=FFH if ACC < ARG (a/k/a REG 2). S and Z flags are valid.
; ----------------------------------------------------------------------
DCOMPD:	ld	hl,ARGLO	;0a49
	call	VMOVE		;0a4c
XDCOMP:	ld	de,ARG		;0a4f
	ld	a,(de)		;0a52
	or	a		;0a53
	jp	z,SIGN		;0a54
	ld	hl,FCOMPS	;0a57
	push	hl		;0a5a
	call	SIGN		;0a5b
	dec	de		;0a5e
	ld	a,(de)		;0a5f
	ld	c,a		;0a60
	ret	z		;0a61
	ld	hl,FAC-1	;0a62
	xor	(hl)		;0a65
	ld	a,c		;0a66
	ret	m		;0a67
	inc	de		;0a68
	inc	hl		;0a69
	ld	b,$08		;0a6a
DCOMP1:	ld	a,(de)		;0a6c
	sub	(hl)		;0a6d
	jp	nz,FCOMPD	;0a6e
	dec	de		;0a71
	dec	hl		;0a72
	dec	b		;0a73
	jr	nz,DCOMP1	;0a74
	pop	bc		;0a76
	ret			;0a77
;
; ======================================================================
; 0A78H – LEVEL II BASIC DOUBLE PRECISION COMPARE – “DCOMP”
;
;   this routine will compare
;   two double precision numbers, but is the opposite of the ICOMP, FCOMP,
;   and XDCOMP routines. This one swaps ARC and ACC, so on Exit,
;   A=1 if ARG > ACCumulator, A=0 if ARG=Accmulator, and A=-1
;   if ARG < ACCumulator. Every register is affected.
; ----------------------------------------------------------------------
DCOMP:	call	XDCOMP		;0a78
	jp	nz,FCOMPS	;0a7b
	ret			;0a7e
;
; ======================================================================
; 0A7FH – LEVEL II BASIC CINT ROUTINE – “FRCINT” - MATH CONVERSION ROUTINE
;
;   CINT routine. Takes a value from ACC, converts it to an integer value
;   and puts it back into the ACC. On completion, the HL Register Pair
;   contains the LSB of the integer value, and the NTF contains 2
;   (Integer=2). If NTF=3 (string) a TM ERROR will be generated and control
;   will be passed to BASIC. Every register is affected. No rounding is performed
; ----------------------------------------------------------------------
FRCINT:	GETYPE			;0a7f - RST 20 - check the current number type
	ld	hl,(FACLO)	;0a80 - in case an int, Load HL with the integer
	ret	m		;0a83 - If an INTEGER, then return HL
	jp	z,TMERR		;0a84 - If a STRING, Display a ?TM ERROR
;
#IFDEF BUGFIX5
	NOP3
	DEFC 	BUGFIX5_ENABLED = 1
	PUBLIC 	BUGFIX5_ENABLED
#ELSE
; If double-precision (NC flag set based on type), call the subroutine at 0AB9H
; (a sign/compare or CSNG entry point), which converts double to single-precision
; with rounding to nearest (standard IEEE-like behavior in TRS-80 floating-point,
; adding 0.5 in mantissa before truncating lower bits. This rounding happens before
; truncation, causing values like 2.9999999# to become 3.0 in single-precision,
; and then INT(3.0) = 3. For single-precision or integer inputs, no call is made,
; and direct truncation occurs (correct behavior).
; CREDIT : Ira Goldklang
;
	call	nc,CONSD	;0a87 - If Double, Convert to single precision
#ENDIF
;
; ----------------------------------------------------------------------
; CONVERT ACCUM FROM SINGLE TO INTEGER (RESULT ALSO IN HL)
;     Before calling Push the Error return address as an error return point
; ----------------------------------------------------------------------
	ld	hl,OVERR	;0a8a - Just in case the number is too big,
	push	hl		;0a8d - RET to the ?OV ERROR, pushed onto stack.
;
; ----------------------------------------------------------------------
; 0A8EH – MATH CONVERSION ROUTINE – “CONIS”
;   This routine will convert a single precision number to an integer.
;   Every register is affected.
; ----------------------------------------------------------------------
CONIS:	ld	a,(FAC)		;0a8e - the exponent for the single precision value
	cp	$90		;0a91 - more than 16 bits of precision
	jr	nc,CONIS2	;0a93 - make sure that it isn't because it is -32768
	call	QINT		;0a95 - Actually convert it
	ex	de,hl		;0a98
CONIS1:	pop	de		;0a99
; ----------------------------------------------------------------------
; 0A9A - LEVEL II BASIC CONVERSION ROUTINE - "MAKINT" - MOVE
;        MOVE FROM (HL) TO ACCUM
;   This is the routine that returns the value in the HL Register Pair
;   to the BASIC program that called it. In effect it moves the content
;   of HL into the ACCumulator so it is ACCumulator = (HL)
;   with VALTYPE set accordingly
; ----------------------------------------------------------------------
MAKINT:	ld	(FACLO),hl	;0a9a - Save the INT into the ACCumulator
; ----------------------------------------------------------------------
; 0A9DH - Set NTF to INTEGER
; ----------------------------------------------------------------------
VALINT:	ld	a,VTINT		;0a9d - Value type INTeger
CONISD:	ld	(VALTYP),a	;0a9f - save to value type for ACC
	ret			;0aa2
; ----------------------------------------------------------------------
; 0AA3H – MATH CONVERSION ROUTINE – “CONIS2”
;   This routine’s purpose is to check to see if a number from the FIN routine is -32768.
; ----------------------------------------------------------------------
CONIS2:	ld	bc,$9080	;0aa3
	ld	de,$0000	;0aa6 - BC:DE single precision constant = -32768
	call	FCOMP		;0aa9 - compare with value in ACC
	ret	nz		;0aac - IF the number can NOT be converted into Int
	ld	h,c		;0aad
	ld	l,d		;0aae
	jr	CONIS1		;0aaf
;
; ======================================================================
; 0AB1H – LEVEL II BASIC CSNG ROUTINE – “FRCSNG”
;
;   Force the number in the ACCumulator to be a single-precision number.
;   Every register is affected.
; ----------------------------------------------------------------------
FRCSNG:	GETYPE			;0ab1 - RST 20 - check the current number type
	ret	po		;0ab2 - we already have SINGLE PRECISION number
	jp	m,CONSI		;0ab3 - If integer Convert It
	jp	z,TMERR		;0ab6 - If String then Error Out
;
; ----------------------------------------------------------------------
; 0AB9 – MATH CONVERSION ROUTINE – “CONSD”
;  Convert a double-precision number to single-precision.
;  Every register is affected.
; ----------------------------------------------------------------------
CONSD:	call	MOVRF		;0ab9 - Move the HIGH ORDER/MSB's into Register Pair BC:DE
	call	VALSNG		;0abc - set number type to single precision
	ld	a,b		;0abf - check for zero, first load the exponent
	or	a		;0ac0 - set flags
	ret	z		;0ac1 - exponent zero, number zero, return
	call	UNPACK		;0ac2 - turn on the MSB of the single in the ACCumulator
	ld	hl,FACLO-1	;0ac5 - chop off the MSB of double double precision
	ld	b,(hl)		;0ac8 - chopped number, the ROUND routine expects
	jp	ROUND		;0ac9 - round the chopped number up, store in ACC and RETurn
;
; ----------------------------------------------------------------------
; 0ACCH-0ADAH - MATH CONVERSION ROUTINE – “CONSI”
;   Convert Integer to Single Precision. Every register is affected.
; ----------------------------------------------------------------------
CONSI:	ld	hl,(FACLO)	;0acc
; ----------------------------------------------------------------------
;   Convert Integer (Passed in HL) to Single Precision
; ----------------------------------------------------------------------
CONSIH:	call	VALSNG		;0acf
	ld	a,h		;0ad2
	ld	d,l		;0ad3
	ld	e,$00		;0ad4
	ld	b,$90		;0ad6
	jp	FLOATR		;0ad8
;
; ======================================================================
; 0ADBH – LEVEL II BASIC CDBL ROUTINE – “FRCDBL”
;
;   CDBL routine. Takes a value from ACCumulator (regardless of integer
;   or single precision) and convert it to double-precision.
;   The result will be in ACC and NTF will be 8.
; ----------------------------------------------------------------------
FRCDBL:	GETYPE			;0adb - RST 20 - check the current number type
	ret	nc		;0adc
	jp	z,TMERR		;0add
	call	m,CONSI		;0ae0
;
; ----------------------------------------------------------------------
; 0AE3H – LEVEL II BASIC CDBL ROUTINE – “CONDS” -  MATH CONVERSION ROUTINE
;   Convert a single precision number to double. Modifies A, H, and L.
; ----------------------------------------------------------------------
CONDS:	ld	hl,$0000	;0ae3
	ld	(DFACLO),hl	;0ae6
	ld	(DFACLO+2),hl	;0ae9
; ----------------------------------------------------------------------
; 0AECH - Set NTF to DOUBLE
; ----------------------------------------------------------------------
VALDBL:	ld	a,VTDBL		;0aec - Double Value Type
;
; ----------------------------------------------------------------------
; 0AEEH-0AF3H – MATH ROUTINE – “VALSNG”
; ----------------------------------------------------------------------
;
	DEFB	LDBCNN		;0aee - Z80 Trick LD BC,nnnn - skip next 2 byte instruction
;
; ----------------------------------------------------------------------
; 0AEFH - Set NTF to SINGLE
; ----------------------------------------------------------------------
VALSNG:	ld	a,VTSNG		;0aef - single precision number type flag (of 4)
	jp	CONISD		;0af1
;
; ----------------------------------------------------------------------
; 0AF4H-0AFAH – LEVEL II BASIC STRING CONVERSION ROUTINE – “CHKSTR”
;   This routine calls 20H (RST 20H) and returns if NTF=3 (string) else if NTF is not 3
;   then it generates a TM ERROR. BC, DE, and HL are saved
; ----------------------------------------------------------------------
CHKSTR:	GETYPE			;0af4 - RST 20 - check the current number type
	ret	z		;0af5
;
; ----------------------------------------------------------------------
; 0AF6H – ?TM ERROR ENTRY POINT – “TMERR”
; ----------------------------------------------------------------------
TMERR:	ld	e,ERRTM		;0af6
	jp	ERROR		;0af8
;
; ----------------------------------------------------------------------
; 0AFBH-0B1EH – MATH ROUTINE – “QINT”
;   If (and only if) the A register contains zero, copy the value in A to
;   the B,C,D,and E registers and return with Z flag set .
;      - OR - If NOT ZERO
;   This routine is a quick “Greatest Integer” function.
;   The result of INT(ACCumulator) is left in BC DE as a signed number
; ----------------------------------------------------------------------
QINT:	ld	b,a		;0afb
	ld	c,a		;0afc
	ld	d,a		;0afd
	ld	e,a		;0afe
	or	a		;0aff
	ret	z		;0b00
	push	hl		;0b01
	call	MOVRF		;0b02 - Get SINGLE in ACC into BC:DE
	call	UNPACK		;0b05 -
	xor	(hl)		;0b08
	ld	h,a		;0b09
	call	m,QINTA		;0b0a - If negative, -1 from low order/LSB
	ld	a,$98		;0b0d - maximum exponent
	sub	b		;0b0f - subtract the exponent
	call	SHIFTR		;0b10
	ld	a,h		;0b13
	rla			;0b14
	call	c,ROUNDA	;0b15
	ld	b,0		;0b18
	call	c,NGER		;0b1a
	pop	hl		;0b1d
	ret			;0b1e
QINTA:	dec	de		;0b1f
	ld	a,d		;0b20
	and	e		;0b21
	inc	a		;0b22
	ret	nz		;0b23
DCXBRT:	dec	bc		;0b24
	ret			;0b25
;
; ======================================================================
; 0B26H – LEVEL II BASIC FIX ROUTINE – “FNFIX”
;
;   Unconditionally truncates the fractional part of a floating
;   point number in WRA1. The result is stored in WRA1 and
;   the type flag is set to integer.
; ----------------------------------------------------------------------
FNFIX:	GETYPE			;0b26 - RST 20 - check the current number type
	ret	m		;0b27
	call	SIGN		;0b28
	jp	p,FNINT		;0b2b
	call	NNEG		;0b2e
	call	FNINT		;0b31
	jp	VNEG		;0b34
;
; ======================================================================
; 0B37H – LEVEL II BASIC INT( ROUTINE – “FNINT”
;
;   Return Integer: Returns the integer portion of a floating point number.
;   Every flag is affected. If the value is positive, the integer portion
;   is returned. If the value is negative with a fractional part,
;   it is rounded up before truncation. The integer portion is left in A
; ----------------------------------------------------------------------
FNINT:	GETYPE			;0b37 - RST 20 - check the current number type
	ret	m		;0b38
	jr	nc,DINT		;0b39
	jr	z,TMERR		;0b3b
	call	CONIS		;0b3d
IINT:	ld	hl,FAC		;0b40
	ld	a,(hl)		;0b43
	cp	$98		;0b44
	ld	a,(FACLO)	;0b46
	ret	nc		;0b49
	ld	a,(hl)		;0b4a
	call	QINT		;0b4b
	ld	(hl),$98	;0b4e
	ld	a,e		;0b50
	push	af		;0b51
	ld	a,c		;0b52
	rla			;0b53
	call	FADFLT		;0b54
	pop	af		;0b57
	ret			;0b58
;
; ----------------------------------------------------------------------
; 0B59H-0B9DH – MATH ROUTINE – “DINT”
;   Integer function for double-precision numbers.
;   All registers are affected.
; ----------------------------------------------------------------------
DINT:	ld	hl,FAC		;0b59
	ld	a,(hl)		;0b5c
	cp	$90		;0b5d
	jp	c,FRCINT	;0b5f
	jr	nz,DINT2	;0b62
	ld	c,a		;0b64
	dec	hl		;0b65
	ld	a,(hl)		;0b66
	xor	$80		;0b67
	ld	b,$06		;0b69
DINT1:	dec	hl		;0b6b
	or	(hl)		;0b6c
	dec	b		;0b6d
	jr	nz,DINT1	;0b6e
	or	a		;0b70
	ld	hl,$8000	;0b71
	jp	z,MAKINT	;0b74 - Move INT in HL into the ACCumulator
	ld	a,c		;0b77
DINT2:	cp	$B8		;0b78
	ret	nc		;0b7a
DINTFO:	push	af		;0b7b
	call	MOVRF		;0b7c
	call	UNPACK		;0b7f
	xor	(hl)		;0b82
	dec	hl		;0b83
	ld	(hl),$B8	;0b84
	push	af		;0b86
	call	m,DINTA		;0b87
	ld	hl,FAC-1	;0b8a
	ld	a,$B8		;0b8d
	sub	b		;0b8f
	call	DSHFTR		;0b90
	pop	af		;0b93
	call	m,DROUNA	;0b94
	xor	a		;0b97
	ld	(DFACLO-1),a	;0b98
	pop	af		;0b9b
	ret	nc		;0b9c
	jp	DNORML		;0b9d
;
; ----------------------------------------------------------------------
; 0BA0H-0BA9H – MATH ROUTINE – “DINTA”
; ----------------------------------------------------------------------
DINTA:	ld	hl,DFACLO	;0ba0
DINTA1:	ld	a,(hl)		;0ba3
	dec	(hl)		;0ba4
	or	a		;0ba5
	inc	hl		;0ba6
	jr	z,DINTA1	;0ba7
	ret			;0ba9
; ----------------------------------------------------------------------
; 0BAAH-0BC6H – MATH ROUTINE – “UMULT”
;   This is the integer multiply routine for multiplying dimensioned
;   array. It will calculate DE = BC * DE. If there is an overflow,
;   a ?BS ERROR will get thrown. Every register except HL is affected.
; ----------------------------------------------------------------------
UMULT:	push	hl		;0baa
	ld	hl,$0000	;0bab
	ld	a,b		;0bae
	or	c		;0baf
	jr	z,MULRET	;0bb0
	ld	a,$10		;0bb2
UMULT1:	add	hl,hl		;0bb4
	jp	c,BSERR		;0bb5
	ex	de,hl		;0bb8
	add	hl,hl		;0bb9
	ex	de,hl		;0bba
	jr	nc,UMULT2	;0bbb
	add	hl,bc		;0bbd
	jp	c,BSERR		;0bbe
UMULT2:	dec	a		;0bc1
	jr	nz,UMULT1	;0bc2
MULRET:	ex	de,hl		;0bc4
	pop	hl		;0bc5
	ret			;0bc6
;
; ======================================================================
; INTEGER CONVENTIONS
; ======================================================================
;
; * Integer variables are 2 byte signed numbers, with the LSB coming first
; * For one argument functions, the argument is in (HL) and the results are put into (HL)
; * For two argument operations, the first argument is in (DE), the second in (HL),
;   and the restuls are left in the ACCumulator and, if there was no overflow, (HL).
;   If there was an overflow, then the arguments are converted to single precision.
; * When integers are stored in the ACCumulator, they are stored at FACLO+0 and FACLO+1, with VALTYPE=2
;
; ======================================================================
; 0BC7H – LEVEL II BASIC INTEGER SUBTRACTION – “ISUB”
;
;   Integer subtract. (ACCumulator=DE-HL) The result is returned in both
;   ACCumulator and, if there was no overflow, the HL Register Pair.
; ----------------------------------------------------------------------
ISUB:	ld	a,h		;0bc7
	rla			;0bc8
	sbc	a,a		;0bc9
	ld	b,a		;0bca
	call	INEGHL		;0bcb
	ld	a,c		;0bce
	sbc	a,b		;0bcf
	jr	IADDS		;0bd0
;
; ======================================================================
; 0BD2H – LEVEL II BASIC INTEGER ADDITION – “IADD”
;
;   Integer addition (ACCumulator=DE+HL), where ACCumulator = 4121H-4122H.
;   After execution NTF=2, or 4 if overflow has occurred, in which case
;   the result in the ACCumulator will be single-precision.
;   The result is returned in both ACCumulator and the HL Register Pair.
; ----------------------------------------------------------------------
IADD:	ld	a,h		;0bd2
	rla			;0bd3
	sbc	a,a		;0bd4
IADDS:	ld	b,a		;0bd5
	push	hl		;0bd6
	ld	a,d		;0bd7
	rla			;0bd8
	sbc	a,a		;0bd9
	add	hl,de		;0bda
	adc	a,b		;0bdb
	rrca			;0bdc
	xor	h		;0bdd
	jp	p,CONIS1	;0bde
	push	bc		;0be1
	ex	de,hl		;0be2
	call	CONSIH		;0be3
	pop	af		;0be6
	pop	hl		;0be7
	call	PUSHF		;0be8
	ex	de,hl		;0beb
	call	INEGAD		;0bec
	jp	FADDT		;0bef
;
; ======================================================================
; 0BF2H – LEVEL II BASIC INTEGER MULTIPLICATION – “IMULT”
;
;   Integer multiply. (ACCumulator (and HL) =DE*HL). Multiplies HL by DE.
;   The product is left in HL and DE is preserved. If overflow occurs,
;   both values are converted to single precision and the operation is
;   restarted. The product would be left in the ACCumulator.
; ----------------------------------------------------------------------
IMULT:	ld	a,h		;0bf2
	or	l		;0bf3
	jp	z,MAKINT	;0bf4 - Move INT in HL into the ACCumulator
	push	hl		;0bf7
	push	de		;0bf8
	call	IMULDV		;0bf9
	push	bc		;0bfc
	ld	b,h		;0bfd
	ld	c,l		;0bfe
	ld	hl,$0000	;0bff
	ld	a,$10		;0c02
IMULT1:	add	hl,hl		;0c04
	jr	c,IMULT5	;0c05
	ex	de,hl		;0c07
	add	hl,hl		;0c08
	ex	de,hl		;0c09
	jr	nc,IMULT2	;0c0a
	add	hl,bc		;0c0c
	jp	c,IMULT5	;0c0d
IMULT2:	dec	a		;0c10
	jr	nz,IMULT1	;0c11
	pop	bc		;0c13
	pop	de		;0c14
	ld	a,h		;0c15
	or	a		;0c16
	jp	m,IMULT3	;0c17
	pop	de		;0c1a
	ld	a,b		;0c1b
	jp	INEGA		;0c1c
; ----------------------------------------------------------------------
; 0C1FH-0C34H – MATH ROUTINE – “IMULT3”
; ----------------------------------------------------------------------
IMULT3:	xor	$80		;0c1f
	or	l		;0c21
	jr	z,IMULT4	;0c22
	ex	de,hl		;0c24
;
	DEFB	LDBCNN		;0c25 - Z80 trick - LD BC,nnnn skip next 2 bytes
IMULT5:	pop	bc		;0c26
	pop	hl		;0c27
;
	call	CONSIH		;0c28
	pop	hl		;0c2b
	call	PUSHF		;0c2c
	call	CONSIH		;0c2f
FMULTT:	pop	bc		;0c32
	pop	de		;0c33
	jp	FMULT		;0c34
; ----------------------------------------------------------------------
; 0C37H-0C44H – MATH ROUTINE – “IMULT4”
; ----------------------------------------------------------------------
IMULT4:	ld	a,b		;0c37
	or	a		;0c38
	pop	bc		;0c39
	jp	m,MAKINT	;0c3a - Move INT in HL into the ACCumulator
	push	de		;0c3d
	call	CONSIH		;0c3e
	pop	de		;0c41
	jp	NNEG		;0c42
; ----------------------------------------------------------------------
; 0C45H-0C5AH – MATH ROUTINE – “IMULDV”
;   This is the integer division routine HL = DE / HL. The remainder will be
;   in DE and the quotient will be left in HL. Every register is affected.
; ----------------------------------------------------------------------
IMULDV:	ld	a,h		;0c45
	xor	d		;0c46
	ld	b,a		;0c47
	call	INEGH		;0c48
	ex	de,hl		;0c4b
INEGH:	ld	a,h		;0c4c
INEGA:	or	a		;0c4d
	jp	p,MAKINT	;0c4e - Move INT in HL into the ACCumulator
; ----------------------------------------------------------------------
; Negate HL routine. This routine changes the sign of the HL Register Pair
; and stores it in the ACC. (HL=ACCumulator=-HL) The result is returned
; in both the HL Register Pair and the ACC.
; ----------------------------------------------------------------------
INEGHL:	xor	a		;0c51
	ld	c,a		;0c52
	sub	l		;0c53
	ld	l,a		;0c54
	ld	a,c		;0c55
	sbc	a,h		;0c56
	ld	h,a		;0c57
	jp	MAKINT		;0c58 - Move INT in HL into the ACCumulator
; ----------------------------------------------------------------------
; 0C5BH-0C6FH – MATH ROUTINE – “INEG”
;   Integer Negation Routine. All registers are altered.
; ----------------------------------------------------------------------
INEG:	ld	hl,(FACLO)	;0c5b
	call	INEGHL		;0c5e
	ld	a,h		;0c61
	xor	$80		;0c62
	or	l		;0c64
	ret	nz		;0c65
INEG2:	ex	de,hl		;0c66
	call	VALSNG		;0c67
	xor	a		;0c6a
INEGAD:	ld	b,$98		;0c6b
	jp	FLOATR		;0c6d

; ======================================================================
; 0C70H – LEVEL II BASIC DOUBLE PRECISION SUBTRACTION – “DSUB”

;   Double-precision subtraction (ACCumulator = ACCumulator – ARG).
;   Subtracts the double precision value in ARG (a/k/a REG 2)
;   from the value in the ACCumulator. The dif is left in ACC.
; ----------------------------------------------------------------------
DSUB:	ld	hl,ARG-1	;0c70
	ld	a,(hl)		;0c73
	xor	$80		;0c74
	ld	(hl),a		;0c76
;
; ======================================================================
; 0C77H - LEVEL II BASIC DOUBLE PRECISION ADDITION – “DADD”
;
;   Double-precision addition (ACCumulator=ACCumulator+ARG (a/k/a REG 2)).
;   Adds the double precision value in ARG (a/k/a REG 2) to the value
;   in the ACCumulator. Sum is left in the ACCumulator.
;   All registers are affected.
; ----------------------------------------------------------------------
DADD:	ld	hl,ARG		;0c77
	ld	a,(hl)		;0c7a
	or	a		;0c7b
	ret	z		;0c7c
	ld	b,a		;0c7d
	dec	hl		;0c7e
	ld	c,(hl)		;0c7f
	ld	de,FAC		;0c80
	ld	a,(de)		;0c83
	or	a		;0c84
	jp	z,VMOVFA	;0c85
	sub	b		;0c88
	jr	nc,DADD2	;0c89
	cpl			;0c8b
	inc	a		;0c8c
	push	af		;0c8d
	ld	c,$08		;0c8e
	inc	hl		;0c90
	push	hl		;0c91
DADD1:	ld	a,(de)		;0c92
	ld	b,(hl)		;0c93
	ld	(hl),a		;0c94
	ld	a,b		;0c95
	ld	(de),a		;0c96
	dec	de		;0c97
	dec	hl		;0c98
	dec	c		;0c99
	jr	nz,DADD1	;0c9a
	pop	hl		;0c9c
	ld	b,(hl)		;0c9d
	dec	hl		;0c9e
	ld	c,(hl)		;0c9f
	pop	af		;0ca0
DADD2:	cp	$39		;0ca1
	ret	nc		;0ca3
	push	af		;0ca4
	call	UNPACK		;0ca5
	inc	hl		;0ca8
	ld	(hl),$00	;0ca9
	ld	b,a		;0cab
	pop	af		;0cac
	ld	hl,ARG-1	;0cad
	call	DSHFTR		;0cb0
	ld	a,(FACFLG)	;0cb3
	ld	(DFACLO-1),a	;0cb6
	ld	a,b		;0cb9
	or	a		;0cba
	jp	p,DADD3		;0cbb
	call	DADDAA		;0cbe
	jp	nc,DROUND	;0cc1
	ex	de,hl		;0cc4
	inc	(hl)		;0cc5
	jp	z,OVERR		;0cc6
	call	DSHFRB		;0cc9
	jp	DROUND		;0ccc
; ----------------------------------------------------------------------
; 0CCFH-0D1FH – DOUBLE PRECISION MATH ROUTINE – “DADD3”
; ----------------------------------------------------------------------
DADD3:	call	DADDAS		;0ccf
	ld	hl,FACSGN	;0cd2
	call	c,DNEGR		;0cd5
; ----------------------------------------------------------------------
; 0CD8H – DOUBLE PRECISION MATH ROUTINE – “DNORML” and “DNORM1”
; ----------------------------------------------------------------------
DNORML:	xor	a		;0cd8
DNORM1:	ld	b,a		;0cd9
	ld	a,(FAC-1)	;0cda
	or	a		;0cdd
	jr	nz,DNORM5	;0cde
	ld	hl,DFACLO-1	;0ce0
	ld	c,$08		;0ce3
DNORM2:	ld	d,(hl)		;0ce5
	ld	(hl),a		;0ce6
	ld	a,d		;0ce7
	inc	hl		;0ce8
	dec	c		;0ce9
	jr	nz,DNORM2	;0cea
	ld	a,b		;0cec
	sub	$08		;0ced
	cp	$C0		;0cef
	jr	nz,DNORM1	;0cf1
	jp	ZERO		;0cf3
; ----------------------------------------------------------------------
; 0CF6H – Part of the “DNORML” and “DNORM1” Routine
; ----------------------------------------------------------------------
DNORM3:	dec	b		;0cf6
	ld	hl,DFACLO-1	;0cf7
	call	DSHFLC		;0cfa
	or	a		;0cfd
DNORM5:	jp	p,DNORM3	;0cfe
	ld	a,b		;0d01
	or	a		;0d02
	jr	z,DROUND	;0d03
	ld	hl,FAC		;0d05
	add	a,(hl)		;0d08
	ld	(hl),a		;0d09
	jp	nc,ZERO		;0d0a
	ret	z		;0d0d
; ----------------------------------------------------------------------
; 0D0EH – DOUBLE PRECISION MATH ROUTINE – “DROUND” and “DROUNB”
; ----------------------------------------------------------------------
DROUND:	ld	a,(DFACLO-1)	;0d0e
DROUNB:	or	a		;0d11
	call	m,DROUNA	;0d12
	ld	hl,FACSGN	;0d15
	ld	a,(hl)		;0d18
	and	$80		;0d19
	dec	hl		;0d1b
	dec	hl		;0d1c
	xor	(hl)		;0d1d
	ld	(hl),a		;0d1e
	ret			;0d1f
; ----------------------------------------------------------------------
; 0D20H-0D32H – DOUBLE PRECISION MATH support routine – “DROUNA”
; ----------------------------------------------------------------------
DROUNA:	ld	hl,DFACLO	;0d20
	ld	b,$07		;0d23
DRON1:	inc	(hl)		;0d25
	ret	nz		;0d26
	inc	hl		;0d27
	dec	b		;0d28
	jr	nz,DRON1	;0d29
	inc	(hl)		;0d2b
	jp	z,OVERR		;0d2c
	dec	hl		;0d2f
	ld	(hl),$80	;0d30
	ret			;0d32
; ----------------------------------------------------------------------
; 0D33H-0D44H – DOUBLE PRECISION MATH ROUTINE – “DADDAA” and “DADDA”
; ----------------------------------------------------------------------
DADDAA:	ld	hl,ARGLO	;0d33
DADDFO:	ld	de,DFACLO	;0d36
DADDS:	ld	c,$07		;0d39
	xor	a		;0d3b
DADALS:	ld	a,(de)		;0d3c
	adc	a,(hl)		;0d3d
	ld	(de),a		;0d3e
	inc	de		;0d3f
	inc	hl		;0d40
	dec	c		;0d41
	jr	nz,DADALS	;0d42
	ret			;0d44
; ----------------------------------------------------------------------
; 0D45H-0D56H – DOUBLE PRECISION MATH ROUTINE – “DADDAS”
;   This routine subtracts numbers in the pure version. This needs to
;   be done in two subroutines since the ROM cannot be modified.
; ----------------------------------------------------------------------
DADDAS:	ld	hl,ARGLO	;0d45
DADDFS:	ld	de,DFACLO	;0d48
DADDSS:	ld	c,$07		;0d4b
	xor	a		;0d4d
DADSLS:	ld	a,(de)		;0d4e
	sbc	a,(hl)		;0d4f
	ld	(de),a		;0d50
	inc	de		;0d51
	inc	hl		;0d52
	dec	c		;0d53
	jr	nz,DADSLS	;0d54
	ret			;0d56
; ----------------------------------------------------------------------
; 0D57H-0D68H – DOUBLE PRECISION MATH ROUTINE – “DNEGR”
;   This routine will negate the signed number held in the ACCumulator.
;   Registers A, B, C, H, and L are affected.
;   This routine is called by DADD and DINT.
; ----------------------------------------------------------------------
DNEGR:	ld	a,(hl)		;0d57
	cpl			;0d58
	ld	(hl),a		;0d59
	ld	hl,DFACLO-1	;0d5a
	ld	b,$08		;0d5d
	xor	a		;0d5f
	ld	c,a		;0d60
DNEGR1:	ld	a,c		;0d61
	sbc	a,(hl)		;0d62
	ld	(hl),a		;0d63
	inc	hl		;0d64
	dec	b		;0d65
	jr	nz,DNEGR1	;0d66
	ret			;0d68
; ----------------------------------------------------------------------
; 0D69H-0D8FH – DOUBLE PRECISION MATH ROUTINE – “DSHFTR”
;   This routine wwill shift the double precision value held in the
;   ACCumulator to the right once.
; ----------------------------------------------------------------------
DSHFTR:	ld	(hl),c		;0d69
	push	hl		;0d6a
DSHFR1:	sub	$08		;0d6b
	jr	c,DSHFR3	;0d6d
	pop	hl		;0d6f
DSHFRM:	push	hl		;0d70
	ld	de,$0800	;0d71 - shifts a zero into the HIGH ORDER byte and sets up a counter
DSHFR2:	ld	c,(hl)		;0d74
	ld	(hl),e		;0d75
	ld	e,c		;0d76
	dec	hl		;0d77
	dec	d		;0d78
	jr	nz,DSHFR2	;0d79
	jr	DSHFR1		;0d7b
; ----------------------------------------------------------------------
; 0D69H-0D8FH – DOUBLE PRECISION MATH ROUTINE – “DSHFR3”
; ----------------------------------------------------------------------
DSHFR3:	add	a,$09		;0d7d
	ld	d,a		;0d7f
DSHFR4:	xor	a		;0d80
	pop	hl		;0d81
	dec	d		;0d82
	ret	z		;0d83
DSHFRA:	push	hl		;0d84
	ld	e,$08		;0d85
DSHFR5:	ld	a,(hl)		;0d87
	rra			;0d88
	ld	(hl),a		;0d89
	dec	hl		;0d8a
	dec	e		;0d8b
	jr	nz,DSHFR5	;0d8c
	jr	DSHFR4		;0d8e
; ----------------------------------------------------------------------
; 0D90H-0D96H – DOUBLE PRECISION MATH ROUTINE – “DSHFRB”
;   This is the entry from DADD and DMULT.
; ----------------------------------------------------------------------
DSHFRB:	ld	hl,FAC-1	;0d90
	ld	d,$01		;0d93
	jr	DSHFRA		;0d95
; ----------------------------------------------------------------------
; 0D97H-0DA0H – DOUBLE PRECISION MATH ROUTINE – “DSHFLC”
;   This routine will rotate the ACCumulator left one.
;   Register A, C, H, and L are affected.
; ----------------------------------------------------------------------
DSHFLC:	ld	c,$08		;0d97
DSHFTL:	ld	a,(hl)		;0d99
	rla			;0d9a
	ld	(hl),a		;0d9b
	inc	hl		;0d9c
	dec	c		;0d9d
	jr	nz,DSHFTL	;0d9e
	ret			;0da0
;
; ======================================================================
; 0DA1H – LEVEL II BASIC DOUBLE PRECISION MULTIPLICATION – “DMULT”
;
;   Double-precision multiplication (ACCumulator=ACC*ARG (a/k/a REG 2)).
;   Multiplies the double precision value in the ACCumulator by the value
;   in ARG (a/k/a REG 2). The product is left in the ACCumulator.
; ----------------------------------------------------------------------
DMULT:	call	SIGN		;0da1
	ret	z		;0da4
	call	MULDVA		;0da5
	call	DMULDV		;0da8
	ld	(hl),c		;0dab
	inc	de		;0dac
	ld	b,$07		;0dad
DMULT2:	ld	a,(de)		;0daf
	inc	de		;0db0
	or	a		;0db1
	push	de		;0db2
	jr	z,DMULT5	;0db3
	ld	c,$08		;0db5
DMULT3:	push	bc		;0db7
	rra			;0db8
	ld	b,a		;0db9
	call	c,DADDAA	;0dba
	call	DSHFRB		;0dbd
	ld	a,b		;0dc0
	pop	bc		;0dc1
	dec	c		;0dc2
	jr	nz,DMULT3	;0dc3
DMULT4:	pop	de		;0dc5
	dec	b		;0dc6
	jr	nz,DMULT2	;0dc7
	jp	DNORML		;0dc9
; ----------------------------------------------------------------------
; 0DCCH – DOUBLE PRECISION MULTIPLICATION Support Routine – “DMULT5”
; ----------------------------------------------------------------------
DMULT5:	ld	hl,FAC-1	;0dcc
	call	DSHFRM		;0dcf
	jr	DMULT4		;0dd2
;
; ----------------------------------------------------------------------
; 0DD4H-0DDBH – DOUBLE PRECISION CONSTANT STORAGE AREA – “DTEN” and “FTEN”
; ----------------------------------------------------------------------
;
DTEN:	DEFB	$00, $00, $00, $00; A double precision constant 10.0 (8 bytes)
FTEN:	DEFB	$00, $00, $20, $84; A single precision constant 10.0
;
; ----------------------------------------------------------------------
; 0DDCH-0DE4H – DOUBLE PRECISION MATH ROUTINE – “DDIV10”
;   Double precision divide routine. Divides the ACCumulator by 10.
;   All registers are affected.
; ----------------------------------------------------------------------
DDIV10:	ld	de,DTEN		;0ddc
	ld	hl,ARGLO	;0ddf
	call	VMOVE		;0de2
;
; ======================================================================
; 0DE5H – LEVEL II BASIC DOUBLE PRECISION DIVISION – “DDIV”
;
;   Divides the double precision value in the ACCumulator by the value in
;   ARG (a/k/a REG 2). The quotient is left in the ACCumulator.
;   All registers are affected
; ----------------------------------------------------------------------
DDIV:	ld	a,(ARG)		;0de5
	or	a		;0de8
	jp	z,DV0ERR	;0de9
	call	MULDVS		;0dec
	inc	(hl)		;0def
	inc	(hl)		;0df0
	call	DMULDV		;0df1
	ld	hl,FBUFFR+33	;0df4 - address of the extra HIGH ORDER byte we will use in ARG
	ld	(hl),c		;0df7 - zero that byte
	ld	b,c		;0df8
DDIV1:	ld	de,FMLTT0	;0df9
	ld	hl,ARGLO	;0dfc
	call	DADDSS		;0dff
	ld	a,(de)		;0e02
	sbc	a,c		;0e03
	ccf			;0e04
	jr	c,DDIV2		;0e05
	ld	de,FMLTT0	;0e07
	ld	hl,ARGLO	;0e0a
	call	DADDS		;0e0d
;
	xor	a		;0e10 - Clear the CF for the Z80 Trick
	DEFB	JPCNN		;0e11 - JP C,nnnn, since C flag cleared skips next 2 bytes
;
DDIV2:	ld	(de),a		;0e12
	inc	b		;0e13
	ld	a,(FAC-1)	;0e14
	inc	a		;0e17
	dec	a		;0e18
	rra			;0e19
	jp	m,DROUNB	;0e1a
	rla			;0e1d
	ld	hl,DFACLO	;0e1e
	ld	c,$07		;0e21
	call	DSHFTL		;0e23
	ld	hl,FMLTT0	;0e26
	call	DSHFLC		;0e29
	ld	a,b		;0e2c
	or	a		;0e2d
	jr	nz,DDIV1	;0e2e
	ld	hl,FAC		;0e30
	dec	(hl)		;0e33
	jr	nz,DDIV1	;0e34
	jp	OVERR		;0e36
; ----------------------------------------------------------------------
; 0E39H-0E4CH – DOUBLE PRECISION MATH ROUTINE – “DMULDV”
;   This routine will transfer the double precision number held in the ACCumulator
;   to FBUFFR for the DMULT and DDIV routines. All registers are affected.
; ----------------------------------------------------------------------
DMULDV:	ld	a,c		;0e39
	ld	(ARG-1),a	;0e3a
	dec	hl		;0e3d
	ld	de,FMLTT2	;0e3e
	ld	bc,$0700	;0e41 - B number of bytes to be moved, and C=0
DMLDV1:	ld	a,(hl)		;0e44
	ld	(de),a		;0e45
	ld	(hl),c		;0e46
	dec	de		;0e47
	dec	hl		;0e48
	dec	b		;0e49
	jr	nz,DMLDV1	;0e4a
	ret			;0e4c
; ----------------------------------------------------------------------
; 0E4DH-0E64H – MATH ROUTINE – “DMUL10”
;   This routine multiplies the current double-precision value by 10 by
;   adding it to itself. First the current value is moved to a saved
;   location, and then DP add routine adds the current value to that
;   saved value. All registers are affected
; ----------------------------------------------------------------------
DMUL10:	call	VMOVAF		;0e4d
	ex	de,hl		;0e50
	dec	hl		;0e51
	ld	a,(hl)		;0e52
	or	a		;0e53
	ret	z		;0e54
	add	a,$02		;0e55
	jp	c,OVERR		;0e57
	ld	(hl),a		;0e5a
	push	hl		;0e5b
	call	DADD		;0e5c
	pop	hl		;0e5f
	inc	(hl)		;0e60
	ret	nz		;0e61
	jp	OVERR		;0e62
;
; ======================================================================
; 0E65H-0F88H – ASCII to Double Precision Converter – “FINDBL”
;
;   This routine converts an ASCII string (pointed to by HL) to a
;   double-precision value and stores it in the ACCumulator.
;   The NTF is fixed accordingly. The string must be terminated with a , or zero.
; ----------------------------------------------------------------------
FINDBL:	call	ZERO		;0e65
	call	VALDBL		;0e68
;
	DEFB	ORNN		;0e6b - Z80 Trick - OR nn - next instruction skippd NZ flag SET
;
; ======================================================================
; 0E6CH - ASCII To Binary - "FIN"
;
;   Converts the ASCII string pointed to by HL to binary. If
;   the value is less than 2**16 and does not contain a decimal
;   point or an E or D descriptor (exponent), the string will be
;   converted to its integer equivalent. If the string contains a
;   decimal point or an E, or D descriptor or if it exceeds 2**16
;   it will be converted to single or double precision. The
;   binary value will be left in WRA1 and the mode flag will be
;   to the proper value.
; ----------------------------------------------------------------------
FIN:	xor	a		;0e6c - Z FLAG SET
	ex	de,hl		;0e6d - DE -> pointer to basic program
	ld	bc,$00FF	;0e6e - init; B decimal point location; C will be a flag.
	ld	h,b		;0e71
	ld	l,b		;0e72 - zero HL
	call	z,MAKINT	;0e73 - Move INT 0 into the ACCumulator
	ex	de,hl		;0e76 - HL -> pointer to basic program
	ld	a,(hl)		;0e77 - get next char
	cp	'-'		;0e78 - check negative sign
	push	af		;0e7a - save the negative sign
	jp	z,FINC		;0e7b - skip pas next check
	cp	'+'		;0e7e - check for +
	jr	z,FINC		;0e80 - skip past bext
	dec	hl		;0e82 - revert the program pointe if not + or -
; ----------------------------------------------------------------------
; Top of the loop starts here
; ----------------------------------------------------------------------
FINC:	GETCHR			;0e83 - rst 10h
	jp	c,FINDIG	;0e84 - was it a digit
	cp	'.'		;0e87
	jp	z,FINDP		;0e89 - was it a decimal point
	cp	'E'		;0e8c
	jr	z,FINEX		;0e8e
	cp	'%'		;0e90
	jp	z,FININT	;0e92
	cp	'#'		;0e95
	jp	z,FINDBF	;0e97
	cp	'!'		;0e9a
	jp	z,FINSNF	;0e9c
	cp	'D'		;0e9f
	jr	nz,FINE		;0ea1
	or	a		;0ea3 - flags for next operation
FINEX:	call	FINFRC		;0ea4 - Convert the ACC to single or double
	push	hl		;0ea7
	ld	hl,FINEC	;0ea8 - return address
	ex	(sp),hl		;0eab
	GETCHR			;0eac - rst 10h
	dec	d		;0ead
	cp	TKMNUS		;0eae - '-' token
	ret	z		;0eb0
	cp	'-'		;0eb1
	ret	z		;0eb3
	inc	d		;0eb4
	cp	TKPLUS		;0eb5 - '-' Token
	ret	z		;0eb7
	cp	'+'		;0eb8
	ret	z		;0eba
	dec	hl		;0ebb
	pop	af		;0ebc
FINEC:	GETCHR			;0ebd - rst 10h
	jp	c,FINEDG	;0ebe
	inc	d		;0ec1
	jr	nz,FINE		;0ec2
	xor	a		;0ec4
	sub	e		;0ec5
	ld	e,a		;0ec6
FINE:	push	hl		;0ec7
	ld	a,e		;0ec8 - value of the exponent
	sub	b		;0ec9 - work out how many time x10 reqd
; ----------------------------------------------------------------------
; multiply or divide by 10 the correct number of times. If A=0 the number is an integer.
; ----------------------------------------------------------------------
FINE2:	call	p,FINMUL	;0eca - multiply by 10
	call	m,FINDIV	;0ecd - divide by 10
	jr	nz,FINE2	;0ed0 - loop back if necessary
	pop	hl		;0ed2 - restore program input buffer
	pop	af		;0ed3 - sign value
	push	hl		;0ed4 - save program pointer
	call	z,VNEG		;0ed5 - convert number to negative
	pop	hl		;0ed8 - restore program input buffer
	GETYPE			;0ed9 - RST 20 - check the current number type
	ret	pe		;0eda - Return if Not a Single precision
	push	hl		;0edb - save program pointer
	ld	hl,POPHRT	;0edc - Routine to Pop HL and Return
	push	hl		;0edf - save as return address
	call	CONIS2		;0ee0
	ret			;0ee3 - THE MAIN RETURN OF FIN
; ----------------------------------------------------------------------
; ----------------------------------------------------------------------
; This routine checks to see if we have seen TWO decimal points and to set
; the decimal point flag. We jumped here when we found a single decimal point.
; ----------------------------------------------------------------------
FINDP:	GETYPE			;0ee4 - RST 20 - check the current number type
	inc	c		;0ee5 - adjust Flag
	jr	nz,FINE		;0ee6 - if found a SECOND DP
	call	c,FINFRC	;0ee8 - convert to Single precision
	jp	FINC		;0eeb - and back to main loop
; ----------------------------------------------------------------------
FININT:	GETYPE			;0eee - RST 20 - check the current number type
	jp	p,SNERR		;0eef
;
#IFDEF BUGFIX7
;
INFINE:	JP	INFINEFIX	; Fixes Bug - Replaces Code Below
;
#ELSE
;
INFINE:	inc	hl		;0ef2
	jr	FINE		;0ef3
;
#ENDIF
;
FINDBF:	or	a		;0ef5
FINSNF:	call	FINFRC		;0ef6
	jr	INFINE		;0ef9
; ----------------------------------------------------------------------
;   This routine will force the ACCumulator to be either single precision
;   or double precision based on the Z FLAG. Z FLAG = Force to single precision;
;   NZ FLAG = Force to double precision.
; ----------------------------------------------------------------------
FINFRC:	push	hl		;0efb
	push	de		;0efc
	push	bc		;0efd
	push	af		;0efe
	call	z,FRCSNG	;0eff
	pop	af		;0f02
	call	nz,FRCDBL	;0f03
	pop	bc		;0f06
	pop	de		;0f07
	pop	hl		;0f08
	ret			;0f09
; ----------------------------------------------------------------------
; 0EE4 – MATH ROUTINE – “FINMUL” and “FINMLT”
;   This subroutine multiplies a number by 10 once. The reason this is a
;   subroutine is that it can also double as a check to see if A is ZERO,
;   thus saving bytes. All registers are affected.
; ----------------------------------------------------------------------
FINMUL:	ret	z		;0f0a
FINMLT:	push	af		;0f0b
	GETYPE			;0f0c - RST 20 - check the current number type
	push	af		;0f0d
	call	po,MUL10	;0f0e - SINGLE Multiply by 10
	pop	af		;0f11
	call	pe,DMUL10	;0f12 - DOUBLE Multiply by 10
	pop	af		;0f15
DCRART:	dec	a		;0f16 - dec the exponent
	ret			;0f17
; ----------------------------------------------------------------------
; 0F18 – MATH ROUTINE – “FINDIV”
;   This subroutine divides a number by 10 once. FIN and FOUT use this
;   routine. Registers A, B, and C are affected.
; ----------------------------------------------------------------------
FINDIV:	push	de		;0f18
	push	hl		;0f19
	push	af		;0f1a
	GETYPE			;0f1b - RST 20 - check the current number type
	push	af		;0f1c
	call	po,DIV10	;0f1d
	pop	af		;0f20
	call	pe,DDIV10	;0f21
	pop	af		;0f24
	pop	hl		;0f25
	pop	de		;0f26
	inc	a		;0f27
	ret			;0f28
; ----------------------------------------------------------------------
; 0F29 – MATH ROUTINE – “FINDIG”
;   This routine will pack the next digit of the number into the ACCumulator.
;   To do this, the ACCumulator is multipled by ten to shift everything
;   over and make room for the digit, and then the digit is added in.
; ----------------------------------------------------------------------
FINDIG:	push	de		;0f29 - save the exponent
	ld	a,b		;0f2a
	adc	a,c		;0f2b
	ld	b,a		;0f2c
	push	bc		;0f2d
	push	hl		;0f2e
	ld	a,(hl)		;0f2f - get the number at program pointer
	sub	'0'		;0f30 - ascii number into biary
	push	af		;0f32 - save the binary digit
	GETYPE			;0f33 - RST 20 - check the current number type
	jp	p,FINDGV	;0f34 - if anything outer than integer
	ld	hl,(FACLO)	;0f37
	ld	de,$0CCD	;0f3a - 3277 to see if x10 will overflow
	CPDEHL			;0f3d - compare
	jr	nc,FINDG2	;0f3e
	ld	d,h		;0f40
	ld	e,l		;0f41
	add	hl,hl		;0f42 - multiply by 2
	add	hl,hl		;0f43 - now multiplied by 4
	add	hl,de		;0f44 - now multiplied by 5
	add	hl,hl		;0f45 - now multiplied by 10
	pop	af		;0f46 - get the binary digit back
	ld	c,a		;0f47 - assign it to c
	add	hl,bc		;0f48 - add it to main number in HL
	ld	a,h		;0f49 -
	or	a		;0f4a - MSB of the integer
	jp	m,FINDG1	;0f4b - if we have overflowed
	ld	(FACLO),hl	;0f4e - store the integer in ACC
FINDGE:	pop	hl		;0f51 - restore input buffer
	pop	bc		;0f52 - restore deciml point info
	pop	de		;0f53 - restore the exponent
	jp	FINC		;0f54
; ----------------------------------------------------------------------
; 0F57 – MATH ROUTINE – “FINDG1”
;   This routine handles 32768 and 32769
; ----------------------------------------------------------------------
FINDG1:	ld	a,c		;0f57
	push	af		;0f58
; ----------------------------------------------------------------------
; 0F59 – MATH ROUTINE – “FINDG2”
;   Convert integer digits into single precision digits
; ----------------------------------------------------------------------
FINDG2:	call	CONSI		;0f59
	scf			;0f5c
; ----------------------------------------------------------------------
; 0F5D – MATH ROUTINE – “FINDGV”
;   Determine if we have a single precision or a double precision number
; ----------------------------------------------------------------------
FINDGV:	jr	nc,FINDGD	;0f5d
	ld	bc,$9474	;0f5f - exponent and MSB of a single precision constant
	ld	de,$2400	;0f62 - NMSB and the LSB of a single precision constant - 1E6
	call	FCOMP		;0f65
	jp	p,FINDG3	;0f68
	call	MUL10		;0f6b
	pop	af		;0f6e
	call	FINLOG		;0f6f
	jr	FINDGE		;0f72
; ----------------------------------------------------------------------
; 0F74 – MATH ROUTINE – “FINDG3” and “FINDGD”
;   The routine will convert a 7 digit single precision number
;   into a double precision number
; ----------------------------------------------------------------------
FINDG3:	call	CONDS		;0f74
FINDGD:	call	DMUL10		;0f77
	call	VMOVAF		;0f7a
	pop	af		;0f7d
	call	FLOAT		;0f7e
	call	CONDS		;0f81
	call	DADD		;0f84
	jr	FINDGE		;0f87
; ----------------------------------------------------------------------
; 0F89H-0F93H – SINGLE PRECISION MATH ROUTINE – “FINLOG”
;   This is a subroutine for FIN and for LOG
; ----------------------------------------------------------------------
FINLOG:	call	PUSHF		;0f89
	call	FLOAT		;0f8c
FADDT:	pop	bc		;0f8f
	pop	de		;0f90
	jp	FADD		;0f91
; ----------------------------------------------------------------------
; 0F94H-0FA6H – MATH ROUTINE – “FINEDG”
;   Pack in a digit of the exponent. This is done by multiplying the
;   old exponent by 10 and then adding in the desired digit.
;   Note: This routine does NOT check for overflow.
; ----------------------------------------------------------------------
FINEDG:	ld	a,e		;0f94
	cp	$0A		;0f95
	jr	nc,FINEDO	;0f97
	rlca			;0f99
	rlca			;0f9a
	add	a,e		;0f9b
	rlca			;0f9c
	add	a,(hl)		;0f9d
	sub	'0'		;0f9e
	ld	e,a		;0fa0
;
	DEFB	JPMNN		;0fa1 - Z80 Trick - JP M,nnnn - skip next 2 bytes
;
FINEDO:	ld	e,$32		;0fa2
	jp	FINEC		;0fa4
; ----------------------------------------------------------------------
; 0FA7H-0FAEH – DISPLAY MESSAGE ROUTINE – “INPRT”
;   Display "IN " and integer stored in HL. Used to display messages
;   such as "BREAK IN nnnnn"
; ----------------------------------------------------------------------
INPRT:	push	hl		;0fa7
	ld	hl,m_INTX	;0fa8
	call	STROUT		;0fab
	pop	hl		;0fae
;
; ======================================================================
; 0FAFH – CONVERT BINARY TO ASCII AND DISPLAY RESULT – “LINPRT”
;
;   This routine converts the two byte number in the HL Register Pair
;   (which is assumed to be an integer) to ASCII and displays it at
;   the current cursor position on the video screen. The space for
;   the sign at the beginning of a line is removed. All registers are affected.
; ----------------------------------------------------------------------
LINPRT:	call	MAKINT		;0faf - Move INT in HL into the ACCumulator
	xor	a		;0fb2
	call	FOUINI		;0fb3
	or	(hl)		;0fb6
	call	FOUT2		;0fb7
	jp	STROUI		;0fba
;
; ----------------------------------------------------------------------
; 0FBDH-1363H – BINARY TO ASCII CONVERSION ROUTINE – “FOUT”
;
;   This routine will output the value held in the ACCumulator according
;   to the format specifications held in Registers A, B, and C.
;   The ACCumulator contents are lost and all registers are affected.
; ----------------------------------------------------------------------
FOUT:	xor	a		;0fbd - Zero Register A so that the format is set for free output
;
; ======================================================================
; 0FBEH – FLOATING to ASCII Conversion Routine – “PUFOUT”
;
;   This routine converts a single or double precision number in the
;   ACCumulator to its ASCII equivalent. The ASCII value is stored at
;   the buffer pointed to by the HL Register Pair. As the value is
;   converted from binary to ASCII, it is formatted as it would be if
;   a PRINT USING statement had been invoked. The format modes that can
;   be specified are selected by loading the A, B, and C registers
; ----------------------------------------------------------------------
PUFOUT:	call	FOUINI		;0fbe - save format spec, and init buffer HL
	and	$08		;0fc1 - check to see if a plus sign is required
	jr	z,FOUT1		;0fc3 - skip over printing of + sign
	ld	(hl),'+'	;0fc5
FOUT1:	ex	de,hl		;0fc7
	call	VSIGN		;0fc8 - Check he sign of the number
	ex	de,hl		;0fcb
	jp	p,FOUT2		;0fcc - A positive number so skip over negative
	ld	(hl),'-'	;0fcf - print a negative sign
	push	bc		;0fd1
	push	hl		;0fd2
	call	VNEG		;0fd3 - Negate the number
	pop	hl		;0fd6
	pop	bc		;0fd7
	or	h		;0fd8
FOUT2:	inc	hl		;0fd9 - inc to next char (after -) in the buffer
	ld	(hl),'0'	;0fda
	ld	a,(TEMP3)	;0fdc - format specification
	ld	d,a		;0fdf
	rla			;0fe0
	ld	a,(VALTYP)	;0fe1 - value type of number
	jp	c,FOUTFX	;0fe4
	jp	z,FOUTZR	;0fe7
	cp	VTSNG		;0fea - compare with Single Precsion
	jp	nc,FOUFRV	;0fec - jump if single or Double precision
	ld	bc,$0000	;0fef -
	call	FOUTCI		;0ff2 - IntToASCII store string in HL bufferL
FOUTZS:	ld	hl,FBUFFR	;0ff5
	ld	b,(hl)		;0ff8
	ld	c,SPACE		;0ff9
	ld	a,(TEMP3)	;0ffb
	ld	e,a		;0ffe
	and	$20		;0fff
	jr	z,FOTZS1	;1001
	ld	a,b		;1003
	cp	c		;1004
	ld	c,'*'		;1005
	jr	nz,FOTZS1	;1007
;
#IFDEF BUGFIX8
	NOP
	DEFC 	BUGFIX8_ENABLED = 1
	PUBLIC 	BUGFIX8_ENABLED
#ELSE
; The ROM's formatting routine incorrectly applies the asterisk
; fill character to the trailing position for positive numbers,
; replacing the intended space with *.
; CREDIT : Ira Goldklang
;
	ld	b,c		;1009
#ENDIF
;
FOTZS1:	ld	(hl),c		;100a
	GETCHR			;100b - rst 10h
	jr	z,FOTZS4	;100c
	cp	'E'		;100e
	jr	z,FOTZS4	;1010
	cp	'D'		;1012
	jr	z,FOTZS4	;1014
	cp	'0'		;1016
	jr	z,FOTZS1	;1018
	cp	','		;101a
	jr	z,FOTZS1	;101c
	cp	'.'		;101e
	jr	nz,FOTZS2	;1020
FOTZS4:	dec	hl		;1022
	ld	(hl),'0'	;1023
FOTZS2:	ld	a,e		;1025
	and	$10		;1026
	jr	z,FOTZS3	;1028
	dec	hl		;102a
	ld	(hl),'$'	;102b
FOTZS3:	ld	a,e		;102d
	and	$04		;102e
	ret	nz		;1030
	dec	hl		;1031
	ld	(hl),b		;1032
	ret			;1033
; ----------------------------------------------------------------------
; 1034 – MATH ROUTINE – “FOUINI”
;   Initially set up the format specs and put in a SPACE for the sign
;   of a positive number. This routine gets called by the FLOATING
;   to ASCII Conversion Routine (at 0FBEH) and by the BINARY to ASCII
;   Conversion Routine (at 0FAFH)
; ----------------------------------------------------------------------
FOUINI:	ld	(TEMP3),a	;1034 - save the format specifiction
	ld	hl,FBUFFR	;1037 - print buffer at 4130
	ld	(hl),SPACE	;103a
	ret			;103c
; ----------------------------------------------------------------------
; 103D – MATH ROUTINE – “FOUFRV”
;   This routine gets called by the FLOATING to ASCII Conversion Routine
;   (0FBEH-0FC0H) if the value being converted is either Single Precision
;   or Double Precision. This will print a single or double precision
;   number in free format
; ----------------------------------------------------------------------
FOUFRV:	cp	$05		;103d - CARRY will be set if double precision number.
	push	hl		;103f
	sbc	a,$00		;1040
	rla			;1042 - number type x2; 08H -> SINGLE; 0AH -> DOUBLE
	ld	d,a		;1043 - Get adjusted number type into D
	inc	d		;1044 - 09H -> SINGLE; 0BH -> DOUBLE
	call	FONTINV		;1045 - scale (normalize) the current value in ACCumulator
	ld	bc,$0300	;1048 - B=3 (decimal point count), C=0 (comma count)
	add	a,d		;104b
	jp	m,FOFRS1	;104c - D is less than .01 then we will need E Notation
	inc	d		;104f
	cp	d		;1050
	jr	nc,FOFRS1	;1051
	inc	a		;1053
	ld	b,a		;1054
	ld	a,$02		;1055
FOFRS1:	sub	$02		;1057
	pop	hl		;1059
	push	af		;105a
	call	FOUTED		;105b
	ld	(hl),'0'	;105e
	call	z,INXHRT	;1060
	call	FOUTCV		;1063
FOFRS2:	dec	hl		;1066
	ld	a,(hl)		;1067
	cp	'0'		;1068
	jr	z,FOFRS2	;106a
	cp	'.'		;106c
	call	nz,INXHRT	;106e
	pop	af		;1071
	jr	z,FOUTDN	;1072
; ----------------------------------------------------------------------
; 1074 – MATH ROUTINE – “FOFLDN”
;   This routine will put the exponent and a D or E into the buffer.
;   On entry, Register A holds the exponent and it is assumed that
;   all FLAGs are set correctly.
; ----------------------------------------------------------------------
FOFLDN:	push	af		;1074
	GETYPE			;1075 - RST 20 - check the current number type
	ld	a,$22		;1076
	adc	a,a		;1078
	ld	(hl),a		;1079
	inc	hl		;107a
	pop	af		;107b
	ld	(hl),'+'	;107c
	jp	p,FOUCE1	;107e
	ld	(hl),'-'	;1081
	cpl			;1083
	inc	a		;1084
; ----------------------------------------------------------------------
; 1085 – MATH ROUTINE – “FOUCE1” and “FOUCE2”
; ----------------------------------------------------------------------
FOUCE1:	ld	b,$2F		;1085
FOUCE2:	inc	b		;1087
	sub	$0A		;1088
	jr	nc,FOUCE2	;108a
	add	a,$3A		;108c
	inc	hl		;108e
	ld	(hl),b		;108f
	inc	hl		;1090
	ld	(hl),a		;1091
FOUTZR:	inc	hl		;1092
; ----------------------------------------------------------------------
; 1093 – MATH ROUTINE – “FOUTDN”
;   This routine will print a free format zero.
; ----------------------------------------------------------------------
FOUTDN:	ld	(hl),$00	;1093
	ex	de,hl		;1095
	ld	hl,FBUFFR	;1096
	ret			;1099
; ----------------------------------------------------------------------
; 109A- MATH ROUTINE – “FOUTFX”
;   This routine will print a number in fixed format.
; ----------------------------------------------------------------------
FOUTFX:	inc	hl		;109a
	push	bc		;109b
	cp	$04		;109c
	ld	a,d		;109e
	jp	nc,FOUFXV	;109f
	rra			;10a2
	jp	c,FFXIFL	;10a3
	ld	bc,$0603	;10a6 - B to a count of 6, C with a comma count of 3
	call	FOUICC		;10a9
	pop	de		;10ac
	ld	a,d		;10ad
	sub	$05		;10ae
	call	p,FOTZER	;10b0
	call	FOUTCI		;10b3
FOUTTD:	ld	a,e		;10b6
	or	a		;10b7
	call	z,DCXHRT	;10b8
	dec	a		;10bb
	call	p,FOTZER	;10bc
; ----------------------------------------------------------------------
; 10BF – MATH ROUTINE – “FOUTTS”
;   This routine will finish up the printing of a fixed format number.
; ----------------------------------------------------------------------
FOUTTS:	push	hl		;10bf
	call	FOUTZS		;10c0
	pop	hl		;10c3
	jr	z,FFXIX1	;10c4
	ld	(hl),b		;10c6
	inc	hl		;10c7
FFXIX1:	ld	(hl),$00	;10c8
	ld	hl,FBUFFR-1	;10ca
FOUBE1:	inc	hl		;10cd
FOUBE5:	ld	a,(TEMP2)	;10ce
	sub	l		;10d1
	sub	d		;10d2
	ret	z		;10d3
	ld	a,(hl)		;10d4
	cp	SPACE		;10d5
	jr	z,FOUBE1	;10d7
	cp	'*'		;10d9
	jr	z,FOUBE1	;10db
	dec	hl		;10dd
	push	hl		;10de
; ----------------------------------------------------------------------
; 10DF – MATH ROUTINE – “FOUBE2”
;   In this routine, we check to see if we can ignore the leading zero
;   before a decimal point.
;   If we see a leading zero, it must be the one before a decimal point
;   or else FOUTZS would have akready suppressed it. In that case, we
;   just INC HL over the character following the zero, and not have to
;   check for the decimal point explicitly.
; ----------------------------------------------------------------------
FOUBE2:	push	af		;10df
	ld	bc,FOUBE2	;10e0
	push	bc		;10e3
	GETCHR			;10e4 - rst 10h
	cp	'-'		;10e5
	ret	z		;10e7
	cp	'+'		;10e8
	ret	z		;10ea
	cp	'$'		;10eb
	ret	z		;10ed
	pop	bc		;10ee
	cp	'0'		;10ef
	jr	nz,FOUBE4	;10f1
	inc	hl		;10f3
	GETCHR			;10f4 - rst 10h
	jr	nc,FOUBE4	;10f5
	dec	hl		;10f7
;
	DEFB	LDBCNN		;10f8 Z80 Trick - LD BC,nnnn - skip next 2 instructions
;
; ----------------------------------------------------------------------
; 10F9 – MATH ROUTINE – “FOUBE3”
;   If we can get rid of the zero, we put the characters on the STACK
;   back into the buffer one position in front of where they originally were.
;   Note that the maximum number of STACK levels this uses is three — one
;   for the last entry flag, one for a possible sign, and one for a possible $.
;   We don’t have to worry about the first character being in the buffer twice
;   because the pointer when FOUT exits will be pointing to the second occurance.
; ----------------------------------------------------------------------
FOUBE3:	dec	hl		;10f9
	ld	(hl),a		;10fa
	pop	af		;10fb
	jr	z,FOUBE3	;10fc
	pop	bc		;10fe
	jp	FOUBE5		;10ff
; ----------------------------------------------------------------------
; 1102 – MATH ROUTINE – “FOUBE4”
;   If the number is too big for the field, we wind up here to deal with that.
; ----------------------------------------------------------------------
FOUBE4:	pop	af		;1102
	jr	z,FOUBE4	;1103
	pop	hl		;1105
	ld	(hl),'%'	;1106
	ret			;1108
; ----------------------------------------------------------------------
; 1109 – MATH ROUTINE – “FOUFXV”
;   This is where the PRINT USING routine will print a single
;   or double precision number in a fixed format
; ----------------------------------------------------------------------
FOUFXV:	push	hl		;1109
	rra			;110a
	jp	c,FFXFLV	;110b
	jr	z,FFXSFX	;110e
	ld	de,FFXDXM	;1110
	call	DCOMPD		;1113
	ld	d,$10		;1116
	jp	m,FFXSDC	;1118
; ----------------------------------------------------------------------
; 111B – MATH ROUTINE – “FFXSDO”
;   This routine will print a number which is greaster than 10^16
;   in free format with a percent sign
; ----------------------------------------------------------------------
FFXSDO:	pop	hl		;111b
	pop	bc		;111c
	call	FOUT		;111d
	dec	hl		;1120
	ld	(hl),'%'	;1121
	ret			;1123
; ----------------------------------------------------------------------
; 1124 – MATH ROUTINE – “FFXSFX”
;   This routine will print a SINGLE PRECISION number in fixed format/fixed point notation
; ----------------------------------------------------------------------
FFXSFX:	ld	bc,$B60E	;1124 - Load Register Pair BC:DE with 1e16
	ld	de,$1BCA	;1127 - BC and DE  SP = to 1×10^16
	call	FCOMP		;112a
	jp	p,FFXSDO	;112d
	ld	d,$06		;1130
; ----------------------------------------------------------------------
; 1124 – MATH ROUTINE – “FFXSDC”
;   This routine will print a SINGLE or DOUBLE number in fixed format/point notation
; ----------------------------------------------------------------------
FFXSDC:	call	SIGN		;1132 - check for ZERO in the ACCumulator
	call	nz,FONTINV	;1135 - not zero, so normalise the number
	pop	hl		;1138
	pop	bc		;1139
	jp	m,FFXXVS	;113a
	push	bc		;113d
	ld	e,a		;113e
	ld	a,b		;113f
	sub	d		;1140
	sub	e		;1141
	call	p,FOTZER	;1142
	call	FOUTCD		;1145
	call	FOUTCV		;1148
	or	e		;114b
	call	nz,FOTZEC	;114c
	or	e		;114f
	call	nz,FOUTED	;1150
	pop	de		;1153
	jp	FOUTTD		;1154
; ----------------------------------------------------------------------
; 1157 – MATH ROUTINE – “FFXXVS”
;   This routine will print a SINGLE or DOUBLE number that has fractional digits
; ----------------------------------------------------------------------
FFXXVS:	ld	e,a		;1157
	ld	a,c		;1158
	or	a		;1159
	call	nz,DCRART	;115a
	add	a,e		;115d
	jp	m,FFXXV8	;115e
	xor	a		;1161
FFXXV8:	push	bc		;1162
	push	af		;1163
FFXXV2:	call	m,FINDIV	;1164
	jp	m,FFXXV2	;1167
	pop	bc		;116a
	ld	a,e		;116b
	sub	b		;116c
	pop	bc		;116d
	ld	e,a		;116e
	add	a,d		;116f
	ld	a,b		;1170
	jp	m,FFXXV3	;1171
	sub	d		;1174
	sub	e		;1175
	call	p,FOTZER	;1176
	push	bc		;1179
	call	FOUTCD		;117a
	jr	FFXXV6		;117d
; ----------------------------------------------------------------------
; 117F – MATH ROUTINE – “FFXXV3”
; ----------------------------------------------------------------------
FFXXV3:	call	FOTZER		;117f
	ld	a,c		;1182
	call	FOUTDP		;1183
	ld	c,a		;1186
	xor	a		;1187
	sub	d		;1188
	sub	e		;1189
	call	FOTZER		;118a
	push	bc		;118d
	ld	b,a		;118e
	ld	c,a		;118f
FFXXV6:	call	FOUTCV		;1190
	pop	bc		;1193
	or	c		;1194
	jr	nz,FFXXV7	;1195
	ld	hl,(TEMP2)	;1197
; ----------------------------------------------------------------------
; 119A – MATH ROUTINE – “FFXXV7”
;   This routine will print trailing zeroes.
; ----------------------------------------------------------------------
FFXXV7:	add	a,e		;119a
	dec	a		;119b
	call	p,FOTZER	;119c
	ld	d,b		;119f
	jp	FOUTTS		;11a0
; ----------------------------------------------------------------------
; 11A3 – MATH ROUTINE – “FFXIFL”
;   This routine will print an integer in fixed format/floating point notation.
; ----------------------------------------------------------------------
FFXIFL:	push	hl		;11a3
	push	de		;11a4
	call	CONSI		;11a5
	pop	de		;11a8
	xor	a		;11a9
; ----------------------------------------------------------------------
; 11AA – MATH ROUTINE – “FFXFLV”
;   This routine will print a SINGLE or DOUBLE PRECISION number in
;   fixed format/floating point notation.
; ----------------------------------------------------------------------
FFXFLV:	jp	z,FFXSFL	;11aa
	ld	e,16		;11ad - maximum length of a double
;
	DEFB	LDBCNN		;11af - Z80 Trick - LD BC,nnnn - skip 2 byte instruction
;
FFXSFL:	ld	e,6		;11b0 - maximum length of a single precision value
	call	SIGN		;11b2 - check to see if we have a zero in the ACCumulator
	scf			;11b5
	call	nz,FONTINV	;11b6 - not zero, so normalise the number
	pop	hl		;11b9
	pop	bc		;11ba
	push	af		;11bb
	ld	a,c		;11bc
	or	a		;11bd
	push	af		;11be
	call	nz,DCRART	;11bf
	add	a,b		;11c2
	ld	c,a		;11c3
	ld	a,d		;11c4
	and	$04		;11c5
	cp	$01		;11c7
	sbc	a,a		;11c9
	ld	d,a		;11ca
	add	a,c		;11cb
	ld	c,a		;11cc
	sub	e		;11cd
	push	af		;11ce
	push	bc		;11cf
FFXLV1:	call	m,FINDIV	;11d0
	jp	m,FFXLV1	;11d3
	pop	bc		;11d6
	pop	af		;11d7
	push	bc		;11d8
	push	af		;11d9
	jp	m,FFXLV3	;11da
	xor	a		;11dd
FFXLV3:	cpl			;11de
	inc	a		;11df
	add	a,b		;11e0
	inc	a		;11e1
	add	a,d		;11e2
	ld	b,a		;11e3
	ld	c,0		;11e4
	call	FOUTCV		;11e6
	pop	af		;11e9
	call	p,FOTZNC	;11ea
	pop	bc		;11ed
	pop	af		;11ee
	call	z,DCXHRT	;11ef
	pop	af		;11f2
	jr	c,FFXLV2	;11f3
	add	a,e		;11f5
	sub	b		;11f6
	sub	d		;11f7
FFXLV2:	push	bc		;11f8
	call	FOFLDN		;11f9
	ex	de,hl		;11fc
	pop	de		;11fd
	jp	FOUTTS		;11fe
; ----------------------------------------------------------------------
; 1201 – Normalise Number in Accumulator – “FOUTNV”
;   This routine will scale (normalize) the number in the accumulator
;   so that all the digits are in the integer part
;   (i.e., between 99,999 and 999,999).
;   The signed base 10 exponent is returned in Register A.
;   Registers D and E are unchanged.
; ----------------------------------------------------------------------
FONTINV: push	de		;1201
	xor	a		;1202 - init the exponent value being returned.
	push	af		;1203 -
	GETYPE			;1204 - RST 20 - check the current number type
	jp	po,FOUNDB	;1205 - If we have a SINGLE PRECISION number
; ----------------------------------------------------------------------
FORBIG:	ld	a,(FAC)		;1208
	cp	$91		;120b
	jp	nc,FOUNDB	;120d
	ld	de,TENTEN	;1210 - pointer to DOUBLE 10,000,000,000
	ld	hl,ARGLO	;1213
	call	VMOVE		;1216
	call	DMULT		;1219
	pop	af		;121c
	sub	$0A		;121d
	push	af		;121f
	jr	FORBIG		;1220 - LOOP BACK UP
; ----------------------------------------------------------------------
FOUNDB:	call	FOUNVC		;1222 - compare the ACCumulator to 999999.5
FOUNDV1: GETYPE			;1225 - RST 20 - check the current number type
	jr	nc,FOUNDV4	;1226 - If we Have DOUBLE or STRING(not logical),
	ld	bc,$9143	;1228
	ld	de,$4FF9	;122b - BC:DE equal to Single value of 99,999.999 ( **** Alternately $5000!!!!)
	call	FCOMP		;122e - compare with value in accumulator
	jr	FOUNDV5		;1231
FOUNDV4: ld	de,FOUTDL	;1233 - pointer to DOUBLE 999,999,999,999,999.95
	call	DCOMPD		;1236 - Compare with value in Accumulator
FOUNDV5: jp	p,FOUNDV3	;1239 - If the number is big enough EXIT ROUTINE
	pop	af		;123c - Get exponent
	call	FINMLT		;123d - multiply by 10, exponent in A is adjusted
	push	af		;1240 - Save exponent
	jr	FOUNDV1		;1241 - LOOP BACK UP
; ----------------------------------------------------------------------
FOUNDVV: pop	af		;1243 - number too big, get exponent off stack
	call	FINDIV		;1244 - Divide a number by 10
	push	af		;1247 - exponent back on stack
	call	FOUNVC		;1248 - compare the ACCumulator to 999999.5
FOUNDV3: pop	af		;124b - exponent off stack
;
#IFDEF VER12
	or	a		;124c
	pop	de		;124d
#ELSE
	pop	de		;124d
	or	a		;124c
#ENDIF
;
	ret			;124e
; ----------------------------------------------------------------------
; 124F – MATH ROUTINE – “FOUNVC”
;   This routine will see if the number in the ACCumulator is small enough yet
; ----------------------------------------------------------------------
FOUNVC:	GETYPE			;124f - RST 20 - check the current number type
	jp	pe,FONVC1	;1250 - If we have a DOUBLE
	ld	bc,$9474	;1253 - the exponent and the MSB of a single precision
	ld	de,$23F8	;1256 - BC and DE = (single precision) 999,999.5
	call	FCOMP		;1259 - compare to accumulator
	jr	FONVC2		;125c
FONVC1:	ld	de,FOUTDU	;125e - address of double = 9,999,999,999,999,999.5
	call	DCOMPD		;1261 - Double Compare
FONVC2:	pop	hl		;1264 - GET return address off stack
	jp	p,FOUNDVV	;1265 - the number in the ACCumulator bigger than
	jp	(hl)		;1268 - number not big enough, RET by JP to (HL)
; ----------------------------------------------------------------------
; 1269H – MATH ROUTINE – “FOTZER”
;   This routine puts leading zeroes into the input buffer. The count is held in A
;   and it can be zero, but the Z FLAG needs to be set in that case.
;   Only (HL) and Register A are affected.
; ----------------------------------------------------------------------
FOTZER:	or	a		;1269
FOTZR1:	ret	z		;126a
	dec	a		;126b
	ld	(hl),'0'	;126c
	inc	hl		;126e
	jr	FOTZR1		;126f
; ----------------------------------------------------------------------
; 1271 – MATH ROUTINE – “FOTZNC”
;   This routine will put zeroes in the buffer along with commans or a decimal
;   point in the middle.
; ----------------------------------------------------------------------
FOTZNC:	jr	nz,FOTZEC	;1271
FOTZRC:	ret	z		;1273
	call	FOUTED		;1274
FOTZEC:	ld	(hl),'0'	;1277
	inc	hl		;1279
	dec	a		;127a
	jr	FOTZRC		;127b
; ----------------------------------------------------------------------
; 127D – MATH ROUTINE – “FOUTCD”
;    This routine will put a possible comma count into Register C and will
;    zero Register C if we are not using commas in the specification.
; ----------------------------------------------------------------------
FOUTCD:	ld	a,e		;127d
	add	a,d		;127e
	inc	a		;127f
	ld	b,a		;1280
	inc	a		;1281
FOTCD1:	sub	$03		;1282
	jr	nc,FOTCD1	;1284
	add	a,$05		;1286
	ld	c,a		;1288
FOUICC:	ld	a,(TEMP3)	;1289
	and	$40		;128c
	ret	nz		;128e
	ld	c,a		;128f
	ret			;1290
; ----------------------------------------------------------------------
; 1291 – MATH ROUTINE – “FOUTED”
;   This routine will put decimal points and commas in their correct places.
;   This subroutine should be called before the next digit is put in the buffer.
;   Register B = the decimal point count and Register C = the comma count.
; ----------------------------------------------------------------------
FOUTED:	dec	b		;1291
	jr	nz,FOUED1	;1292
FOUTDP:	ld	(hl),'.'	;1294
	ld	(TEMP2),hl	;1296
	inc	hl		;1299
	ld	c,b		;129a
	ret			;129b
; ----------------------------------------------------------------------
; 129C – MATH ROUTINE – “FOUED1”
;   Part of the above routine, jumped here to test to see if a comma needs
;   to be placed at (HL).
; ----------------------------------------------------------------------
FOUED1:	dec	c		;129c
	ret	nz		;129d
	ld	(hl),','	;129e
	inc	hl		;12a0
	ld	c,$03		;12a1
	ret			;12a3
; ----------------------------------------------------------------------
; 12A4 – MATH ROUTINE – “FOUTCV”
;   This routine will convert a SINGLE or a DOUBLE PRECISION number
;   that has been normalized to decimal digits.
; ----------------------------------------------------------------------
FOUTCV:	push	de		;12a4
	GETYPE			;12a5 - RST 20 - check the current number type
	jp	po,FOUTCS	;12a6
	push	bc		;12a9
	push	hl		;12aa
	call	VMOVAF		;12ab
	ld	hl,DHALF	;12ae
	call	VMOVFM		;12b1
	call	DADD		;12b4
	xor	a		;12b7
	call	DINTFO		;12b8
	pop	hl		;12bb
	pop	bc		;12bc
	ld	de,FODTBL	;12bd
	ld	a,$0A		;12c0
FOUCD1:	call	FOUTED		;12c2
	push	bc		;12c5
	push	af		;12c6
	push	hl		;12c7
	push	de		;12c8
	ld	b,$2F		;12c9
FOUCD2:	inc	b		;12cb
	pop	hl		;12cc
	push	hl		;12cd
	call	DADDFS		;12ce
	jr	nc,FOUCD2	;12d1
	pop	hl		;12d3
	call	DADDFO		;12d4
	ex	de,hl		;12d7
	pop	hl		;12d8
	ld	(hl),b		;12d9
	inc	hl		;12da
	pop	af		;12db
	pop	bc		;12dc
	dec	a		;12dd
	jr	nz,FOUCD1	;12de
	push	bc		;12e0
	push	hl		;12e1
	ld	hl,DFACLO	;12e2
	call	MOVFM		;12e5
	jr	FOUCDC		;12e8
; ----------------------------------------------------------------------
; 12EA – MATH CONVERSION ROUTINE – “FOUTCS”
; This routine is to convert a SINGLE precision value to an INTEGER which will be the decimal digits.
; ----------------------------------------------------------------------
FOUTCS:	push	bc		;12ea
	push	hl		;12eb
	call	FADDH		;12ec
	inc	a		;12ef
	call	QINT		;12f0
	call	MOVFR		;12f3 - Move single in BC:DE into ACC
FOUCDC:	pop	hl		;12f6
	pop	bc		;12f7
	xor	a		;12f8
	ld	de,FOSTBL	;12f9
; ----------------------------------------------------------------------
; 12FC – MATH ROUTINE – “FOUCS1”
;   This routine is to calculate the next digit of the number.
; ----------------------------------------------------------------------
FOUCS1:	ccf			;12fc
	call	FOUTED		;12fd
	push	bc		;1300
	push	af		;1301
	push	hl		;1302
	push	de		;1303
	call	MOVRF		;1304
	pop	hl		;1307
	ld	b,$2F		;1308
; ----------------------------------------------------------------------
; 130A – MATH ROUTINE – “FOUCS2”
;   This routine divides the integer portion of the current value
;   by 100,000 using compound subtraction.
; ----------------------------------------------------------------------
FOUCS2:	inc	b		;130a
	ld	a,e		;130b
	sub	(hl)		;130c
	ld	e,a		;130d
	inc	hl		;130e
	ld	a,d		;130f
	sbc	a,(hl)		;1310
	ld	d,a		;1311
	inc	hl		;1312
	ld	a,c		;1313
	sbc	a,(hl)		;1314
	ld	c,a		;1315
	dec	hl		;1316
	dec	hl		;1317
	jr	nc,FOUCS2	;1318
	call	FADDA		;131a
	inc	hl		;131d
	call	MOVFR		;131e - Move single in BC:DE into ACC
	ex	de,hl		;1321
	pop	hl		;1322
	ld	(hl),b		;1323
	inc	hl		;1324
	pop	af		;1325
	pop	bc		;1326
	jr	c,FOUCS1	;1327
	inc	de		;1329
	inc	de		;132a
	ld	a,$04		;132b
	jr	FOUCI1		;132d
;
; ======================================================================
; 132F – INTEGER to ASCII – “FOUTCI”
;
;   This routine converts an integer into decimal digits by dividing
;   the integer portion of the current value by 100,000 using compound
;   subtraction. The quotient is kept in Register B as an ASCII value
;   and A=0 on exit.
; ----------------------------------------------------------------------
FOUTCI:	push	de		;132f
	ld	de,FOITBL	;1330
	ld	a,$05		;1333
FOUCI1:	call	FOUTED		;1335
	push	bc		;1338
	push	af		;1339
	push	hl		;133a
	ex	de,hl		;133b
	ld	c,(hl)		;133c
	inc	hl		;133d
	ld	b,(hl)		;133e
	push	bc		;133f
	inc	hl		;1340
	ex	(sp),hl		;1341
	ex	de,hl		;1342
	ld	hl,(FACLO)	;1343
	ld	b,$2F		;1346
FOUCI2:	inc	b		;1348
	ld	a,l		;1349
	sub	e		;134a
	ld	l,a		;134b
	ld	a,h		;134c
	sbc	a,d		;134d
	ld	h,a		;134e
	jr	nc,FOUCI2	;134f
	add	hl,de		;1351
	ld	(FACLO),hl	;1352
	pop	de		;1355
	pop	hl		;1356
	ld	(hl),b		;1357
	inc	hl		;1358
	pop	af		;1359
	pop	bc		;135a
	dec	a		;135b
	jr	nz,FOUCI1	;135c
	call	FOUTED		;135e
	ld	(hl),a		;1361
	pop	de		;1362
	ret			;1363
;
; ----------------------------------------------------------------------
; 1364-136B – DOUBLE PRECISION CONSTANT STORAGE LOCATION – “TENTEN”
; A double precision constant equal to 10,000,000,000
; ----------------------------------------------------------------------
TENTEN:	DEFB	$00, $00, $00, $00, $F9, $02, $15, $A2
;
; ----------------------------------------------------------------------
; 136C-1373 – DOUBLE PRECISION CONSTANT STORAGE LOCATION – “FOUTDL”
; A double precision constant equal to 999,999,999,999,999.95
; ----------------------------------------------------------------------
FOUTDL:	DEFB	$FD, $FF, $9F, $31, $A9, $5F, $63, $B2
;
; ----------------------------------------------------------------------
; 1374-137B – DOUBLE PRECISION CONSTANT STORAGE LOCATION – “FOUTDU”
; A double precision constant equal to 9,999,999,999,999,999.5
; ----------------------------------------------------------------------
FOUTDU:	DEFB	$FE, $FF, $03, $BF, $C9, $1B, $0E, $B6
;
; ----------------------------------------------------------------------
; 137C-1383 – DOUBLE PRECISION CONSTANT STORAGE LOCATION – “DHALF”
; ----------------------------------------------------------------------
; A double precision constant equal to 0.5D0 .
DHALF:	DEFB	$00, $00, $00, $00
;
; A single precision constant equal to 0.5E0 .
; Referencing : half-way through double precision value, results in a single precision value of 0.5
FHALF:	DEFB	$00, $00, $00, $80
;
; ----------------------------------------------------------------------
; 1384-138B – DOUBLE PRECISION CONSTANT STORAGE LOCATION – “FFXDXM”
; A double precision constant equal to 1D16
; ----------------------------------------------------------------------
FFXDXM:	DEFB	$00, $00, $04, $BF, $C9, $1B, $0E, $B6
;
; ----------------------------------------------------------------------
; 138C-13D1 – DOUBLE PRECISION INTEGER CONSTANT STORAGE LOCATION – “FODTBL”
; ----------------------------------------------------------------------
FODTBL:	DEFB	$00, $80, $C6, $A4, $7E, $8D, $03	; 1D15
	DEFB	$00, $40, $7A, $10, $F3, $5A, $00	; 1D14
	DEFB	$00, $A0, $72, $4E, $18, $09, $00	; 1D13
	DEFB	$00, $10, $A5, $D4, $E8, $00, $00	; 1D12
	DEFB	$00, $E8, $76, $48, $17, $00, $00	; 1D10
	DEFB	$00, $E4, $0B, $54, $02, $00, $00	; 1D9
	DEFB	$00, $CA, $9A, $3B, $00, $00, $00	; 1D8
	DEFB	$00, $E1, $F5, $05, $00, $00, $00	; 1D7
	DEFB	$80, $96, $98, $00, $00, $00, $00	; 1D6
	DEFB	$40, $42, $0F, $00, $00, $00, $00	; 1D5
;
; NOTE: The above data does not (exactly) match what is held
; in the TRS-80 web site rom disassembly
;
; ----------------------------------------------------------------------
; 13D2-13D7 – SINGLE PRECISION POWER OF TEN TABLE LOCATION – “FOSTBL
; ----------------------------------------------------------------------
FOSTBL:	DEFB	$A0, $86, $01	; 1E5
	DEFB	$10, $27, $00	; 1E4
;
; ----------------------------------------------------------------------
; 13D8 - 13E1 – SINGLE PRECISION POWER OF TEN TABLE LOCATION – “FOITBL
; ----------------------------------------------------------------------
FOITBL:	DEFB	$10, $27	; 10,000
	DEFB	$E8, $03	; 1,000
	DEFB	$64, $00	; 100
	DEFB	$0A, $00	; 10
	DEFB	$01, $00	; 1
;
; ----------------------------------------------------------------------
; 13E2-13E6 – MATH ROUTINE – “PSHNEG”
; ----------------------------------------------------------------------
PSHNEG:	ld	HL,NNEG		; address of the routine for conversion of floating point numbers from negative to positive
	ex	(sp),hl		;13e5
	jp	(hl)		;13e6
;
; ======================================================================
; 13E7 – LEVEL II BASIC SQR(n) – “FNSQR”
;   This routine computes the square root of any value in ACC. It processes
;   it by raising n to the power of 0.5. The root is left in ACC as a single
;   precision value. Single-precision values only should be used
; ----------------------------------------------------------------------
FNSQR:	call	PUSHF		;13e7
	ld	hl,FHALF	;13ea
	call	MOVFM		;13ed
	jr	FPWRT		;13f0
;
; ======================================================================
; 13F2 - LEVEL II BASIC X to the Y Power (X^Y) ROUTINE – “FPWRQ”
;
;   A call to 13F2H raises the single precision value which has been
;   saved to the STACK to the power specified in ACC. The result will be
;   returned in ACC. The method of computation is e ** (y ln x).
; ----------------------------------------------------------------------
FPWRQ:	call	FRCSNG		;13f2
FPWRT:	pop	bc		;13f5
	pop	de		;13f6
;
; ----------------------------------------------------------------------
; 13F7 – LEVEL II BASIC Exponentiation routine – “FPWR”
;   This routine handles the exponentiation routine of X^Y. To do so,
;   first Y is checked for 0 and, if so, then the answer is simply 1.
;   Then we check X for 0 and, if so, then the answer is simply 0.
; ----------------------------------------------------------------------
FPWR:	call	SIGN		;13f7
	ld	a,b		;13fa
	jr	z,FNEXP		;13fb
	jp	p,POSEXP	;13fd
	or	a		;1400
	jp	z,DV0ERR	;1401
POSEXP:	or	a		;1404
	jp	z,ZERO0		;1405
	push	de		;1408
	push	bc		;1409
	ld	a,c		;140a
	or	$7F		;140b
	call	MOVRF		;140d
	jp	p,FPWR1		;1410
	push	de		;1413
	push	bc		;1414
	call	IINT		;1415
	pop	bc		;1418
	pop	de		;1419
	push	af		;141a
	call	FCOMP		;141b
	pop	hl		;141e
	ld	a,h		;141f
	rra			;1420
FPWR1:	pop	hl		;1421
	ld	(FAC-1),hl	;1422
	pop	hl		;1425
	ld	(FACLO),hl	;1426
	call	c,PSHNEG	;1429
	call	z,NNEG		;142c
	push	de		;142f
	push	bc		;1430
	call	FNLOG		;1431
	pop	bc		;1434
	pop	de		;1435
	call	FMULT		;1436
;
; ======================================================================
; 1439 – LEVEL II ROM EXP ROUTINE. Function "FNEXP"
;
;   Single-precision only. (ACCumulator = EXP(REG1)).
; ----------------------------------------------------------------------
FNEXP:	call	PUSHF		;1439
	ld	bc,$8138	;143c
	ld	de,$AA3B	;143f
	call	FMULT		;1442
	ld	a,(FAC)		;1445
	cp	$88		;1448
	jp	nc,MLDVEX	;144a
	call	IINT		;144d
	add	a,$80		;1450
	add	a,$02		;1452
	jp	c,MLDVEX	;1454
	push	af		;1457
	ld	hl,FONE		;1458
	call	FADDS		;145b
	call	MULLN2		;145e
	pop	af		;1461
	pop	bc		;1462
	pop	de		;1463
	push	af		;1464
	call	FSUB		;1465
	call	NNEG		;1468
	ld	hl,EXPCON	;146b
	call	POLY		;146e
	ld	de,$0000	;1471
	pop	bc		;1474
	ld	c,d		;1475
	jp	FMULT		;1476
;
; ----------------------------------------------------------------------
; 1479-1499 – SINGLE PRECISION CONSTANT STORAGE LOCATION
; This represents 1/6, -1/5, 1/4, -1/3, 1/2, -1, and 1 – “EXPCON”
; ----------------------------------------------------------------------
;
EXPCON:	DEFB	$08		; number of constants which follow
	DEFB	$40, $2E, $94, $74; constant equal to -0.00014171607 (-1.413165 * 10e-4)
	DEFB	$70, $4F, $2E, $77; constant equal to 0.00132988204 (1.32988 * 10e-3, roughly -1/6)
	DEFB	$6E, $02, $88, $7A; constant equal to -0.00830136052 (-8.30136 * 10e-3, roughly -1/5)
	DEFB	$E6, $A0, $2A, $7C; constant equal to 0.04165735095 (roughly 1/4)
	DEFB	$50, $AA, $AA, $7E; constant equal to -0.16666531543 (roughly -1/3)
	DEFB	$FF, $FF, $7F, $7F; constant equal to 0.49999996981 (roughly 1/2)
	DEFB	$00, $00, $80, $81; constant equal to -1.0
	DEFB	$00, $00, $00, $81; constant equal to 1.0
;
; ----------------------------------------------------------------------
; 149A-14C8 – MATH ROUTINE – “POLYX”
;   This is a general purpose summation routine which computes the series
;   C0*X+C1*X^3+C2*X^5+C3*X^7+…+C(N)*X^(2*N+1) for I=0 to N when entered
;   at 149AH If entered at 14A9H the series changes to
;   SUM ((((x*c0+c1)x*c2)x+c3)x+.cN. On entry, the x is held in BC:DE and
;   HL points to a list containing the number of terms followed by the coefficients.
; ----------------------------------------------------------------------
POLYX:	call	PUSHF		;149a
	ld	de,FMULTT	;149d - Load Register Pair DE with the return address of the FMULTT routine …
	push	de		;14a0
	push	hl		;14a1
	call	MOVRF		;14a2
	call	FMULT		;14a5
	pop	hl		;14a8
; ----------------------------------------------------------------------
; 14A9 – MATH ROUTINE – “POLY”
;   General polynomial evaluator routine. Pointer to degree+1 is in (HL),
;   and that gets updated through the computation. The Constants follow
;   the degree and should be stored in reverse order. The ACCumulator has
;   the X. The formula is c0+c1*x+c2*x^2+c3*x^3+…+c(n-1)*x^(n-1)+c(n)*x^n
; ----------------------------------------------------------------------
POLY:	call	PUSHF		;14a9
	ld	a,(hl)		;14ac
	inc	hl		;14ad
	call	MOVFM		;14ae
;
; Z-80 Trick! If passing through, this will simply alter
;Register B and the next instruction of POP AF will not be processed.
	DEFB	LDBNN		;14b1
;
POLY1:	pop	af		;14b2
	pop	bc		;14b3
	pop	de		;14b4
	dec	a		;14b5
	ret	z		;14b6
	push	de		;14b7
	push	bc		;14b8
	push	af		;14b9
	push	hl		;14ba
	call	FMULT		;14bb
	pop	hl		;14be
	call	MOVRM		;14bf
	push	hl		;14c2
	call	FADD		;14c3
	pop	hl		;14c6
	jr	POLY1		;14c7
;
; ----------------------------------------------------------------------
; 14C9-1540 – LEVEL II BASIC RND(n) ROUTINE – “FNRND”.
;   If the passed argument is 0, the last random number generated is returned.
;   If the argument is < 0, a new sequence of random numbers is started using the argument.
; ----------------------------------------------------------------------
FNRND:	call	FRCINT		;14c9 - convert the RND(x) argument to an integer -> HL
	ld	a,h		;14cc - the MSB for the argument value
	or	a		;14cd
	jp	m,FCERR		;14ce - FC Error if number was negative
	or	l		;14d1 - Combine the MSB and LSB of argument, status flags
	jp	z,RND0		;14d2 - If argument is Zero, JUMP to RND(0), which RETurns
	push	hl		;14d5 - Save the RND(x) argument to the Stack
	call	RND0		;14d6 - Call the RND(0) function, generate a number in ACC
	call	MOVRF		;14d9 - Move the generated random number into BC:DE
	ex	de,hl		;14dc - Swap random number into BC/HL
	ex	(sp),hl		;14dd - HL -> integer argument; STACK -> LSB's of RND(0)
	push	bc		;14de - Save MSB's of random number value to STACK
	call	CONSIH		;14df - Store RND(x) argument (in HL) into ACC as Single
	pop	bc		;14e2 - Restore RND(0) from STACK into BC:DE
	pop	de		;14e3
	call	FMULT		;14e4 - Multiply BC:DE with ACC leave result in ACC
	ld	hl,FONE		;14e7 - Single precision constant equal to 1.0
	call	FADDS		;14ea - Add to accumulator
	jp	IINT		;14ed - and convert result into INT and return.
;
; ----------------------------------------------------------------------
; 14F0 – This routine calculates RND(0) – “RND0”.
; ----------------------------------------------------------------------
RND0:	ld	hl,MULTR	;14f0 - starting address for a multiplier table
	push	hl		;14f3 - Save the starting address
	ld	de,$0000	;14f4 - starting value init to 0
	ld	c,e		;14f7 - MSB of the starting value in C/DE
	ld	h,3		;14f8 - counter value for the multiplication loop
RND00:	ld	l,8		;14fa - LOOP counter value of 8 iterations
RND01:	ex	de,hl		;14fc - NMSB and the LSB of random number is in HL
	add	hl,hl		;14fd - Multiply by 2
	ex	de,hl		;14fe - swap back to original registers
	ld	a,c		;14ff - get MSB of the random number into A
	rla			;1500 - Multiply by 2
	ld	c,a		;1501 - put MSB of the random number back into C
	ex	(sp),hl		;1502 - get pointer to the multiplier table is now in HL
	ld	a,(hl)		;1503 - Fetch a multiplier from the the multiplier table
	rlca			;1504 - Multiply by 2
	ld	(hl),a		;1505 - Put multiplier back
	ex	(sp),hl		;1506 - put pointer to the multiplier table back on stack
	jp	nc,RND02	;1507
	push	hl		;150a - Save the counter values
	ld	hl,(RNDX)	;150b - the NMSB and the LSB of the random number seed
	add	hl,de		;150e - add the current random number to the seed
	ex	de,hl		;150f - putting it back into the current random number DE
	ld	a,(RNDX+2)	;1510 - the MSB of the random number seed
	adc	a,c		;1513 - add the current random number to the seed
	ld	c,a		;1514 - putting it back into the current random number C
	pop	hl		;1515 - Restore the counter values
RND02:	dec	l		;1516 - dec the main bit loop counter
	jp	nz,RND01	;1517 - LOOP BACK if not finished, 8 times
	ex	(sp),hl		;151a - get pointer to the multiplier table is now in HL
	inc	hl		;151b - BUMP to the Next Multiplier
	ex	(sp),hl		;151c - put pointer to the multiplier table back on stack
	dec	h		;151d - dec the multiplier loop counter
	jp	nz,RND00	;151e - LOOP BACK if not finished, 3 times
	pop	hl		;1521 - Remove the Multiplier address from the stack.
	ld	hl,$B065	;1522 - re Seed the random number seed
	add	hl,de		;1525 - add the current value to this Seed
	ld	(RNDX),hl	;1526 - Write it back into Seed for latter
	call	VALSNG		;1529 - set the current number type to single precision
	ld	a,5		;152c
	adc	a,c		;152e - Add 5 and the MSB of the random number in C
	ld	(RNDX+2),a	;152f - Write it back into Seed for latter
	ex	de,hl		;1532 - the result is now in A/DE
	ld	b,$80		;1533 - value for the sign flag and the exponent
	ld	hl,FACSGN	;1535 - address for the sign value storage location.
	ld	(hl),b		;1538 - Save the sign result to FACSGN
	dec	hl		;1539
	ld	(hl),b		;153a - Save the exponent into FAC
	ld	c,a		;153b - normalize BC:DE to hold the single
	ld	b,$00		;153c - removing the value of any overflow.
#IFDEF BUGFIX2
	jp	RND0FIX 	; Apply Bugfix 2 on the result of RND(0)
#ELSE
	jp	NORMAL		;153e
#ENDIF
;
; ======================================================================
; 1541 – LEVEL II BASIC COS - FUNCTION "FNCOS"
;
;   Single-precision only.(ACCumulator = COS(ACCumulator)). A call to 1541H
;   computes the cosine for an angle given in radians. The angle must be a
;   floating point value in ACCumulator; the cosine will be returned in
;   ACCumulator as a floating point value.
; ----------------------------------------------------------------------
FNCOS:	ld	hl,PI2		;1541
	call	FADDS		;1544
;
; ======================================================================
; 1547 – LEVEL II BASIC SIN ROUTINE – “SIN”
;
;   Returns the sine as a single precision value in WRA1. The
;   sine must be given in radians in WRA1.
;   Single-precision only.(ACCumulator = SIN(ACCumulator)).
; ----------------------------------------------------------------------
FNSIN:	call	PUSHF		;1547
	ld	bc,$8349	;154a - exponent and the MSB of a single precision constant
	ld	de,$0FDB	;154d - NMSB and the LSB of a single precision constant
	call	MOVFR		;1550 - Move single in BC:DE into ACC
	pop	bc		;1553
	pop	de		;1554
	call	FDIV		;1555
	call	PUSHF		;1558
	call	IINT		;155b
	pop	bc		;155e
	pop	de		;155f
	call	FSUB		;1560
	ld	hl,FR4		;1563
	call	FSUBS		;1566
	call	SIGN		;1569
	scf			;156c
	jp	p,SIN1		;156d
	call	FADDH		;1570
	call	SIGN		;1573
	or	a		;1576
SIN1:	push	af		;1577
	call	p,NNEG		;1578
	ld	hl,FR4		;157b
	call	FADDS		;157e
	pop	af		;1581
	call	nc,NNEG		;1582
	ld	hl,SINCON	;1585
	jp	POLYX		;1588
;
; ----------------------------------------------------------------------
; 158B-158E – SINGLE PRECISION CONSTANT STORAGE LOCATION – “PI2”
; ----------------------------------------------------------------------
PI2:	DEFB	$DB, $0F, $49, $81	; PI/2 Constant = 1.57079637029
; ----------------------------------------------------------------------
; 158F-1592 – SINGLE PRECISION CONSTANT STORAGE LOCATION – “FR4”
; ----------------------------------------------------------------------
FR4:	DEFB	$00, $00, $00, $7F	; 1/4 Constant = 0.25
; ----------------------------------------------------------------------
; 1593-15A7 – SINGLE PRECISION CONSTANTS STORAGE LOCATION – “SINCON”
; ----------------------------------------------------------------------
;
SINCON:	DEFB	05H		; The number of single precision constants (05) which follows
; These are the coefficients used in the power series to compute SIN(x)
	DEFB	$BA, $D7, $1E, $86; 39.7106704708
	DEFB	$64, $26, $99, $87; -76.5749816893
	DEFB	$58, $34, $23, $87; 81.6022338865
	DEFB	$E0, $5D, $A5, $86; -41.3416748045
	DEFB	$DA, $0F, $49, $83; 6.28318500497
;
; ======================================================================
; 15A8 – LEVEL II BASIC TAN(n) ROUTINE – “FNTAN”
;   Computes the tangent of an angle in radians. The angle must be specified
;   as a single precision value in WRA1. The tangent will be left in WRA1
;   Single-precision only.(ACCumulator = TAN(ACCumulator)).
; ----------------------------------------------------------------------
FNTAN:	call	PUSHF		;15a8
	call	FNSIN		;15ab
	pop	bc		;15ae
	pop	hl		;15af
	call	PUSHF		;15b0
	ex	de,hl		;15b3
	call	MOVFR		;15b4 - Move single in BC:DE into ACC
	call	FNCOS		;15b7
	jp	FDIVT		;15ba
;
; ======================================================================
; 15BD – LEVEL II BASIC ATN(n) ROUTINE – “ATN”.
;   Returns the angle in radians, for the floating point tangent value in WRA1.
;   The angle will be left as a single precision value in WRA1
;   Single-precision only.(ACCumulator = ATN(ACCumulator)).
; ----------------------------------------------------------------------
ATAN:	call	SIGN		;15bd
	call	m,PSHNEG	;15c0
	call	m,NNEG		;15c3
	ld	a,(FAC)		;15c6
	cp	$81		;15c9
	jr	c,ATAN2		;15cb
	ld	bc,$8100	;15cd
	ld	d,c		;15d0
	ld	e,c		;15d1
	call	FDIV		;15d2
	ld	hl,FSUBS	;15d5
	push	hl		;15d8
ATAN2:	ld	hl,ATNCON	;15d9
	call	POLYX		;15dc
	ld	hl,PI2		;15df
	ret			;15e2
;
; ----------------------------------------------------------------------
; 15E3-1607 – SINGLE PRECISION CONSTANTS STORAGE LOCATION – “ATNCON”
; ----------------------------------------------------------------------
ATNCON:	DEFB	$09		; number constants which follows
	DEFB	$4A, $D7, $3B, $78; 0.00286622549
	DEFB	$02, $6E, $84, $7B; -0.01616573699
	DEFB	$FE, $C1, $2F, $7C; 0.04290961441
	DEFB	$74, $31, $9A, $7D; 0.07528963666
	DEFB	$84, $3D, $5A, $7D; 0.10656264407
	DEFB	$C8, $7F, $91, $7E; -0.14208900905
	DEFB	$E4, $BB, $4C, $7E; 0.19993549561
	DEFB	$6C, $AA, $AA, $7F; -0.33333146561
	DEFB	$00, $00, $00, $81; 1.0
;
; ----------------------------------------------------------------------
; 1608-18C8 – LIST OF BASIC RESERVED WORDS, TOKENS, AND ENTRY LOCATIONS
; ----------------------------------------------------------------------
;  The original ROM source code makes an interesting note about the order
;  of these reserved words. Some reserved words are contained in other
;  reserved words, which will cause a problem.
; ----------------------------------------------------------------------
	ASSERT $ == $1608, "Segment: Function Dispatch Table Should start at $1608"
; ----------------------------------------------------------------------
; 1608-164F - Function Dispatch Table
;           - for TOKENS stating at $D7 (SGN) to $FA (MID$)
; ----------------------------------------------------------------------
FUNDSP:
	DEFW	FNSGN		; SGN() - ($D7)
	DEFW	FNINT		; INT()
	DEFW	FNABS		; ABS()
	DEFW	FNFRE		; FRE
	DEFW	FNINP		; INP
	DEFW	FNPOS		; POS()
	DEFW	FNSQR		; SQR()
	DEFW	FNRND		; RND()
	DEFW	FNLOG		; LOG()
	DEFW	FNEXP		; EXP()
	DEFW	FNCOS		; COS()
	DEFW	FNSIN		; SIN()
	DEFW	FNTAN		; TAN()
	DEFW	ATAN		; ATAN()
	DEFW	PEEK		; PEEK - ($E5)
	DEFW	DVCVI		; CVI - Disk Basic Token - ($E6)
	DEFW	DVCVS		; CVS - Disk Basic Token
	DEFW	DVCVD		; CVD - Disk Basic Token
	DEFW	DVEOF		; EOF - Disk Basic Token
	DEFW	DVLOC		; LOC - Disk Basic Token
	DEFW	DVLOF		; LOF - Disk Basic Token
	DEFW	DVMKI		; MKI - Disk Basic Token
	DEFW	DVMKS		; MKS - Disk Basic Token
	DEFW	DVMKD		; MKD  - Disk Basic Token- ($EE)
	DEFW	FRCINT		; CINT() - ($EF)
	DEFW	FRCSNG		; CSNG()
	DEFW	FRCDBL		; CDBL
	DEFW	FNFIX		; FIX
	DEFW	FNLEN		; LEN
	DEFW	FNSTR		; STR$
	DEFW	FNVAL		; VAL
	DEFW	FNASC		; ASC
	DEFW	FNCHR		; CHR$
	DEFW	FNLEFT		; LEFT$
	DEFW	FNRGT		; RIGHT$
	DEFW	FNMID		; MID$ - ($FA)
;
; ----------------------------------------------------------------------
; 1650-1821 - Reserved key word list (in token order)
;       * first character ored with 80h to denote start of new token
;       * token ID's start from $80 and increment
;	* token ID is in the comments for reference purposes
;	* table is broken into statments, followed by functions
; ----------------------------------------------------------------------
RESLST:
;
; The following are Statements (80h-BBh)
; Invoked by the Statement Dispatch Table (STMDSP)
;
	DEFB	$C5,"ND"	; END   - $80
	DEFB	$C6,"OR"	; FOR   - $81
	DEFB	$D2,"ESET"	; RESET - $82
	DEFB	$D3,"ET"	; SET   - $83
	DEFB	$C3,"LS"	; CLS
	DEFB	$C3,"MD"	; CMD (disk) - $85
	DEFB	$D2,"ANDOM"	; RANDOM
	DEFB	$CE,"EXT"	; NEXT  - $87
	DEFB	$C4,"ATA"	; DATA  - $88
	DEFB	$C9,"NPUT"	; INPUT
	DEFB	$C4,"IM"	; DIM
	DEFB	$D2,"EAD"	; READ
	DEFB	$CC,"ET"	; LET
	DEFB	$C7,"OTO"	; GOTO  - $8D
	DEFB	$D2,"UN"	; RUN
	DEFB	$C9,"F"		; IF    - $8F
	DEFB	$D2,"ESTORE"	; RESTORE
	DEFB	$C7,"OSUB"	; GOSUB - $91
	DEFB	$D2,"ETURN"	; RETURN
	DEFB	$D2,"EM"	; REM   - $93
	DEFB	$D3,"TOP"	; STOP
	DEFB	$C5,"LSE"	; ELSE  - $95
	DEFB	$D4,"RON"	; TRON
	DEFB	$D4,"ROFF"	; TROFF
	DEFB	$C4,"EFSTR"	; DEFSTR
	DEFB	$C4,"EFINT"	; DEFINT
	DEFB	$C4,"EFSNG"	; DEFSNG
	DEFB	$C4,"EFDBL"	; DEFDBL
	DEFB	$CC,"INE"	; LINE (disk) - $9C
	DEFB	$C5,"DIT"	; EDIT
	DEFB	$C5,"RROR"	; ERROR  - $9E
	DEFB	$D2,"ESUME"	; RESUME - $9F
	DEFB	$CF,"UT"	; OUT
	DEFB	$CF,"N"		; ON     - $A1
	DEFB	$CF,"PEN"	; OPEN (disk) - $A2
	DEFB	$C6,"IELD"	; FIELD (disk)
	DEFB	$C7,"ET"	; GET (disk)
	DEFB	$D0,"UT"	; PUT (disk)
	DEFB	$C3,"LOSE"	; CLOSE (disk)
	DEFB	$CC,"OAD"	; LOAD (disk)
	DEFB	$CD,"ERGE"	; MERGE (disk)
	DEFB	$CE,"AME"	; NAME (disk)
	DEFB	$CB,"ILL"	; KILL (disk)
	DEFB	$CC,"SET"	; LSET (disk)
	DEFB	$D2,"SET"	; RSET (disk)
	DEFB	$D3,"AVE"	; SAVE (disk) - $AD
	DEFB	$D3,"YSTEM"	; SYSTEM
	DEFB	$CC,"PRINT"	; LPRINT
	DEFB	$C4,"EF"	; DEF (disk) - $B0
	DEFB	$D0,"OKE"	; POKE
	DEFB	$D0,"RINT"	; PRINT - $B2
	DEFB	$C3,"ONT"	; CONT
	DEFB	$CC,"IST"	; LIST
	DEFB	$CC,"LIST"	; LLIST
	DEFB	$C4,"ELETE"	; DELETE
	DEFB	$C1,"UTO"	; AUTO
	DEFB	$C3,"LEAR"	; CLEAR
	DEFB	$C3,"LOAD"	; CLOAD
	DEFB	$C3,"SAVE"	; CSAVE
	DEFB	$CE,"EW"	; NEW   - $BB
;
; The following are General Purpose Tokens
;
#IFDEF BUGFIX7C
	DEFB	$D4,"AB"	; TAB - without the (
ELSE
	DEFB	$D4,"AB("	; TAB()     - $BC
#ENDIF
	DEFB	$D4,"O"		; TO        - $BD
	DEFB	$C6,"N"		; FN (disk) - $BE
	DEFB	$D5,"SING"	; USING     - $BF
	DEFB	$D6,"ARPTR"	; VARPTR
	DEFB	$D5,"SR"	; USR
	DEFB	$C5,"RL"	; ERL
	DEFB	$C5,"RR"	; ERR
	DEFB	$D3,"TRING$"	; STRING$
	DEFB	$C9,"NSTR"	; INSTR
	DEFB	$D0,"OINT"	; POINT
	DEFB	$D4,"IME$"	; TIME$ (disk) - $C7
	DEFB	$CD,"EM"	; MEM
	DEFB	$C9,"NKEY$"	; INKEY$
	DEFB	$D4,"HEN"	; THEN
	DEFB	$CE,"OT"	; NOT  - $CB
	DEFB	$D3,"TEP"	; STEP - $CC
;
; Arithmetic, Boolean and Logical Tokens
;
	DEFB	$AB		; + ($CD)
	DEFB	$AD		; - ($CE)
	DEFB	$AA		; *
	DEFB	$AF		; /
	DEFB	$DB		; [ - (up arrow)
	DEFB	$C1,"ND"	; AND - $D2
	DEFB	$CF,"R"		; OR  - $D3
	DEFB	$BE		; > ($D4)
	DEFB	$BD		; =
	DEFB	$BC		; < ($D6)
;
; The following are Functions
; Invoked via function dispatch table (FUNDSP)
;
	DEFB	$D3,"GN"	; SGN - $D7
	DEFB	$C9,"NT"	; INT - $D8
	DEFB	$C1,"BS"	; ABS
	DEFB	$C6,"RE"	; FRE
	DEFB	$C9,"NP"	; INP
	DEFB	$D0,"OS"	; POS
	DEFB	$D3,"QR"	; SQR
	DEFB	$D2,"ND"	; RND
	DEFB	$CC,"OG"	; LOG
	DEFB	$C5,"XP"	; EXP
	DEFB	$C3,"OS"	; COS
	DEFB	$D3,"IN"	; SIN
	DEFB	$D4,"AN"	; TAN
	DEFB	$C1,"TN"	; ATN
	DEFB	$D0,"EEK"	; PEEK
	DEFB	$C3,"VI"	; CVI (disk) - $E6
	DEFB	$C3,"VS"	; CVS (disk)
	DEFB	$C3,"VD"	; CVD (disk)
	DEFB	$C5,"OF"	; EOF (disk)
	DEFB	$CC,"OC"	; LOC (disk)
	DEFB	$CC,"OF"	; LOF (disk)
	DEFB	$CD,"KI$"	; MKI$ (disk)
	DEFB	$CD,"KS$"	; MKS$ (disk)
	DEFB	$CD,"KD$"	; MKD$ (disk) - $ED
	DEFB	$C3,"INT"	; CINT
	DEFB	$C3,"SNG"	; CSNG
	DEFB	$C3,"DBL"	; CDBL
	DEFB	$C6,"IX"	; FIX
	DEFB	$CC,"EN"	; LEN
	DEFB	$D3,"TR$"	; STR$
	DEFB	$D6,"AL"	; VAL
	DEFB	$C1,"SC"	; ASC
	DEFB	$C3,"HR$"	; CHR$
	DEFB	$CC,"EFT$"	; LEFT$  - $F8
	DEFB	$D2,"IGHT$"	; RIGHT$ - $F9
	DEFB	$CD,"ID$"	; MID$   - $FA
;
	DEFB	$A7		; ' (REM)- $FB
;
	DEFB	80h		; END OF TABLE TERMINATOR.
;
	DEFS	$1822 - $	; Padding to account for BUGFIX7C
;
; ----------------------------------------------------------------------
; 1822-1898 - Statement Dispatch Table (command addresses)
;           - in token order staring at token $80 - ending at $BB
; ----------------------------------------------------------------------
STMDSP:
	DEFW	END		; END - ID = $80
	DEFW	FOR		; FOR
	DEFW	RESET		; RESET
	DEFW	SET		; SET
	DEFW	CLS		; CLS
	DEFW	DVCMD		; CMD ( Command Vector )
	DEFW	RANDOM		; RANDOM
	DEFW	NEXT		; NEXT
	DEFW	DATA		; DATA
	DEFW	INPUT		; INPUT
	DEFW	DIM		; DIM
	DEFW	READ		; READ
	DEFW	LET		; LET
	DEFW	GOTO		; GOTO
	DEFW	RUN		; RUN
	DEFW	IF		; IF
	DEFW	RESTORE		; RESTORE
	DEFW	GOSUB		; GOSUB
	DEFW	RETURN		; RETURN
	DEFW	REM		; REM
	DEFW	STOP		; STOP
	DEFW	REM		; ELSE (ELSE is not a standalone command)
	DEFW	TRON		; TRON
	DEFW	TROFF		; TROFF
	DEFW	DEFSTR		; DEFSTR
	DEFW	DEFINT		; DEFINT
	DEFW	DEFREA		; DEFSNG
	DEFW	DEFDBL		; DEFDBL
	DEFW	DVLINE		; LINE ( Command Vector )
	DEFW	EDIT		; EDIT
	DEFW	ERRORS		; ERRORS
	DEFW	RESUME		; RESUME
	DEFW	FNOUT		; FNOUT
	DEFW	ONGOTO		; ON
	DEFW	DVOPEN		; OPEN ( Command Vector )
	DEFW	DVFIEL		; FIELD ( Command Vector )
	DEFW	DVGET		; GET ( Command Vector )
	DEFW	DVPUT		; PUT ( Command Vector )
	DEFW	DVCLOS		; CLOSE ( Command Vector )
	DEFW	DVLOAD		; LOAD ( Command Vector )
	DEFW	DVMERG		; MERGE ( Command Vector )
	DEFW	DVNAME		; NAME ( Command Vector )
	DEFW	DVKILL		; KILL ( Command Vector )
	DEFW	DVLSET		; LSET ( Command Vector )
	DEFW	DVREST		; RSET ( Command Vector )
	DEFW	DVSAVE		; SAVE ( Command Vector )
	DEFW	SYSTEM		; SYSTEM
	DEFW	LPRINT		; LPRINT
	DEFW	DVDEF		; DEF ( Command Vector )
	DEFW	POKE		; POKE
	DEFW	PRINT		; PRINT
	DEFW	CONT		; CONT
	DEFW	LIST		; LIST
	DEFW	LLIST		; LLIST
	DEFW	DELETE		; DELETE
	DEFW	AUTO		; AUTO
	DEFW	CLEAR		; CLEAR
#IFDEF NOCASSETTE
	DEFW	SNERR		; CLOAD
	DEFW	SNERR		; CSAVE
#ELSE
	DEFW	CLOAD		; CLOAD
	DEFW	CSAVE		; CSAVE
#ENDIF
	DEFW	SCRATH		; NEW - ID = $BB
;
; ----------------------------------------------------------------------
; 189A-18A0 - Operation Precedent Table
; ----------------------------------------------------------------------
OPTAB:
	DEFB	$79		; -
	DEFB	$79		; +
	DEFB	$7C		; /
	DEFB	$7C		; *
	DEFB	$7F		; EXPONENT (up arrow)
	DEFB	$50		; AND
	DEFB	$46		; OR
;
; ----------------------------------------------------------------------
; 18A1-18AA - Conversion functions
; ----------------------------------------------------------------------
FRCTBL:
	DEFW	FRCDBL		; double conversion
	DEFW	0
	DEFW	FRCINT		; integer conversion
	DEFW	CHKSTR		; string conversion
	DEFW	FRCSNG		; single precision
;
; ----------------------------------------------------------------------
; 18AB-18B4 - Double precision math
; ----------------------------------------------------------------------
DBLDSP:
	DEFW	DADD		; dp additiion
	DEFW	DSUB		; dp sutraction
	DEFW	DMULT		; dp multiplication
	DEFW	DDIV		; dp division
	DEFW	DCOMP		; dp compare
;
; ----------------------------------------------------------------------
; 18B5-18BE - Single precision math
; ----------------------------------------------------------------------
SNGDSP:
	DEFW	FADD		; sp addition
	DEFW	FSUB		; sp sutraction
	DEFW	FMULT		; sp multiplication
	DEFW	FDIV		; sp division
	DEFW	FCOMP		; sp compare
;
; ----------------------------------------------------------------------
; 18BF-18C8 - Integer math
; ----------------------------------------------------------------------
INTDSP:
	DEFW	IADD		; int addition
	DEFW	ISUB		; int sutraction
	DEFW	IMULT		; int multiplication
	DEFW	INTDIV		; int division
	DEFW	ICOMP		; int compare
;
; ----------------------------------------------------------------------
; 18C9-18F6 – STORAGE LOCATION FOR LEVEL II BASIC ERROR MESSAGES – "ERRTAB"
; table of error strings (2 char each)
; ----------------------------------------------------------------------
ERRTAB:
	DEFB	"NF"		; NEXT without FOR 	(00H)
	DEFB	"SN"		; Syntax Error 		(02H)
	DEFB	"RG"		; RETURN without GOSUB 	(04H)
	DEFB	"OD"		; Out of DATA 		(06H)
	DEFB	"FC"		; Illegal Function Call (08H)
	DEFB	"OV"		; Overflow 		(0AH)
	DEFB	"OM"		; Out of Memory 	(0CH)
	DEFB	"UL"		; Underfined Line Number (0EH)
	DEFB	"BS"		; Subscript out of Range (10H)
	DEFB	"DD"		; Redimensioned Array 	(12H)
	DEFB	"/0"		; Division by Zero 	(14H)
	DEFB	"ID"		; Illegal Direct Operation (16H)
	DEFB	"TM"		; Type Mismatch 	(18H)
	DEFB	"OS"		; Out of String Message (1AH)
	DEFB	"LS"		; Out of Memory 	(1CH)
	DEFB	"ST"		; String Too Long 	(1EH)
	DEFB	"CN"		; Can’t Continue 	(20H)
	DEFB	"NR"		; No RESUME 		(22H)
	DEFB	"RW"		; RESUME Without Error 	(24H)
	DEFB	"UE"		; Unprintable Error 	(26H)
	DEFB	"MO"		; Missing Operand 	(28H)
	DEFB	"FD"		; Bad file Data 	(2AH)
#IFDEF	EACA80
	DEFB	"SN"		; Disk BASIC Command 	(2CH) - On Dick Smith System-80
#ELSE
	DEFB	"L3"		; Disk BASIC Command 	(2CH)
#ENDIF
;
; ----------------------------------------------------------------------
; 18F7-1904 – STORAGE LOCATION FOR THE SINGLE PRECISION DIVISION ROUTINE
;  This code is moved from 18F7-191CH to 4080H-40A5H during non-disk initial setup.
; ----------------------------------------------------------------------
; Single Point Division Routine (4080 - 408D)
CONSTR:	sub	$00		;4080 (FDIVC) - Note Argument is set into working RAM
	ld	l,a		;4082
	ld	a,h		;4083
	sbc	a,$00		;4084 (FDIVB) - Note Argument is set into worikng RAM
	ld	h,a		;4086
	ld	a,b		;4087
	sbc	a,$00		;4088 (FDIVA) - Note Argument is set into working RAM
	ld	b,a		;408A
	ld	a,$00		;408B (FDIVG) - Note Argument is set into working RAM
	ret			;408D
;
	DEFW	FCERR		;408E (USRTAB) - Vector for to USR(0) routine
	DEFB	$40, $E6, $4D	;4090 (MULTR) - Random number seed
;
;	For BUGFIX2 we also attempted the following change which improved the outcome
;	DEFB	$42, $E6, $4D	;4090 (MULTR) - Random number Multipliers 3x 1byte numbers

	in	a,($00)		;4093 (STAINP) - Input Port Routine. Arg Set in RAM
	ret			;4095
	out	($00),a		;4096 (OUTWRD) - Output port routine. Arg Set in RAM
	ret			;4098
;
	DEFB	0		;4099 (CHARC) - Inkey $ Storage
	DEFB	0		;409A (ERRFLG) - current error flag
	DEFB	0		;409B (LPTPOS) - current tab position
	DEFB	DEV0VID		;409C (PRTFLG) - device output flag
	DEFB	64		;409D (LINLEN) - max chars on video disp line
	DEFB	48		;409E (CLMLST) - Size of print line
	DEFB	0		;409F (PARQTD) - Reserved for Model 3
	DEFW	MEMEND+$14C	;40A0 (STKTOP) - String Storage Area (434C)
	DEFW	$FFFE		;40A2 (CURLIN) - Current BASIC Line Number
	DEFW	MEMEND+$E9	;40A4 (TXTTAB) - BASIC Program Statement Table Pointer
;
CONSTR2:
;
; ----------------------------------------------------------------------
; 191D-1923 – MESSAGE STORAGE LOCATION – "ERR"
; ----------------------------------------------------------------------
m_ERR:	DEFB	" Error"
	DEFB	0
;
; Message IN
m_INTX:	DEFB	" in "
	DEFB	0
;
; 1929-192F – MESSAGE STORAGE LOCATION – "REDDY"
m_REDDY: DEFB	"READY"
	DEFB	ENTER
	DEFB	0
;
; 1930-1935 – MESSAGE STORAGE LOCATION – "BRKTXT"
BNKTXT:	DEFB	"Break"
	DEFB	0
;
; ----------------------------------------------------------------------
; 1936-1954 – SCAN STACK ROUTINE – “FNDFOR”
;   This routine is called with DE as the address of the NEXT variable index.
;   It scans the STACK backwards looking for a FOR push. If one is found,
;   it gets the address of the index and compares with the DE that was in
;   place when this routine was called.
;     If NOT found then it exits with A<>0.
;     If FOUND, then it exits with A=0 and
;        HL=Address of 4th Byte in stack.
;        DE=Loop Variable address (typically passed in, not from the Stack)
; ----------------------------------------------------------------------
FNDFOR:	ld	hl,4		;1936 - accounting for this and outer CALL statements
	add	hl,sp		;1939 - move up the stack by 4 bytes
LOOPER:	ld	a,(hl)		;193a - get bytes at stack-4
	inc	hl		;193b - back one more byte
	cp	TKFOR		;193c - Check for a FOR token, asserting STACK item was a FOR loop
	ret	nz		;193e - Wasnt so return.
	ld	c,(hl)		;193f - BC - the pointer to FOR variable
	inc	hl		;1940 - incrementing the memory address pointer
	ld	b,(hl)		;1941
	inc	hl		;1942 - increment to the Sign of the increment
	push	hl		;1943 - save the memory pointer (HL) the Sign of the Increment
	ld	l,c		;1944 - HL - pointer to FOR variable
	ld	h,b		;1945
	ld	a,d		;1946 - check if passed in variable address DE = 0
	or	e		;1947
	ex	de,hl		;1948 - DE -> For variable; HL -> passed in loop variable
	jr	z,POPGOF	;1949 - skip the compare since no variable name was passed in
	ex	de,hl		;194b - DE -> passed in loop variable; HL -> For variable
	CPDEHL			;194c - compare the variable addresses
POPGOF:	ld	bc,14		;194d - amount to advance up the stack
	pop	hl		;1950 - Restore the memory pointer to Sign of the Increment
	ret	z		;1951 - Found so return with HL pointing to the Sign of the Increment
	add	hl,bc		;1952 - Not Found - Move Up stack By 14 bytes to location of next FOR
	jr	LOOPER		;1953 - Loop
; ----------------------------------------------------------------------
; 1955-1962 – DATA MOVEMENT ROUTINE – “BLTU”
;   This routine moves a variable into another area specified by the caller.
;   On entry BC is set as the end address of the list to move (which is
;   the upper limit); DE is set as the start address of the list to move;
;   and HL is the end of the area to move it to.
; ----------------------------------------------------------------------
BLTU:	call	REASON		;1955
BLTUC:	push	bc		;1958
	ex	(sp),hl		;1959
	pop	bc		;195a
BLTLOP:	CPDEHL			;195b
	ld	a,(hl)		;195c
	ld	(bc),a		;195d
	ret	z		;195e
	dec	bc		;195f
	dec	hl		;1960
	jr	BLTLOP		;1961
; ----------------------------------------------------------------------
; 1963-197D – MEMORY CHECK ROUTINE – “GETSTK”
;   This routine computes the amount of space between HL and the end of memory
;   at FFC6. On entry, Register C should hold the number of desired bytes.
; ----------------------------------------------------------------------
GETSTK:	push	hl		;1963
	ld	hl,(STREND)	;1964
	ld	b,$00		;1967
	add	hl,bc		;1969
	add	hl,bc		;196a
;
	DEFB	LDANN		;196b - Z80 Trick - LD A,nn - skip next 1 byte instruction
;
REASON:	push	hl		;196c
	ld	a,$C6		;196d
	sub	l		;196f
	ld	l,a		;1970
	ld	a,$FF		;1971
	sbc	a,h		;1973
	jr	c,OMERR		;1974
	ld	h,a		;1976
	add	hl,sp		;1977
	pop	hl		;1978
	ret	c		;1979
;
; ----------------------------------------------------------------------
; 197AH – ?OM ERROR ENTRY POINT – “OMERR”
; ----------------------------------------------------------------------
OMERR:	ld	e,ERROM		;197a
	jr	ERROR		;197c
;
; ----------------------------------------------------------------------
; 197E-1AF7 – LEVEL II BASIC COMMAND MODE ERROR HANDLING – “PRGEND”
; ----------------------------------------------------------------------
PRGEND:	ld	hl,(CURLIN)	;197e
	ld	a,h		;1981
	and	l		;1982
	inc	a		;1983
	jr	z,ENDCNJ	;1984
	ld	a,(ONEFLG)	;1986
	or	a		;1989
	ld	e,ERRNR		;198a
	jr	nz,ERROR	;198c
ENDCNJ:	jp	ENDCON		;198e
DATSNE:	ld	hl,(DATLIN)	;1991
	ld	(CURLIN),hl	;1994
; ----------------------------------------------------------------------
; 1997H – ?SN ERROR ENTRY POINT – “SNERR”
; ----------------------------------------------------------------------
SNERR:	ld	e,ERRSN		;1997 - ?SN ERROR
;
; ----------------------------------------------------------------------
; 1999A – ?D0 ERROR ENTRY POINT – “DV0ERR”
; ----------------------------------------------------------------------
	DEFB	LDBCNN		;1999 Z80 Trick LD BC,nnnn - skips the next 2 byte instruction
DV0ERR:	ld	e,ERRD0		;199A - ?/0 ERROR
;
; ----------------------------------------------------------------------
; 199DH – ?NF ERROR ENTRY POINT – “NFERR”
; ----------------------------------------------------------------------
	DEFB	LDBCNN		;199c  Z80 Trick LD BC,nnnn - skips the next 2 byte instruction
NFERR:	ld	e,ERRNF		;199d - ?NF ERROR
;
; ----------------------------------------------------------------------
; 19A0H – ?OV ERROR ENTRY POINT – “REERR”
; ----------------------------------------------------------------------
	DEFB	LDBCNN		;199f  Z80 Trick LD BC,nnnn - skips the next 2 byte instruction
REERR:	ld	e,ERRRW		;19A0 - ?RW ERROR
;
; ----------------------------------------------------------------------
; 19A2 - Entry Point For Errors
; ----------------------------------------------------------------------
ERROR:	ld	hl,(CURLIN)	;19a2
	ld	(ERRLIN),hl	;19a5
	ld	(DOT),hl	;19a8
ERRESM:	ld	bc,ERRMOR	;19ab - ret addr - continuation address after reinit
;
; ----------------------------------------------------------------------
; 19AE - ALTERNATE ENTRY TO BASIC "READY"
; This will work with both the Model I and the Model III
; To use this routine, load the BC with 1A18H, then JP the 19AE
; On the model 1 (and Enhanced Model 3) A simple JP 06CCH will work
; ----------------------------------------------------------------------
ERESET:	ld	hl,(SAVSTK)	;19ae
	jp	STKERR		;19b1
;
; ----------------------------------------------------------------------
; 19B4 – LEVEL II BASIC COMMAND MODE ERROR HANDLING – “ERRMOR”
; ----------------------------------------------------------------------
ERRMOR:	pop	bc		;19b4
	ld	a,e		;19b5
	ld	c,e		;19b6
	ld	(ERRFLG),a	;19b7
	ld	hl,(SAVTXT)	;19ba
	ld	(ERRTXT),hl	;19bd
	ex	de,hl		;19c0
	ld	hl,(ERRLIN)	;19c1
	ld	a,h		;19c4
	and	l		;19c5
	inc	a		;19c6
	jr	z,NTMDCN	;19c7
	ld	(OLDLIN),hl	;19c9
	ex	de,hl		;19cc
	ld	(OLDTXT),hl	;19cd
NTMDCN:	ld	hl,(ONELIN)	;19d0
	ld	a,h		;19d3
	or	l		;19d4
	ex	de,hl		;19d5
	ld	hl,ONEFLG	;19d6
	jr	z,NOTRAP	;19d9
	and	(hl)		;19db
	jr	nz,NOTRAP	;19dc
	dec	(hl)		;19de
	ex	de,hl		;19df
	jp	GONE4		;19e0
; ----------------------------------------------------------------------
; 19E3 – LEVEL II BASIC COMMAND MODE ERROR HANDLING – “NOTRAP”
; ----------------------------------------------------------------------
NOTRAP:	xor	a		;19e3
	ld	(hl),a		;19e4
	ld	e,c		;19e5
	call	CRDONZ		;19e6
	ld	hl,ERRTAB	;19e9
	call	EXDSKR		;19ec - dos err handling
	ld	d,a		;19ef
	ld	a,'?'		;19f0
	call	OUTDO		;19f2
	add	hl,de		;19f5
	ld	a,(hl)		;19f6
	call	OUTDO		;19f7
	GETCHR			;19fa - rst 10h
	call	OUTDO		;19fb
	ld	hl,m_ERR	;19fe
	push	hl		;1a01
	ld	hl,(ERRLIN)	;1a02
	ex	(sp),hl		;1a05
ERRFIN:	call	STROUT		;1a06
	pop	hl		;1a09
	ld	de,$FFFE	;1a0a
	CPDEHL			;1a0d
#IFDEF MODEL3ROM
	jp	z,CIO		;1a0e
#ELSE
	jp	z,INIT		;1a0e
#ENDIF
	ld	a,h		;1a11
	and	l		;1a12
	inc	a		;1a13
	call	nz,INPRT	;1a14
;
	DEFB	LDANN		; Z80 Trick - LD A,nn - skip next 1 byte instruction
;
STPRDY:	pop	bc		;1a18
;
; ======================================================================
; 1A19 - OFFICIAL" RETURN TO BASIC "READY"
;  The disadvantage of using this entry is that it will often return
;   an "Out Memory Error" message response to the next command typed
;   in, even though the condition does not exist.
;  Often 06CCH or 0072H are used as alternatives, but these dont work on M3
;  See 19AE which also provides a good entry point and works on M1 and M3
; ======================================================================
	ASSERT	$ == $1A19, "Segment: READY Entry Point Should start at $1A19"
READY:	call	FINLPT		;1a19 - set the current output device to the video display
	call	PRGFIN		;1a1c - dos exit for BASIC startup
#IFDEF NOCASSETTE
	NOP3			;skip the cassette call
#ELSE
	call	CTOFF		;1a1f - turn off the cassette recorder
#ENDIF
	call	CRDONZ		;1a22 - display a carriage return if necessary
	ld	hl,m_REDDY	;1a25 - the starting address of word “READY”
	call	STROUT		;1a28 - Display the word “READY”
	ld	a,(ERRFLG)	;1a2b - load A with the value of the current error code
	sub	ERRSN		;1a2e - compare with SYNTAX ERROR
	call	z,ERREDT	;1a30 - If an SN ERR, enter EDIT mode on that line
;
;
; ======================================================================
; ======================================================================
; 1A33-1A5F – MAIN LEVEL II BASIC INTERPRETER ENTRY – “MAIN”
;
;    Handle normal command prompt and AUTO Processing
; ----------------------------------------------------------------------
MAIN:	ld	hl,$FFFF	;1a33
	ld	(CURLIN),hl	;1a36
	ld	a,(AUTFLG)	;1a39
	or	a		;1a3c
	jr	z,NTAUTO	;1a3d - for normal User Prompt ump Down
; ----------------------------------------------------------------------
; Auto processing continues here
;   If the jump here was from an AUTO call, (40E4H) will have the increment
;   number, (40E1H) will be 0 if no AUTO and non-zero if AUTO, and (40E2H)
;   will have the starting line number.
; ----------------------------------------------------------------------
	ld	hl,(AUTLIN)	;1a3f
	push	hl		;1a42
	call	LINPRT		;1a43
	pop	de		;1a46
	push	de		;1a47
	call	FNDLIN		;1a48
	ld	a,'*'		;1a4b
	jr	c,AUTELN	;1a4d
	ld	a,SPACE		;1a4f
AUTELN:	call	OUTDO		;1a51
	call	INLIN		;1a54
	pop	de		;1a57
	jr	nc,AUTGOD	;1a58
AUTRES:	xor	a		;1a5a
	ld	(AUTFLG),a	;1a5b
	jr	READY		;1a5e
AUTGOD:	ld	hl,(AUTINC)	;1a60
	add	hl,de		;1a63
	jr	c,AUTRES	;1a64
	push	de		;1a66
	ld	de,$FFF9	;1a67
	CPDEHL			;1a6a
	pop	de		;1a6b
	jr	nc,AUTRES	;1a6c
	ld	(AUTLIN),hl	;1a6e
	or	$FF		;1a71
	jp	EDITRT		;1a73
; ----------------------------------------------------------------------
; 1A76H-1AF7 – NOT AN AUTO – “NTAUTO”
;   Command entry comes here if we are not in an Auto Command
; ----------------------------------------------------------------------
NTAUTO:	ld	a,'>'		;1a76
	call	OUTDO		;1a78 - Display the > Prompt
	call	INLIN		;1a7b - Read a Line
	jp	c,MAIN		;1a7e - loop back if BREAK pressed
	GETCHR			;1a81 - rst 10h
	inc	a		;1a82 - sets the status flags but saves the carry flag
	dec	a		;1a83 - so we can test for an end of statement
	jp	z,MAIN		;1a84 - if we have an end of (or blank) statement
	push	af		;1a87
	call	LINGET		;1a88 - convert line pointer to Integer
BAKSP:	dec	hl		;1a8b - back pointer up
	ld	a,(hl)		;1a8c - get the character
	cp	SPACE		;1a8d - was it a space
	jr	z,BAKSP		;1a8f - Loop back over any space characters
	inc	hl		;1a91 - finally pushing pointer to first space.
	ld	a,(hl)		;1a92 - get the character
	cp	SPACE		;1a93
	call	z,INXHRT	;1a95
EDENT:	push	de		;1a98
	call	CRUNCH		;1a99 - TOKENIZE THE INPUT
	pop	de		;1a9c
	pop	af		;1a9d
	ld	(SAVTXT),hl	;1a9e - Save the command txt pointer
	call	DIRDO		;1aa1 - DOS EXIT - Give a DOS chance to process
	jp	nc,GONE1	;1aa4 - IF The was a DIRECT STATEMENT
	push	de		;1aa7
	push	bc		;1aa8
	xor	a		;1aa9
	ld	(BFKLFL),a	;1aaa
	GETCHR			;1aad - rst 10h
	or	a		;1aae
	push	af		;1aaf
	ex	de,hl		;1ab0
	ld	(DOT),hl	;1ab1
	ex	de,hl		;1ab4
	call	FNDLIN		;1ab5 - Search for a Line Number from DE
	push	bc		;1ab8
	call	c,DELDEL	;1ab9
	pop	de		;1abc
	pop	af		;1abd
	push	de		;1abe
	jr	z,FINI		;1abf
	pop	de		;1ac1
	ld	hl,(VARTAB)	;1ac2
	ex	(sp),hl		;1ac5
	pop	bc		;1ac6
	add	hl,bc		;1ac7
	push	hl		;1ac8
	call	BLTU		;1ac9 - check for enough memory for the new BASIC line
	pop	hl		;1acc
	ld	(VARTAB),hl	;1acd
	ex	de,hl		;1ad0
	ld	(hl),h		;1ad1
	pop	de		;1ad2
	push	hl		;1ad3
	inc	hl		;1ad4
	inc	hl		;1ad5
	ld	(hl),e		;1ad6
	inc	hl		;1ad7
	ld	(hl),d		;1ad8
	inc	hl		;1ad9
	ex	de,hl		;1ada
	ld	hl,(BUFPNT)	;1adb
	ex	de,hl		;1ade
	dec	de		;1adf
	dec	de		;1ae0
MLOOPR:	ld	a,(de)		;1ae1
	ld	(hl),a		;1ae2
	inc	hl		;1ae3
	inc	de		;1ae4
	or	a		;1ae5
	jr	nz,MLOOPR	;1ae6
FINI:	pop	de		;1ae8
	call	CHEAD		;1ae9
	call	EXFIND		;1aec
	call	RUNC		;1aef
	call	EXFIN2		;1af2
	jp	MAIN		;1af5
; ----------------------------------------------------------------------
; 1AF8-1B0F – LINE POINTERS ROUTINE – “LINKER”
;   This routine fixes the line pointers in a BASIC program.
;   This is useful, for instance for a renumber program which has to move
;   BASIC program lines from one location in memory to an other, which
;   means that the line pointers would no longer be valid. This routine
;   will fix them. Registers A, HL and DE are used
; ----------------------------------------------------------------------
LINKER:	ld	hl,(TXTTAB)	;1af8
	ex	de,hl		;1afb
CHEAD:	ld	h,d		;1afc
	ld	l,e		;1afd
	ld	a,(hl)		;1afe
	inc	hl		;1aff
	or	(hl)		;1b00
	ret	z		;1b01
	inc	hl		;1b02
	inc	hl		;1b03
	inc	hl		;1b04
	xor	a		;1b05
CZLOOP:	cp	(hl)		;1b06
	inc	hl		;1b07
	jr	nz,CZLOOP	;1b08
	ex	de,hl		;1b0a
	ld	(hl),e		;1b0b
	inc	hl		;1b0c
	ld	(hl),d		;1b0d
	jr	CHEAD		;1b0e
; ----------------------------------------------------------------------
; 1B10-1B48 – EVALUATE LINE NUMBERS – “SCNLINE”
;   This is called by LIST and DELETE. It converts the starting and ending
;   line numbers (X-Y) to binary and saves the ending line number on the STACK.
;   Then the code locates the program table address for the starting line.
;   The routine leaves the address of the starting line in BC and the ending
;   line number in the STACK.
; ----------------------------------------------------------------------
SCNLINE: ld	de,$0000	;1b10
	push	de		;1b13
	jr	z,ALLLST	;1b14
	pop	de		;1b16
	call	LINSPC		;1b17
	push	de		;1b1a
	jr	z,SNGLIN	;1b1b
	SYNTAX	(TKMNUS)	;1b1d - rst 08h
ALLLST:	ld	de,$FFFA	;1b1f
	call	nz,LINSPC	;1b22
	jp	nz,SNERR	;1b25
SNGLIN:	ex	de,hl		;1b28
	pop	de		;1b29
FNDLN1:	ex	(sp),hl		;1b2a
	push	hl		;1b2b
; ----------------------------------------------------------------------
; 1B2CH – SEARCH FOR A LINE NUMBER – “FNDLIN”
;   FNDLIN routine searches the program text for the line whose line
;   number is held in Register Pair DE. DE is preserved.
; ----------------------------------------------------------------------
FNDLIN:	ld	hl,(TXTTAB)	;1b2c
FNLOOP:	ld	b,h		;1b2f
	ld	c,l		;1b30
	ld	a,(hl)		;1b31
	inc	hl		;1b32
	or	(hl)		;1b33
	dec	hl		;1b34
	ret	z		;1b35
	inc	hl		;1b36
	inc	hl		;1b37
	ld	a,(hl)		;1b38
	inc	hl		;1b39
	ld	h,(hl)		;1b3a
	ld	l,a		;1b3b
	CPDEHL			;1b3c
	ld	h,b		;1b3d
	ld	l,c		;1b3e
	ld	a,(hl)		;1b3f
	inc	hl		;1b40
	ld	h,(hl)		;1b41
	ld	l,a		;1b42
	ccf			;1b43
	ret	z		;1b44
	ccf			;1b45
	ret	nc		;1b46
	jr	FNLOOP		;1b47
;
; ----------------------------------------------------------------------
; 1B49-1B5C – LEVEL II BASIC NEW ROUTINE – “SCRATH”
; ----------------------------------------------------------------------
SCRATH:	ret	nz		;1b49
; ----------------------------------------------------------------------
; 1B4A - Does a NEW as well as clearing the screen
; ----------------------------------------------------------------------
	call	CLS		;1b4a
; ----------------------------------------------------------------------
; 1B4D - NEW - This routine will wipe out the BASIC program currently
;    in memory by resetting the pointers associated with it .
; ----------------------------------------------------------------------
SCRTCH:	ld	hl,(TXTTAB)	;1b4d
	call	TROFF		;1b50
	ld	(AUTFLG),a	;1b53
	ld	(hl),a		;1b56
	inc	hl		;1b57
	ld	(hl),a		;1b58
	inc	hl		;1b59
	ld	(VARTAB),hl	;1b5a
;
; ----------------------------------------------------------------------
; 1B5D-1BB2 – LEVEL II BASIC RUN ROUTINE – “RUNC”
;   This is called by "RUN" routine when NO Line number is specified
;
;   This routine does a lot of variable resets and other things that are
;   common to NEW as well, so NEW just does the special NEW stuff
;   and than passes right through to here to reset the rest.
; ----------------------------------------------------------------------
#IFDEF MODEL3ROM
RUNC:	call 	SCROLLP		;1b5d - clear video scroll protection
#ELSE
RUNC:	ld	hl,(TXTTAB)	;1b5d - the PST (the start of the BASIC program pointer).
#ENDIF
	dec	hl		;1b60
;
; ----------------------------------------------------------------------
; 1B61H – Subroutine which initializes a lot of stuff – “CLEARC”
;   Initialize he variable and array space by resetting
;   ARYTAB (which is the end of the the simple variable spac) and
;   STREND (which is the end of the array storage).
;   It then falls into STKINI which resets the STACK. HL is preserved.
; ----------------------------------------------------------------------
CLEARC:	ld	(TEMP),hl	;1b61
	ld	b,26		;1b64 - number of variable names to be initialized
	ld	hl,DEFTBL	;1b66
LOFDPT:	ld	(hl),$04	;1b69
	inc	hl		;1b6b
	djnz	LOFDPT		;1b6c
	xor	a		;1b6e
	ld	(ONEFLG),a	;1b6f
	ld	l,a		;1b72
	ld	h,a		;1b73
	ld	(ONELIN),hl	;1b74
	ld	(OLDTXT),hl	;1b77
	ld	hl,(MEMSIZ)	;1b7a
	ld	(FRETOP),hl	;1b7d
	call	RESTORE		;1b80
	ld	hl,(VARTAB)	;1b83
	ld	(ARYTAB),hl	;1b86
	ld	(STREND),hl	;1b89
	call	CLSALL		;1b8c
;
; ----------------------------------------------------------------------
; 1B8F – Subroutine which initializes Stack and others – "STKINI"
;   this routine resets the STACK point, which will also destroy all GOSUBs and FORs.
;   String temporaries are freed, SUBFLG is reset, CONT is forbidden,
;   and a dummy entry is put on the STACK, so that FNDFOR will always find a NON-"FOR"
;   entry at the bottom of the STACK. A will be reset to 0 and Register Pair DE is preserved.
; ----------------------------------------------------------------------
STKINI:	pop	bc		;1b8f - get return address off stack
	ld	hl,(STKTOP)	;1b90 - MEMSIZE-32
	dec	hl		;1b93
	dec	hl		;1b94 - now room for a FNDFOR stopper value to be put on the STACK
	ld	(SAVSTK),hl	;1b95 - save pointer
	inc	hl		;1b98
	inc	hl		;1b99 - back to being the start of the string space pointer
STKERR:	ld	sp,hl		;1b9a - MAIN SET SP with the start of the string space pointer
	ld	hl,TEMPST	;1b9b - start of the string work area
	ld	(TEMPPT),hl	;1b9e - init string temps - the next available location in the string work area
	call	FINLPT		;1ba1 - set the current output device to the video display
	call	FINPRT		;1ba4 - turn off the cassette recorder
	xor	a		;1ba7
	ld	h,a		;1ba8
	ld	l,a		;1ba9
	ld	(SUBFLG),a	;1baa - Clear the FOR statement flag.
	push	hl		;1bad - put FNDFOR stopper value on the STACK
	push	bc		;1bae - Save the RETURN ADDRESS back on the STACK
	ld	hl,(TEMP)	;1baf - Restore Register Pair HL so it is preserved
	ret			;1bb2
;
; ======================================================================
; 1BB3 – KEYBOARD INPUT ROUTINE – “QINLIN”
;
;   This is the last of the general purpose input routines. This routine
;   functions identically to the 0361H routine with the exception that it
;   prints a ? on the screen (like INPUT does with BASIC) before allowing
;   input from the keyboard.
; ----------------------------------------------------------------------
QINLIN:	ld	a,'?'		;1bb3
	call	OUTDO		;1bb5
	ld	a,SPACE		;1bb8
	call	OUTDO		;1bba
	jp	INLIN		;1bbd
;
; ----------------------------------------------------------------------
; 1BC0-1C8F – TOKENIZE INPUT ROUTINE – “CRUNCH”
;   This routine translates all “reserved words” into single bytes with the
;   MSB on. This saves space and time by allowing for table dispatch during
;   execution, and, as such, all statements appear together in the ; reserved
;   word list in the same ; order they appear in in STMDSP.
; ----------------------------------------------------------------------
CRUNCH:	xor	a		;1bc0
	ld	(DORES),a	;1bc1
	ld	c,a		;1bc4
	ex	de,hl		;1bc5
	ld	hl,(BUFPNT)	;1bc6
	dec	hl		;1bc9
	dec	hl		;1bca
	ex	de,hl		;1bcb
KLOOP:	ld	a,(hl)		;1bcc
	cp	SPACE		;1bcd
	jp	z,STUFFH	;1bcf
	ld	b,a		;1bd2
	cp	DQUOTE		;1bd3 - Check to see if the current character is a "
	jp	z,STRNG		;1bd5
	or	a		;1bd8
	jp	z,CRDONE	;1bd9
	ld	a,(DORES)	;1bdc
	or	a		;1bdf
	ld	a,(hl)		;1be0
	jp	nz,STUFFH	;1be1
	cp	'?'		;1be4 - Check to see if is a ? (PRINT statement)
	ld	a,TKPRNT	;1be6 - Token PRINT for next line
	jp	z,STUFFH	;1be8 - If we have a ? then make believe it is a "PRINT"
	ld	a,(hl)		;1beb - Re-fetch the current char (from input buffer)
	cp	'0'		;1bec - if less than a zero character (alpha numeric)
	jr	c,MUSTCR	;1bee - meaning it is not a digit or letter
	cp	'<'		;1bf0 - is less than < character (if it is 0–9, :, ;, <)
	jp	c,STUFFH	;1bf2 - char is 0–9, :, ;, <, constant or special character
MUSTCR:	push	de		;1bf5 - Save the value of the input buffer pointer
	ld	de,RESLST-1	;1bf6 - reserved words list (first instruction in the LOPSKP is to INC)
	push	bc		;1bf9 - Save the character count
	ld	bc,NOTRES	;1bfa - return address after matching the reserved word list
	push	bc		;1bfd - save RET address
	ld	b,$7F		;1bfe - initialize the reserved words counter
	ld	a,(hl)		;1c00 - character at the location of the input buffer
	cp	'a'		;1c01 - lower-case chaeck
	jr	c,TRYAGA	;1c03 - if the character in Register A isn't lowercase
	cp	'z'+1		;1c05 - is within the lower-case range
	jr	nc,TRYAGA	;1c07 - if the character in Register A isn't lowercase
	and	$5F		;1c09 - Covert the lowercase to upper-case
	ld	(hl),a		;1c0b - Replace the character in the input buffer with upper case
TRYAGA:	ld	c,(hl)		;1c0c - character at the location of the input buffer
	ex	de,hl		;1c0d - DE -> input buffer pointer; HL -> reserved words list pointer
LOPSKP:	inc	hl		;1c0e - Bump the reserved words list pointer
	or	(hl)		;1c0f - find the start of a reserved word. Bit7 = 1
	jp	p,LOPSKP	;1c10 - LOOP until we find start of a reserved work
	inc	b		;1c13 - Bump the reserved words counter
	ld	a,(hl)		;1c14 - character at the location of the reserved words list
	and	$7F		;1c15 - Reset the MSB Bit 7 of the character from reserved word list
	ret	z		;1c17 - EXIT if we are at the end of ther reserved word list
	cp	c		;1c18 - compare with character from input buffer
	jr	nz,LOPSKP	;1c19 - if characters DONT match, loop, keep looking
	ex	de,hl		;1c1b - DE -> reserved words list pointer; HL -> input buffer pointer
	push	hl		;1c1c - save the input buffer pointer
LOPPSI:	inc	de		;1c1d - Bump the value of the reserved words list pointer
	ld	a,(de)		;1c1e - next char of reserved word
	or	a		;1c1f - set flags
	jp	m,FOUND		;1c20 - If Bit 7 was set, new reserved word, Found a match, so jump
; ----------------------------------------------------------------------
; If we are here then we are in the middle of checking against the reserved word list,
; and we are still in the middle of a reserved word that might be a potential match.
; ----------------------------------------------------------------------
	ld	c,a		;1c23 - the current reserved word list character
	ld	a,b		;1c24 - reserved words counter
; ----------------------------------------------------------------------
; The GOTO reserved word is the only one which allows for spaces to be inside it,
; so . if we find that we have GO so far, we will call the RST 10H to strip out
; any intevening spaces before continuing.
; ----------------------------------------------------------------------
	cp	TKGOTO		;1c25 - compare - reserved word is GOTO
	jr	nz,NTGOTO	;1c27 - skip if NOT a GOTO
	GETCHR			;1c29 - rst 10h
	dec	hl		;1c2a - DEC input buffer pointer to offset next instruction
NTGOTO:	inc	hl		;1c2b - Bump input buffer pointer to the next character
	ld	a,(hl)		;1c2c - next character in input buffer
	cp	'a'		;1c2d - Check to see if the character is lower-case
	jr	c,NOTLW1	;1c2f - jump forward if uppercase
	and	$5F		;1c31 - Make character uppercase
NOTLW1:	cp	c		;1c33 - compare with next char from reserved word list
	jr	z,LOPPSI	;1c34 - If a match, loop back, keep checking reserved word
; ----------------------------------------------------------------------
; If we are here, then the matching process failed
; ----------------------------------------------------------------------
	pop	hl		;1c36 - get back original input buffer pointer
	jr	TRYAGA		;1c37 - move on to the next reserved word
FOUND:	ld	c,b		;1c39 - value of the reserved words counter
	pop	af		;1c3a -
	ex	de,hl		;1c3b
	ret			;1c3c
; ----------------------------------------------------------------------
; 1C3D – Part of the tokeninzing routine – “NOTRES”
; ----------------------------------------------------------------------
NOTRES:	ex	de,hl		;1c3d
	ld	a,c		;1c3e
	pop	bc		;1c3f
	pop	de		;1c40
	ex	de,hl		;1c41
	cp	TKELSE		;1c42
	ld	(hl),':'	;1c44
	jr	nz,CKSNGO	;1c46
	inc	c		;1c48
	inc	hl		;1c49
CKSNGO:	cp	$FB		;1c4a
	jr	nz,NTSNGT	;1c4c
	ld	(hl),':'	;1c4e
	inc	hl		;1c50
	ld	b,TKREM		;1c51
	ld	(hl),b		;1c53
	inc	hl		;1c54
	ex	de,hl		;1c55
	inc	c		;1c56
	inc	c		;1c57
	jr	STRNG		;1c58
; ----------------------------------------------------------------------
; 1C5A – Part of the tokeninzing routine – “NTSNGT” and “STUFFH”
; ----------------------------------------------------------------------
NTSNGT:	ex	de,hl		;1c5a
STUFFH:	inc	hl		;1c5b
	ld	(de),a		;1c5c
	inc	de		;1c5d
	inc	c		;1c5e
	sub	':'		;1c5f ;  is a : to flag a multi-statement line
	jr	z,COLIS		;1c61
	cp	$4E		;1c63
	jr	nz,NODATT	;1c65
COLIS:	ld	(DORES),a	;1c67
NODATT:	sub	$59		;1c6a
	jp	nz,KLOOP	;1c6c
	ld	b,a		;1c6f
STR1:	ld	a,(hl)		;1c70
	or	a		;1c71
	jr	z,CRDONE	;1c72
	cp	b		;1c74
	jr	z,STUFFH	;1c75
STRNG:	inc	hl		;1c77
	ld	(de),a		;1c78
	inc	c		;1c79
	inc	de		;1c7a
	jr	STR1		;1c7b
; ----------------------------------------------------------------------
;  1C7D – Part of the tokeninzing routine – Jumped here when an EOL is found
; ----------------------------------------------------------------------
CRDONE:	ld	hl,$0005	;1c7d - add 5 bytes to the tokenized character count
	ld	b,h		;1c80
	add	hl,bc		;1c81
	ld	b,h		;1c82
	ld	c,l		;1c83
	ld	hl,(BUFPNT)	;1c84
	dec	hl		;1c87
	dec	hl		;1c88
	dec	hl		;1c89
	ld	(de),a		;1c8a
	inc	de		;1c8b
	ld	(de),a		;1c8c
	inc	de		;1c8d
	ld	(de),a		;1c8e
	ret			;1c8f
;
; ======================================================================
; 1C90-1C95 – RST 0018H CODE – “DCOMPR”
;
;   The RST 18H code is located here. Unsigned compare (HL-DE), which
;   numerically compares DE and HL. Will not work for signed integers
;   (except positive ones). Uses the A-register only. The result of the
;   comparison is returned in the status Register as:
;   CARRY SET=HL<DE; NO CARRY=HL>DE; NZ=Unequal; Z=Equal).
; ----------------------------------------------------------------------
DCOMPR:	ld	a,h		;1c90
	sub	d		;1c91
	ret	nz		;1c92
	ld	a,l		;1c93
	sub	e		;1c94
	ret			;1c95
;
; ======================================================================
; 1C96-1CA0 – RST 08H CODE – “SYNCHR”
;
;   The RST 8H code is located here. This is the COMPARE SYMBOL routine
;   which compares the symbol in the input string pointed to by HL Register
;   to the value in the location following the RST 08 call. If there is a
;   match, control is returned to address of the RST 08 instruction 2 with
;   the next symbol in in Register A and HL incremented by one. If the two
;   characters do not match, a syntax error message is given and control
;   returns to the Input Phase).
; ----------------------------------------------------------------------
SYNCHR:	ld	a,(hl)		;1c96
	ex	(sp),hl		;1c97
	cp	(hl)		;1c98
	inc	hl		;1c99
	ex	(sp),hl		;1c9a
	jp	z,CHRGTR	;1c9b
	jp	SNERR		;1c9e
;
; ----------------------------------------------------------------------
; 1CA1-1D1D – Level II BASIC FOR ROUTINE – “FOR”
;
; The Stack contains the following (ascending Stack order)
;   1 Byte  - The FOR token ( constant = $81 )
;   2 Bytes - A pointer to the loop's variable
;   1 Byte  - A byte reflecting the sign of the increment
;   4 Bytes - SINGLE value of the STEP
;   4 Bytes - SINGLE upper limit TO of the loop
;   2 Bytes - The line number of the FOR statement
;   2 Bytes - A BASIC program pointer into the FOR statement
;
; For an Integer the Stack may look something more like this
;   1 Byte  - The FOR token ( constant = $81 )
;   2 Bytes - A pointer to the loop's variable
;   1 Byte  - A byte reflecting the sign of the increment
;   4 Bytes - INTEGER UNUSED PADDING
;   2 Bytes - INTEGER value of the STEP
;   2 Bytes - INTEGER upper limit TO of the loop
;   2 Bytes - The line number of the FOR statement
;   2 Bytes - A BASIC program pointer into the FOR statement
;
; ----------------------------------------------------------------------
FOR:	ld	a,$64		;1ca1 - the value for the FOR flag
	ld	(SUBFLG),a	;1ca3 - Save the FOR flag. 40DCH
	call	LET		;1ca6 - read the FOR variable, read initial value, store in (TEMP)
	ex	(sp),hl		;1ca9 - Exchange the current BASIC program pointer to the STACK
	call	FNDFOR		;1caa - see if there is a FOR statement to the STACK using variable name
	pop	de		;1cad - get BASIC program pointer (should be the TO token)
	jr	nz,NOTOL	;1cae - An existing FOR is not found skip next 3 instructions
	add	hl,bc		;1cb0
	ld	sp,hl		;1cb1
	ld	(SAVSTK),hl	;1cb2
NOTOL:	ex	de,hl		;1cb5 - HL -> BASIC program pointer; DE -> STACK pointer address
	ld	c, 16/2		;1cb6 - 16 bytes are needed for a FOR entry
	call	GETSTK		;1cb8 - check to see if 16 bytes are available
; ----------------------------------------------------------------------
	push	hl		;1cbb - temp save HL, restored in EX instruction
	call	DATA		;1cbc - Scanning the BASIC program until (HL) END OF LINE terminator
	ex	(sp),hl		;1cbf - (SAVE) Saving basic program pointer
	push	hl		;1cc0
	ld	hl,(CURLIN)	;1cc1 - Get Basic Line number
	ex	(sp),hl		;1cc4 - (SAVE) BASIC line number
	SYNTAX	(TKTO)		;1cc5 - rst 08h Look for TO Token
	GETYPE			;1cc7 - RST 20 - check the current number type
	jp	z,TMERR		;1cc8 - EXIT if String Type
	jp	nc,TMERR	;1ccb - EXIT if Double Type
	push	af		;1cce
	call	FRMEVL		;1ccf - Evaluate the expression following TO
	pop	af		;1cd2
	push	hl		;1cd3 - temp save the BASIC program pointer TO
	jp	p,SNGFOR	;1cd4 - jump forward if a Single Loop
; ----------------------------------------------------------------------
; Part of the FOR routine – Setup for an Integer Loop
; ----------------------------------------------------------------------
	call	FRCINT		;1cd7 - Convert to Integer in HL
	ex	(sp),hl		;1cda - (SAVE) the TO Integer into the stack.
	ld	de,1		;1cdb - Default Step Value = 1
	ld	a,(hl)		;1cde - next char from the BASIC program line
	cp	TKSTEP		;1cdf - Check for a STEP token
	call	z,GETINT	;1ce1 - if step then get step value as an Integer
	push	de		;1ce4 - (SAVE) the Step Amount
	push	hl		;1ce5 - temp save the BASIC program pointer
	ex	de,hl		;1ce6 - HL -> Step val; DE -> program pointer
	call	ISIGN		;1ce7 - get the sign of the STEP value in HL
	jr	STPSGN		;1cea
; ----------------------------------------------------------------------
; Part of the FOR routine – Setup for a Single Loop
; ----------------------------------------------------------------------
SNGFOR:	call	FRCSNG		;1cec
	call	MOVRF		;1cef
	pop	hl		;1cf2
	push	bc		;1cf3 - (SAVE) the TO Single into the stack.
	push	de		;1cf4 - (SAVE) Single has 4 bytes
	ld	bc,$8100	;1cf5 - Single precision constant for 1
	ld	d,c		;1cf8 - loaded into BC and DE
	ld	e,d		;1cf9
	ld	a,(hl)		;1cfa - next char from the BASIC program line
	cp	TKSTEP		;1cfb - Check for a STEP token
	ld	a,1		;1cfd - Default Step Value = 1
	jr	nz,ONEON	;1cff - Skip forward if we dont have STEP token
	call	FRMCHK		;1d01 - Evaluate the step expression
	push	hl		;1d04 - save BASIC program pointer
	call	FRCSNG		;1d05 - convert to single
	call	MOVRF		;1d08 - load the single precision into BC DE
	call	SIGN		;1d0b - Get the Sign of value into A
; ----------------------------------------------------------------------
; Part of the FOR routine – Common Setup
; ----------------------------------------------------------------------
STPSGN:	pop	hl		;1d0e - the BASIC program pointer
ONEON:	push	bc		;1d0f - (SAVE) The Single Precision STEP Value
	push	de		;1d10 - (SAVE) OR Integer Padding
	ld	c,a		;1d11 - sign value for the STEP value
	GETYPE			;1d12 - RST 20 - check the current number type
	ld	b,a		;1d13 - type-adjusted and sign of the number type flag
	push	bc		;1d14 - (SAVE)
	push	hl		;1d15 - temp save the BASIC program pointer
	ld	hl,(TEMP)	;1d16 - Pointer to loop variable in call to LET
	ex	(sp),hl		;1d19 - (SAVE) Pointer to the Loops Variable
; ----------------------------------------------------------------------
; Jumped here at completion of FOR NEXT Loop
; ----------------------------------------------------------------------
NXTCON:	ld	b,TKFOR		;1d1a - The BASIC FOR token
	push	bc		;1d1c - (SAVE) The For Token in B register
	inc	sp		;1d1d - Reverting the Store of C in above push
	; Fall through
;
; ----------------------------------------------------------------------
; 1D1E-1D77 – LEVEL II BASIC INTERPRETER – “NEWSTT”
;   this is where we go for a new statement. The character on the BASIC
;   program line pointed to by Register Pair HL should be either a “:”
;   or an END OF LINE. The address of this routine is left on the STACK so
;   that when a statement is executed and done, the RETurn comes back here.
; ----------------------------------------------------------------------
NEWSTT:	call	ISCHAR		;1d1e
	or	a		;1d21
	call	nz,CNTCCN	;1d22
	ld	(SAVTXT),hl	;1d25
	ld	(SAVSTK),sp	;1d28
	ld	a,(hl)		;1d2c
	cp	':'		;1d2d
	jr	z,GONE1		;1d2f
	or	a		;1d31
	jp	nz,SNERR	;1d32
	inc	hl		;1d35
GONE4:	ld	a,(hl)		;1d36
	inc	hl		;1d37
	or	(hl)		;1d38
	jp	z,PRGEND	;1d39
	inc	hl		;1d3c
	ld	e,(hl)		;1d3d
	inc	hl		;1d3e
	ld	d,(hl)		;1d3f
	ex	de,hl		;1d40
	ld	(CURLIN),hl	;1d41
	ld	a,(TRCFLG)	;1d44
	or	a		;1d47
	jr	z,NOTTRC	;1d48
	push	de		;1d4a
	ld	a,'<'		;1d4b
	call	OUTDO		;1d4d
	call	LINPRT		;1d50
	ld	a,'>'		;1d53
	call	OUTDO		;1d55
	pop	de		;1d58
NOTTRC:	ex	de,hl		;1d59
; ----------------------------------------------------------------------
; Jumped here if user entered a DIRECT Statement
; ----------------------------------------------------------------------
GONE1:	GETCHR			;1d5a - rst 10h
	ld	de,NEWSTT	;1d5b
	push	de		;1d5e
GONE3:	ret	z		;1d5f - Return If an END OF LINE delimiter
GONE2:	sub	TKOFF		;1d60 - Check for a token >= 80H
	jp	c,LET		;1d62 - NOT a Token, so must be a LET. JUMP
	cp	TKTAB-TKOFF	;1d65 - if the token is below the TAB( token
	jp	nc,ISMID	;1d67 - If the token >= TAB token
	rlca			;1d6a - Multiply the token value in Register A by two
	ld	c,a		;1d6b
	ld	b,$00		;1d6c - address offset into BC
	ex	de,hl		;1d6e - save the BASIC program pointer DE into HL
	ld	hl,STMDSP	;1d6f - Statement Dispatch Table- list of Addresses
	add	hl,bc		;1d72 - add the offset
	ld	c,(hl)		;1d73 - get low order byte
	inc	hl		;1d74
	ld	b,(hl)		;1d75 - het high order byte
	push	bc		;1d76 - Save execution address in BC to the STACK
	ex	de,hl		;1d77 - restore the BASIC program pointer into DE
;
; ======================================================================
; 1D78-1D90 – RST 10H CODE – “CHRGTR”
;
;   The RST 10H code is located here. This is the EXAMINE NEXT SYMBOL
;   routine which loads the next character from the string pointed to by
;   the HL Register set into the A-register and clears the CARRY flag if
;   it is alphabetic, or sets it if is alphanumeric. Blanks and control
;   codes 09 and OB are ignored causing the following character to be
;   loaded and tested. The HL Register will be incremented before loading
;   any character therefore on the first call the HL Register should contain
;   the string address minus one. The string must be terminated by a byte
;   of zeros).
; ----------------------------------------------------------------------
CHRGTR:	inc	hl		;1d78 - Bump the BASIC program pointer to next char
	ld	a,(hl)		;1d79
	cp	':'		;1d7a - is greater than or equal to a :
	ret	nc		;1d7c - Return if char >= to a : meaning :, ;, < . Y, Z
	cp	SPACE		;1d7d - is a SPACE
	jp	z,CHRGTR	;1d7f - loop if a space
	cp	VERTAB		;1d82 - is >= 0BH (not a control code)
	jr	nc,NOTLFT	;1d84 - JP if greater than or equal to 0BH
	cp	TAB		;1d86 - is >= 09H (meaning a line feed or tab)
	jp	nc,CHRGTR	;1d88 - Loop if the char is >= to 09H
NOTLFT:	cp	'0'		;1d8b - is >= a zero character
	ccf			;1d8d - Set the carry flag if is numeric (i.e., greater than or equal to 30H)
	inc	a		;1d8e
	dec	a		;1d8f
	ret			;1d90
;
; ----------------------------------------------------------------------
; 1D91-1D9A – LEVEL II BASIC RESTORE ROUTINE – “RESTORE”
; ----------------------------------------------------------------------
RESTORE: ex	de,hl		;1d91
	ld	hl,(TXTTAB)	;1d92
	dec	hl		;1d95
RESFIN:	ld	(DATPTR),hl	;1d96
	ex	de,hl		;1d99
	ret			;1d9a
;
; ----------------------------------------------------------------------
; 1D9B-1DAD – SCAN KEYBOARD ROUTINE – “ISCNTC”
; ----------------------------------------------------------------------
ISCNTN:	call	ISCHAR		;1d9b
	or	a		;1d9e
	ret	z		;1d9f
CNTCCN:	cp	BQUOTE		;1da0 - Is key pressed a SHIFT + @.
	call	z,INCHR		;1da2
	ld	(CHARC),a	;1da5
	dec	a		;1da8
;
; ----------------------------------------------------------------------
; 1DA9-1DAD – LEVEL II BASIC STOP ROUTINE – “STOP”
; ----------------------------------------------------------------------
STOP:	ret	nz		;1da9
	inc	a		;1daa
	jp	CONSTP		;1dab
;
; ----------------------------------------------------------------------
; 1DAE-1DE3 – LEVEL II BASIC END ROUTINE – “END”
; ----------------------------------------------------------------------
END:	ret	nz		;1dae
	push	af		;1daf
	call	z,CLSALL	;1db0
	pop	af		;1db3
CONSTP:	ld	(SAVTXT),hl	;1db4
	ld	hl,TEMPST	;1db7
	ld	(TEMPPT),hl	;1dba
;
	DEFB	LDHLNN		;1dbd Z-80 Trick - LD HL,nnnn - next 2 instructions skipped
;
STPEND:	or	$FF		;1dbe A is NZ so as to force the printing of the BREAK message
	pop	bc		;1dc0
;
ENDCON:	ld	hl,(CURLIN)	;1dc1
	push	hl		;1dc4
	push	af		;1dc5
	ld	a,l		;1dc6
	and	h		;1dc7
	inc	a		;1dc8
	jr	z,DIRIS		;1dc9
	ld	(OLDLIN),hl	;1dcb
	ld	hl,(SAVTXT)	;1dce
	ld	(OLDTXT),hl	;1dd1
DIRIS:	call	FINLPT		;1dd4 - set the current output device to video
	call	CRDONZ		;1dd7
	pop	af		;1dda
	ld	hl,BNKTXT	;1ddb
	jp	nz,ERRFIN	;1dde
	jp	STPRDY		;1de1
;
; ----------------------------------------------------------------------
; 1DE4-1DF6 – LEVEL II BASIC CONT ROUTINE – “CONT”
; ----------------------------------------------------------------------
CONT:	ld	hl,(OLDTXT)	;1de4
	ld	a,h		;1de7
	or	l		;1de8
	ld	e,ERRCN		;1de9
	jp	z,ERROR		;1deb
	ex	de,hl		;1dee
	ld	hl,(OLDLIN)	;1def
	ld	(CURLIN),hl	;1df2
	ex	de,hl		;1df5
	ret			;1df6
;
; ----------------------------------------------------------------------
; 1DF7-1DF8 - TRON ENTRY POINT - "TRON"
; ----------------------------------------------------------------------
TRON:	DEFB	LDANN		;1df7 - Z80 Trick LD A,nn where nn is the next XOR instruction byte
; which is nn zero, thus we store a non-ZERO, ON state
;
; ----------------------------------------------------------------------
; 1DF8 - TROFF ENTRY POINT - "TROFF"
; ----------------------------------------------------------------------
TROFF:	xor	a		;1df8
	ld	(TRCFLG),a	;1df9
	ret			;1dfc
;
; ----------------------------------------------------------------------
; 1DFD-1DFF - DISK ROUTINE NOT USED BY LEVEL II BASIC - "POPAHT".
; ----------------------------------------------------------------------
POPAHT:	pop	af		;1dfd
	pop	hl		;1dfe
	ret			;1dff
;
; ----------------------------------------------------------------------
; 1E00-1E02 - DEFSTR ENTRY POINT - "DEFSTR"
; ----------------------------------------------------------------------
DEFSTR:	ld	e,VTSTR		;1e00
	DEFB	LDBCNN		;1e02 - Z80 Trick (LD BC,nnnn) skip next 2 byte instruction
;
; ----------------------------------------------------------------------
; 1E03-1E05 - DEFINT ENTRY POINT - "DEFINT"
; ----------------------------------------------------------------------
DEFINT:	ld	e,VTINT		;1e03
	DEFB	LDBCNN		;1e05 - Z80 Trick (LD BC,nnnn) skip next 2 byte instruction
;
; ----------------------------------------------------------------------
; 1E06-1E08 - DEFSNG ENTRY POINT - "DEFREA" (DEFSNG)
; ----------------------------------------------------------------------
DEFREA:	ld	e,VTSNG		;1e06
	DEFB	LDBCNN		;1e08 - Z80 Trick (LD BC,nnnn) skip next 2 byte instruction
;
; ----------------------------------------------------------------------
; 1E09-1E0A - DEFDBL ENTRY POINT - "DEFDBL"
; ----------------------------------------------------------------------
DEFDBL:	ld	e,VTDBL		;1e09
;
; ----------------------------------------------------------------------
; 1E0B-1E3C - COMMON CODE SHARED BY DEFSTR/DEFINT/DEFSNG/DEFDBL - "DEFCON".
;   All of those can either have a - for a range of values or be separated
;   by ,. This code needs to figure out the variables that followed the
;   DEF??? instruction and then set the variable type (which is currently
;   sitting in Register E) in the variable table
; ----------------------------------------------------------------------
DEFCON:	call	ISLET		;1e0b
	ld	bc,SNERR	;1e0e
	push	bc		;1e11
	ret	c		;1e12
	sub	$41		;1e13
	ld	c,a		;1e15
	ld	b,a		;1e16
	GETCHR			;1e17 - rst 10h
	cp	TKMNUS		;1e18 - a "-" TOKEN
	jr	nz,NOTRNG	;1e1a
	GETCHR			;1e1c - rst 10h
	call	ISLET		;1e1d
	ret	c		;1e20
	sub	$41		;1e21
	ld	b,a		;1e23
	GETCHR			;1e24 - rst 10h
NOTRNG:	ld	a,b		;1e25
	sub	c		;1e26
	ret	c		;1e27
	inc	a		;1e28
	ex	(sp),hl		;1e29
	ld	hl,DEFTBL	;1e2a
	ld	b,$00		;1e2d
	add	hl,bc		;1e2f
LPDCHG:	ld	(hl),e		;1e30
	inc	hl		;1e31
	dec	a		;1e32
	jr	nz,LPDCHG	;1e33
	pop	hl		;1e35
	ld	a,(hl)		;1e36
	cp	','		;1e37
	ret	nz		;1e39
	GETCHR			;1e3a - rst 10h
	jr	DEFCON		;1e3b
; ----------------------------------------------------------------------
; 1E3D-1E44 - EXAMINE VARIABLE - "ISLET"
;   This routine tests the value pointed to by the HL Register Pair and
;   sets the C FLAG if it is an ASCII letter value; and otherwise the
;   NC FLAG is set.
; ----------------------------------------------------------------------
ISLET:	ld	a,(hl)		;1e3d
	cp	$41		;1e3e
	ret	c		;1e40
	cp	'Z'+1		;1e41 - is greater than a "Z"
	ccf			;1e43 - Complement the value of the Carry flag
	ret			;1e44
;
; ----------------------------------------------------------------------
; 1E45-1E4E - EXAMINE VARIABLE - "INTIDX"
;   this routine reads a formula from the current position and turns it
;   into a positive integer, with the result put into Register Pair DE.
;   Negative arguments are not allowed. On exit, Register Pair HL wil
;   point to the terminating character of the formula on the BASIC
;   program line being examined
; ----------------------------------------------------------------------
INTIDX:	GETCHR			;1e45 - rst 10h
INTID2:	call	GETIN2		;1e46
	ret	p		;1e49
;
; ----------------------------------------------------------------------
; 1E4AH - ?FC ERROR ENTRY POINT - "FCERR"
; ----------------------------------------------------------------------
FCERR:	ld	e,ERRFC		;1e4a
	jp	ERROR		;1e4c
;
; ----------------------------------------------------------------------
; 1E4F-1E79 - Line Number Conversion Routine 1 - "LINSPC"
;   LINSPC and LINGET are identical except that LINSPC also permits the
;   use of a '.' to act as the current line number. Otherwise, They read
;   the line number from the current position in the BASIC program.
;   Possible line numbers are 00000-65529. On exit, DE holds the line
;   number, and HL is updated to point to the terminating character,
;   and Register A will contain the terminating character with the
;   FLAGs set based on Register A's value.
; ----------------------------------------------------------------------
LINSPC:	ld	a,(hl)		;1e4f
	cp	$2E		;1e50
	ex	de,hl		;1e52
	ld	hl,(DOT)	;1e53
	ex	de,hl		;1e56
	jp	z,CHRGTR	;1e57
;
; ======================================================================
; 1E5A - ASCII To Integer - "LINGET"
;   Converts numeric ASCII string pointed to by the HL Register Pair,
;   and places the result in the DE Register Pair
;   Conversion will cease when the first non-numeric character
;   is found. A value of zero is returned if no numeric value is found
;   Maximum allowable value is 65529
; ----------------------------------------------------------------------
LINGET:	dec	hl		;1e5a
LINGT2:	ld	de,$0000	;1e5b
MORLIN:	GETCHR			;1e5e - rst 10h
	ret	nc		;1e5f
	push	hl		;1e60
	push	af		;1e61
	ld	hl,6552		;1e62
	CPDEHL			;1e65
	jp	c,SNERR		;1e66
	ld	h,d		;1e69
	ld	l,e		;1e6a
	add	hl,de		;1e6b
	add	hl,hl		;1e6c
	add	hl,de		;1e6d
	add	hl,hl		;1e6e
	pop	af		;1e6f
	sub	'0'		;1e70 - Convert the ASCII digit to binary
	ld	e,a		;1e72
	ld	d,$00		;1e73 - DE will be binary 0000 through 0009
	add	hl,de		;1e75
	ex	de,hl		;1e76
	pop	hl		;1e77
	jr	MORLIN		;1e78
;
; ----------------------------------------------------------------------
; 1E7A-1EA0 - LEVEL II BASIC CLEAR ROUTINE - "CLEAR"
;   this will change the amount
;   of string space allowed. If no formula is given, the amount of string
;   space will remain unchanged. On entry, if the Z flag is set,
;   there was no parameter present
; ----------------------------------------------------------------------
CLEAR:	jp	z,CLEARC	;1e7a
	call	INTID2		;1e7d
	dec	hl		;1e80
	GETCHR			;1e81 - rst 10h
	ret	nz		;1e82
	push	hl		;1e83
	ld	hl,(MEMSIZ)	;1e84
	ld	a,l		;1e87
	sub	e		;1e88
	ld	e,a		;1e89
	ld	a,h		;1e8a
	sbc	a,d		;1e8b
	ld	d,a		;1e8c
	jp	c,OMERR		;1e8d
	ld	hl,(VARTAB)	;1e90
	ld	bc,$0028	;1e93 least amount of space needed for BASIC program variables
	add	hl,bc		;1e96
	CPDEHL			;1e97
	jp	nc,OMERR	;1e98
	ex	de,hl		;1e9b
	ld	(STKTOP),hl	;1e9c
	pop	hl		;1e9f
	jp	CLEARC		;1ea0
;
; ----------------------------------------------------------------------
; 1EA3-1EB0 - LEVEL II BASIC RUN ROUTINE - "RUN"
;   This is the MAIN entry Point
;   On entry, if the Z flag is set, there was no parameter present
; ----------------------------------------------------------------------
RUN:	jp	z,RUNC		;1ea3 - Jump if there isn't a line number specified after the RUN
	call	LRUN		;1ea6 - see if DOS wants to do anything?
	call	CLEARC		;1ea9 - initialize RUN time variables
	ld	bc,NEWSTT	;1eac - BC with the continuation address in the execution driver, RETurn to NEWSTT
	jr	RUNC2		;1eaf - Use GOTO code to begin execution at specified line
;
; ----------------------------------------------------------------------
; 1EB1-1EC1 - LEVEL II BASIC GOSUB ROUTINE - "GOSUB"
; ----------------------------------------------------------------------
GOSUB:	ld	c,$03		;1eb1
	call	GETSTK		;1eb3
	pop	bc		;1eb6
	push	hl		;1eb7
	push	hl		;1eb8
	ld	hl,(CURLIN)	;1eb9
	ex	(sp),hl		;1ebc
	ld	a,TKGOSU	;1ebd - Load A with a GOSUB token
	push	af		;1ebf
	inc	sp		;1ec0
RUNC2:	push	bc		;1ec1
;
; ----------------------------------------------------------------------
; 1EC2-1EDD - LEVEL II BASIC GOTO ROUTINE - "GOTO"
; ----------------------------------------------------------------------
GOTO:	call	LINGET		;1ec2
GOTO2:	call	REM		;1ec5
	push	hl		;1ec8
	ld	hl,(CURLIN)	;1ec9
	CPDEHL			;1ecc
	pop	hl		;1ecd
	inc	hl		;1ece
	call	c,FNLOOP	;1ecf
	call	nc,FNDLIN	;1ed2
	ld	h,b		;1ed5
	ld	l,c		;1ed6
	dec	hl		;1ed7
	ret	c		;1ed8
; ----------------------------------------------------------------------
; 1ED9H - ?UL ERROR ENTRY POINT - "USERR"
; ----------------------------------------------------------------------
USERR:	ld	e,ERRUL		;1ed9
	jp	ERROR		;1edb
;
; ----------------------------------------------------------------------
; 1EDE-1E04 - LEVEL II BASIC RETURN ROUTINE - "RETURN"
;   Returns control to the BASIC statement following the last GOSUB call
; ----------------------------------------------------------------------
RETURN:	ret	nz		;1ede
	ld	d,$FF		;1edf
	call	FNDFOR		;1ee1
	ld	sp,hl		;1ee4
	ld	(SAVSTK),hl	;1ee5
	cp	TKGOSU		;1ee8 - Check if is a GOSUB token
	ld	e,ERRRG		;1eea
	jp	nz,ERROR	;1eec
	pop	hl		;1eef
	ld	(CURLIN),hl	;1ef0
	inc	hl		;1ef3
	ld	a,h		;1ef4
	or	l		;1ef5
	jr	nz,GOBACK	;1ef6
	ld	a,(BFKLFL)	;1ef8
	or	a		;1efb
	jp	nz,STPRDY	;1efc
GOBACK:	ld	hl,NEWSTT	;1eff
	ex	(sp),hl		;1f02
;
	DEFB	LDANN		;1f03 - Z80 Trick LD A,nn - skp next instruction - load it into A
;
DATAH:	pop	hl		;1f04
;
; ----------------------------------------------------------------------
; 1F05-1F20 - SCAN ROUTINE - "DATA"
; ----------------------------------------------------------------------
DATA:	DEFB	LDBCNN, $3A	;1f05 - Z80 Trick - LD BC,$nn3A - skip the next 1 byte - Then a NOP
REM:	ld	c,$00		;1f07 - z80 Trick - noting second byte here is 0 which is a NOP
	ld	b,$00		;1f09
EXCHQT:	ld	a,c		;1f0b
	ld	c,b		;1f0c
	ld	b,a		;1f0d
REMER:	ld	a,(hl)		;1f0e
	or	a		;1f0f
	ret	z		;1f10
	cp	b		;1f11
	ret	z		;1f12
	inc	hl		;1f13
	cp	DQUOTE		;1f14 - Check to see if is a quote "
	jr	z,EXCHQT	;1f16
	sub	TKIF		;1f18 - Check to see if is a IF token
	jr	nz,REMER	;1f1a
	cp	b		;1f1c
	adc	a,d		;1f1d
	ld	d,a		;1f1e
	jr	REMER		;1f1f
;
; ----------------------------------------------------------------------
; 1F21-1F6B - LEVEL II BASIC LET ROUTINE - "LET"
; ----------------------------------------------------------------------
LET:	call	PTRGET		;1f21
	SYNTAX	(TKEQL)		;1f24 - rst 08h Test if the variable name is followed by a = token
	ex	de,hl		;1f26
	ld	(TEMP),hl	;1f27
	ex	de,hl		;1f2a
	push	de		;1f2b
	GETYPE			;1f2c - RST 20 - check the current number type
	push	af		;1f2d
	call	FRMEVL		;1f2e
	pop	af		;1f31
	ex	(sp),hl		;1f32
INPCOM:	add	a,$03		;1f33
	call	DOCNVF		;1f35
	call	VDFACS		;1f38
	push	hl		;1f3b
	jr	nz,COPNUM	;1f3c
	ld	hl,(FACLO)	;1f3e
	push	hl		;1f41
	inc	hl		;1f42
	ld	e,(hl)		;1f43
	inc	hl		;1f44
	ld	d,(hl)		;1f45
	ld	hl,(TXTTAB)	;1f46
	CPDEHL			;1f49
	jr	nc,INBUFC	;1f4a
	ld	hl,(STKTOP)	;1f4c
	CPDEHL			;1f4f
	pop	de		;1f50
	jr	nc,DNTCPY	;1f51
	ld	hl,(VARTAB)	;1f53
	CPDEHL			;1f56
	jr	nc,DNTCPY	;1f57
;
	DEFB	LDANN		;1f58 Z80 Trick - LD A,nn - skip next instruction
;
INBUFC:	pop	de		;1f5a
	call	FRETMS		;1f5b
	ex	de,hl		;1f5e
	call	STRCPY		;1f5f
DNTCPY:	call	FRETMS		;1f62
	ex	(sp),hl		;1f65
COPNUM:	call	VMOVE		;1f66
	pop	de		;1f69
	pop	hl		;1f6a
	ret			;1f6b
;
; ----------------------------------------------------------------------
; 1F6C-1FAE - LEVEL II BASIC ERROR ON ROUTINE - "ONGOTO"
; ----------------------------------------------------------------------
ONGOTO:	cp	TKERRO		;1f6c - is an ERROR token (meant to be ON ERROR)
	jr	nz,NTOERR	;1f6e - Not ON ERROR check for other ON statements
	GETCHR			;1f70 - rst 10h
	SYNTAX	(TKGOTO)	;1f71 - rst 08h
	call	LINGET		;1f73
	ld	a,d		;1f76
	or	e		;1f77
	jr	z,RESTRP	;1f78
	call	FNDLN1		;1f7a
	ld	d,b		;1f7d
	ld	e,c		;1f7e
	pop	hl		;1f7f
	jp	nc,USERR	;1f80
RESTRP:	ex	de,hl		;1f83
	ld	(ONELIN),hl	;1f84
	ex	de,hl		;1f87
	ret	c		;1f88
	ld	a,(ONEFLG)	;1f89
	or	a		;1f8c
	ret	z		;1f8d
	ld	a,(ERRFLG)	;1f8e
	ld	e,a		;1f91
	jp	ERRESM		;1f92
; ----------------------------------------------------------------------
; We know it isn't ON ERROR. We now need to deal with the possibility
; that it was an ON n GOTO or ON n GOSUB
; ----------------------------------------------------------------------
NTOERR:	call	GETBYT		;1f95
	ld	a,(hl)		;1f98
	ld	b,a		;1f99
	cp	TKGOSU		;1f9a - IS Register A a GOSUB token
	jr	z,ISGOSU	;1f9c - Skip the next 2 opcodes since a GOSUB
	SYNTAX	(TKGOTO)	;1f9e - rst 08h
	dec	hl		;1fa0
ISGOSU:	ld	c,e		;1fa1
LOOPON:	dec	c		;1fa2
	ld	a,b		;1fa3
	jp	z,GONE2		;1fa4
	call	LINGT2		;1fa7
	cp	','		;1faa
	ret	nz		;1fac
	jr	LOOPON		;1fad
; ----------------------------------------------------------------------
; 1FAF-1FF3 - LEVEL II BASIC RESUME ROUTINE - "RESUME"
; ----------------------------------------------------------------------
RESUME:	ld	de,ONEFLG	;1faf
	ld	a,(de)		;1fb2
	or	a		;1fb3
	jp	z,REERR		;1fb4
	inc	a		;1fb7
	ld	(ERRFLG),a	;1fb8
	ld	(de),a		;1fbb
	ld	a,(hl)		;1fbc
	cp	TKNEXT		;1fbd - Check to see if it is a NEXT token
	jr	z,RESNXT	;1fbf
	call	LINGET		;1fc1
	ret	nz		;1fc4
	ld	a,d		;1fc5
	or	e		;1fc6
	jp	nz,GOTO2	;1fc7
	inc	a		;1fca
	jr	RESTXT		;1fcb
;
; ----------------------------------------------------------------------
; 1FCDH - Part of the RESUME routine - "RESNXT"
; ----------------------------------------------------------------------
RESNXT:	GETCHR			;1fcd - rst 10h
	ret	nz		;1fce
; ----------------------------------------------------------------------
; 1FCF - This is the RESUME 0 routine - "RESTXT"
; ----------------------------------------------------------------------
RESTXT:	ld	hl,(ERRTXT)	;1fcf
	ex	de,hl		;1fd2
	ld	hl,(ERRLIN)	;1fd3
	ld	(CURLIN),hl	;1fd6
	ex	de,hl		;1fd9
	ret	nz		;1fda
	ld	a,(hl)		;1fdb
	or	a		;1fdc
	jr	nz,NOTBGL	;1fdd
	inc	hl		;1fdf
	inc	hl		;1fe0
	inc	hl		;1fe1
	inc	hl		;1fe2
NOTBGL:	inc	hl		;1fe3
	ld	a,d		;1fe4
	and	e		;1fe5
	inc	a		;1fe6
	jp	nz,DATA		;1fe7
	ld	a,(BFKLFL)	;1fea
	dec	a		;1fed
	jp	z,STPEND	;1fee
	jp	DATA		;1ff1
; ----------------------------------------------------------------------
; 1FF4H-2007 - LEVEL II BASIC ERROR ROUTINE - "ERRORS"
;   This evaluates n for ERROR n
; ----------------------------------------------------------------------
ERRORS:	call	GETBYT		;1ff4
	ret	nz		;1ff7
	or	a		;1ff8
	jp	z,FCERR		;1ff9
	dec	a		;1ffc
	add	a,a		;1ffd
	ld	e,a		;1ffe
	cp	$2D		;1fff
	jr	c,GOERR		;2001
; ----------------------------------------------------------------------
; 2003H - ?UE ERROR ENTRY POINT - "UEERR"
; ----------------------------------------------------------------------
UEERR:	ld	e,ERRUE		;2003
GOERR:	jp	ERROR		;2005
;
; ----------------------------------------------------------------------
; 2008-2038 – LEVEL II BASIC AUTO ROUTINE – “AUTO”
;   the AUTO [begin,[inc]]
;   command is used to generate line number for lines to be inserted.
; ----------------------------------------------------------------------
AUTO:	ld	de,000AH	;2008
	push	de		;200b
	jr	z,SNGAUT	;200c
	call	LINSPC		;200e
	ex	de,hl		;2011
	ex	(sp),hl		;2012
; At this point, DE points to the current character in the BASIC line
; being processed, “10” is in HL, and the initial number is on the STACK.
	jr	z,SNGAU1	;2013
	ex	de,hl		;2015
	SYNTAX	(',')		;2016 - rst 08h
	ex	de,hl		;2018
	ld	hl,(AUTINC)	;2019
	ex	de,hl		;201c
	jr	z,SNGAUT	;201d
	call	LINGET		;201f
	jp	nz,SNERR	;2022
SNGAUT:	ex	de,hl		;2025
SNGAU1:	ld	a,h		;2026
	or	l		;2027
	jp	z,FCERR		;2028
	ld	(AUTINC),hl	;202b
	ld	(AUTFLG),a	;202e
	pop	hl		;2031
	ld	(AUTLIN),hl	;2032
	pop	bc		;2035
	jp	MAIN		;2036
;
; ----------------------------------------------------------------------
; 2039-2066 – LEVEL II BASIC IF ROUTINE – “IF”
; ----------------------------------------------------------------------
IF:	call	FRMEVL		;2039
	ld	a,(hl)		;203c
	cp	','		;203d
	call	z,CHRGTR	;203f
	cp	TKTHEN		;2042
	call	z,CHRGTR	;2044
	dec	hl		;2047
	push	hl		;2048
	call	VSIGN		;2049
	pop	hl		;204c
	jr	z,FALSIF	;204d
DOCOND:	GETCHR			;204f - rst 10h
	jp	c,GOTO		;2050
	jp	GONE3		;2053
;
; ----------------------------------------------------------------------
; 2056H – LEVEL II BASIC ELSE ROUTINE – “FALSIF”
; ----------------------------------------------------------------------
FALSIF:	ld	d,$01		;2056
SKPMRF:	call	DATA		;2058
	or	a		;205b
	ret	z		;205c
	GETCHR			;205d - rst 10h
	cp	TKELSE		;205e - else token
	jr	nz,SKPMRF	;2060
	dec	d		;2062
	jr	nz,SKPMRF	;2063
	jr	DOCOND		;2065
; ----------------------------------------------------------------------
; 2067-206E – LEVEL II BASIC LPRINT ROUTINE – FOR v1.0 ONLY– “LPRINT”
; ----------------------------------------------------------------------
LPRINT:	ld	a,DEV1PRT	;2067 - Device PRINTER
	ld	(PRTFLG),a	;2069 - set the output device code - printer
LPRIN1:	jp	NEWCHR		;206c * * *
; ----------------------------------------------------------------------
; 206F-2177 – LEVEL II BASIC PRINT@ ROUTINE – FOR v1.0 ONLY – “PRINT”
; ----------------------------------------------------------------------
;
#IFDEF VER12
;
PRINT:	call	FILGET		;206f
	cp	'@'		;2072 - IS it a PRINT@
	jr	nz,PNOTAT	;2074 - Jump if not PRINT@, otherwise continue
	call	GETINT		;2076 - Evaluate and get Integer into DE
	cp	$04		;2079
	jp	nc,FCERR	;207b
	push	hl		;207e
	ld	hl,vidmem	;207f
	add	hl,de		;2082
	ld	(CURSOR),hl	;2083
	ld	a,e		;2086
	and	$3F		;2087
	ld	(TTYPOS),a	;2089
	pop	hl		;208c
	SYNTAX	(',')		;208d - rst 08h
PNOTAT:	cp	'#'		;208f - Is it PRINT#
	jr	nz,NEWCHR	;2091 - Jump if not PRINT#
	call	CWRTON		;2093
	ld	a,DEVTAPE	;2096 - Set A to 80H (the write to cassette flag)
	ld	(PRTFLG),a	;2098 - save current output device flag
NEWCHR:	dec	hl		;209b
	GETCHR			;209c - rst 10h
	call	z,CRDO		;209d
PRINTC:	jp	z,FINPRT	;20a0
	cp	TKUSNG		;20a3 - using token
	jp	z,PRINUS	;20a5
	cp	TKTAB		;20a8 - tab token
	jp	z,TABER		;20aa
	push	hl		;20ad
	cp	','		;20ae
	jp	z,COMPRT	;20b0
	cp	SEMICO		;20b3 - compare with semicolin ';'
	jp	z,NOTABR	;20b5
	pop	bc		;20b8
	call	FRMEVL		;20b9
	push	hl		;20bc
;
#ELSE
;
PRINT:	call	FILGET		;206f DOS exit for PRINT processing.
	cp	'#'		;2072 Check for Cassette
	jr	nz,PNOTAT	;2074
	call	CWRTON		;2076 Write header on cassette file
	ld	(PRTFLG),a 	;2079 Set current system device to cassette
PNOTAT:
NEWCHR:	dec	hl 		;207C Backspace over previous symbol in code string
	GETCHR	 		;207D rst 10h Re-examine previous char in code string
	call	z,CRDO 		;207E If end of string write a Carriage Return
PRINTC:	jp	z,FINPRT	;2081 If end of string turn off cassette and return
	or	$20		;2084 Not end of string. Convert possible 40 to 60
 	cp	BQUOTE	 	;2086 Compare against a "'", which is actually a @ with OR $20
	jr	nz,PRINTD	;2088 Jmp if not PRINT @
 	call	GETINT 		;208A Evaluate @ expression, result in DE * PRINT @ routine
	cp	$04		;208D A = MSB, test for @ value > 1023
 	jp	nc,FCERR	;208E FC error if @ position > 1023
	push	hl	 	;2092  Save current code string addr
	ld	hl,vidmem	;2093 HL = starting addr of video buffer
	add	hl,de		;2096  Add tab position
 	ld	(CURSOR),hl	;2097 And save addr in video DCB as cursor addr
	ld	a,e		;209A Then get position within line
	and	$3F		;209B And truncate it to 63
 	ld	(TTYPOS),a 	;209D Then save as current position within line
	pop	hl		;20A0 Restore code string addr (starting addr of item list)
	SYNTAX	(',')		;20A1 rst 08h But make sure a comma follows the tab position
	jr	LPRIN1		;20A3 Go get first variable from item list
PRINTD:	ld	a,(hl)		;20A5 Reload next element from code string
	cp	TKUSNG		;20A6 Test for USING token
	jp	z,PRINUS	;20A8 Jmp if USING token
	cp	TKTAB		;20AB Test for TAB token
	jp	z,TABER		;20AD  Jmp if TAB token
	push	hl		;20B0  Save current code string addr
	cp	','		;20B1 Test for a comma
	jr	z,COMPRT	;20B3 Go get next item if a comma
 	cp	SEMICO		;20B5 Not comma, test for semi-colon
	jr	z,NTCAS0	;20B7 Go get next item if semi-colon
	call	FRMEVL		;20B9 Evaluate next item to be printed
 	ex	(sp),hl		;20BC Save current code string addr HL = addr of current item
;
#ENDIF
;
	GETYPE			;20bd - RST 20 - check the current number type
	jr	z,STRDON	;20be - Output a String
	call	FOUT		;20c0 - convert number to string in the print buffer
	call	STRLIT		;20c3 - String for the ascii number
	call	EXDSKL		;20c6
	ld	hl,(FACLO)	;20c9
	ld	a,(PRTFLG)	;20cc - Get the output device type flag into A
	or	a		;20cf - set flags
	jp	m,LINCH2	;20d0 - If we writing to a cassette
	jr	z,ISTTY		;20d3 - If NOT LPRINT
; ----------------------------------------------------------------------
;   Lands here if we are sure we are using the printer
; ----------------------------------------------------------------------
	ld	a,(LPTPOS)	;20d5 - We have a LPRINT, Get carriage POS
	add	a,(hl)		;20d8
	cp	132		;20d9 - Is the adjusted length greater than 132
	jr	LINCHK		;20db
; ----------------------------------------------------------------------
;   Jumped here if we are sure we are using the display
; ----------------------------------------------------------------------
#IFDEF BUGFIX1
ISTTY:	call	DSPLINLTH	; get the line length into A from shadow Port
#ELSE
ISTTY:	ld	a,(LINLEN)	;20dd
#ENDIF
	ld	b,a		;20e0 - the video line size
	ld	a,(TTYPOS)	;20e1 - current video line position
	add	a,(hl)		;20e4 - Add the len of string to be displayed
	cp	b		;20e5 - compare with line size
;
LINCHK:	call	nc,CRDO		;20e6 - the new line will overflow the buffer -> CR
LINCH2:	call	STRPRT		;20e9
	ld	a,SPACE		;20ec
	call	OUTDO		;20ee
	or	a		;20f1
STRDON:	call	z,STRPRT	;20f2
	pop	hl		;20f5
	jp	NEWCHR		;20f6
CRDONZ:	ld	a,(TTYPOS)	;20f9
	or	a		;20fc
	ret	z		;20fd
; ----------------------------------------------------------------------
; 20FE – This routine outputs a carriage return (0DH)
;   to a device determined by flag stored at (409CH) – “CRDO”
; ----------------------------------------------------------------------
CRDO:	ld	a,ENTER		;20fe
	call	OUTDO		;2100
CRFIN:	call	EXDSCR		;2103
	xor	a		;2106
	ret			;2107
; ----------------------------------------------------------------------
; 2108 – This is the jump point for a continuation of the PRINT# code – “COMPRT”.
; ----------------------------------------------------------------------
COMPRT:	call	EXPDOS		;2108 - Dos Exit for Print TAB and Print #
	ld	a,(PRTFLG)	;210b - the current output device flag
	or	a		;210e - Set The Flags
	jp	p,NTCAS		;210f - if the printer or the video display
	ld	a,','		;2112
	call	OUTDO		;2114
NTCAS0:	jr	NOTABR		;2117
NTCAS:	jr	z,ISCTTY	;2119 - is it the video display
	ld	a,(LPTPOS)	;211b - the current carriage position.
	cp	$70		;211e
	jp	CHKCOM		;2120
ISCTTY:	ld	a,(CLMLST)	;2123 - output device is the video display
	ld	b,a		;2126
	ld	a,(TTYPOS)	;2127
	cp	b		;212a
CHKCOM:	call	nc,CRDO		;212b
	jr	nc,NOTABR	;212e
MORCOM:	sub	$10		;2130
	jr	nc,MORCOM	;2132
	cpl			;2134
	jr	ASPA2		;2135
; ----------------------------------------------------------------------
; 2137 – TAB logic – “TABER”
;   This routine is the TAB function for video or printer (flag at 409CH).
;   On entry: E Register contains desired TAB position,
;   HL points to start of message to be displayed
; ----------------------------------------------------------------------
TABER:	call	GTBYTC		;2137 - evaluate the tab number, and return with the result in A
;
#IFDEF VER12
	and	$3F		;213a - Do not let it exceed 63
#ELSE
	and	$7F		;213a - Result in A-reg. Do not let it exceed 127
#ENDIF
;
	ld	e,a		;213c - E - number of tabs <= 127
#IFDEF BUGFIX7C
	call	TABERFIX	;Fixed routine to consume the )
#ELSE
	SYNTAX	(')')		;213d - rst 08h
	dec	hl		;213f - decrement back, will consume latter
#ENDIF
; ----------------------------------------------------------------------
	push	hl		;2140 - save the pointer to program
	call	EXPDOS		;2141 - Dos Exit for Print TAB and Print #
	ld	a,(PRTFLG)	;2144 - the current output device flag
	or	a		;2147 - set the flags
	jp	m,FCERR		;2148 - cannot send a tab to cassette, FC ERR
	jp	z,TTYIST	;214b - is Video
	ld	a,(LPTPOS)	;214e - printer get carriage position
	jr	DOSIST		;2151
TTYIST:	ld	a,(TTYPOS)	;2153 - current cursor position
DOSIST:	cpl			;2156 - => - current cursor pos
	add	a,e		;2157 - number of tabs - current cursor pos
	jr	nc,NOTABR	;2158 - already past the current pos, JP EXIT
ASPA2:	inc	a		;215a
	ld	b,a		;215b - number of characters to print
	ld	a,SPACE		;215c - Symbol to use for tabs
REPOUT:	call	OUTDO		;215e - Print a Space
	dec	b		;2161 - dec count of spaces to print
	jr	nz,REPOUT	;2162 - more spaces required, loop
NOTABR:	pop	hl		;2164 - restore program pointer
	GETCHR			;2165 - rst 10h - consume the character
	jp	PRINTC		;2166 - Return back to PRINT routine
; ----------------------------------------------------------------------
; 2169 – FINPRT - This routine resets the device type flag at 409CH to
;        zero (output to video display), also turns off cassette drive if
;        necessary. CALLs Disk BASIC link at 41BEH prior to return.
; ----------------------------------------------------------------------
FINPRT:
#IFNDEF NOCASSETTE
	ld	a,(PRTFLG)	;2169 - current output device flag
	or	a		;216c - check the flags
	call	m,CTOFF		;216d - If cassette, turn it off
#ENDIF
	xor	a		;2170 - DEV0VID
	ld	(PRTFLG),a	;2171 - set current output device type = VIDEO
	call	FINDRT		;2174 - DOS Exit Point
	ret			;2177
;
	DEFS	$2178 - $	; UNUSED - padding for cassette code removal
; ----------------------------------------------------------------------
; 2178-217E – MESSAGE STORAGE LOCATION FOR REDO MESSAGE – “TRYAGN”
; ----------------------------------------------------------------------
TRYAGN:	DEFB	"?REDO"
	DEFB	ENTER
	DEFB	0
; ----------------------------------------------------------------------
; 217F-2285 – INPUT AND READ ROUTINES– “TRMNOK”
;   This is a multi-purpose processing routine. We can wind up here because
;     DATA was typed in ; DATA statements were improperly formatted.
;   We can also wind up here where we want an INPUT to start again.
;   If we are here because of a READ, throw a ?SN ERROR at the data line.
; ----------------------------------------------------------------------
TRMNOK:	ld	a,(FLGINP)	;217f
	or	a		;2182
	jp	nz,DATSNE	;2183
	ld	a,(CASFLG)	;2186 - test the cassette flag
	or	a		;2189
	ld	e,ERRFD		;218a - ?FD ERROR - bad data file error
	jp	z,ERROR		;218c - If input device is cassette
	pop	bc		;218f
	ld	hl,TRYAGN	;2190
	call	STROUT		;2193
	ld	hl,(SAVTXT)	;2196
	ret			;2199
;
; ----------------------------------------------------------------------
; 219A-21EE – LEVEL II BASIC INPUT ROUTINE – “INPUT”
; ----------------------------------------------------------------------
INPUT:	call	ERRDIR		;219a - Check to see if there is an illegal direct
	ld	a,(hl)		;219d - char in basic program
	call	EXUNKN		;219e - Pass Control to a DOS exit.
	sub	'#'		;21a1 - compare with # indicating from Cassette
	ld	(CASFLG),a	;21a3 - store value in cassette flag
	ld	a,(hl)		;21a6 - get the character again
	jr	nz,INTCAS	;21a7 - Jump if Not "#" input from casssette
;
#IFDEF NOCASSETTE
;
	ld	e,ERRFD		; ?FD ERROR - bad data file error
	jp	ERROR		; If input device is cassette
	DEFS	$21C9 - $	; Pad UNUSED black above previously cassette code
;
#ELSE
;
	call	CSRDON		;21a9
	push	hl		;21ac
	ld	b,250		;21ad - Max characters which can be read
	ld	hl,(BUFPNT)	;21af - input buffer
FILBUF:	call	CASIN		;21b2
	ld	(hl),a		;21b5
	inc	hl		;21b6
	cp	ENTER		;21b7
	jr	z,ENDREC	;21b9
	djnz	FILBUF		;21bb
ENDREC:	dec	hl		;21bd
	ld	(hl),$00	;21be
	call	CTOFF		;21c0
	ld	hl,(BUFPNT)	;21c3
	dec	hl		;21c6
	jr	INPCN3		;21c7
;
#ENDIF
;
INTCAS:	ld	bc,NOTQTI	;21c9
	push	bc		;21cc
	cp	DQUOTE		;21cd
	ret	nz		;21cf
	call	STRLTI		;21d0
	SYNTAX	(SEMICO)	;21d3 - rst 08h compare with semicolin ';'
	push	hl		;21d5
	call	STRPRT		;21d6
	pop	hl		;21d9
	ret			;21da
NOTQTI:	push	hl		;21db
	call	QINLIN		;21dc - Print '?' - and get the input from the keyboard
	pop	bc		;21df
	jp	c,STPEND	;21e0
; -----------------------------------------------------------------------
; 21E3 - ASSIGN STRING(S) TO BASIC VARIABLE(S) (TAS)
;   This routine is part of the BASIC INPUT command routine , and can be
;   used to process input obtained from CALLing one of the keyboard input
;   routines at 1BB3H, 0361H, etc. On entry, BC must point to the first
;   character of a string that contains the variable name(s) (if more than
;   one variable name is used the names must be separatedby commas, and a
;   zero byte or colon must be placed after the last variable name). HL
;   must point to the byte just prior to the beginning of the input string
;   (this is where placed by the above - mentioned input routines -
;   that this byte is altered by this routine), and the string may
;   contain input for more than one variable (items must be separated by
;   commas).
; -----------------------------------------------------------------------
	inc	hl		;21e3
	ld	a,(hl)		;21e4
	or	a		;21e5
	dec	hl		;21e6
	push	bc		;21e7
	jp	z,DATAH		;21e8
INPCN3:	ld	(hl),','	;21eb
	jr	INPCON		;21ed
;
; ----------------------------------------------------------------------
; 21EF – READ logic – “READ”
READ:	push	hl		;21ef
	ld	hl,(DATPTR)	;21f0
;
	DEFB	ORNN		;21f3 - Z80 Trick - OR nn - skip next 1 byte
;
INPCON:	xor	a		;21f4
	ld	(FLGINP),a	;21f5
	ex	(sp),hl		;21f8
	jr	LOPDAT		;21f9
LOPDT2:	SYNTAX	(',')		;21fb - rst 08h
LOPDAT:	call	PTRGET		;21fd
	ex	(sp),hl		;2200
	push	de		;2201
	ld	a,(hl)		;2202
	cp	','		;2203
	jr	z,DATBK		;2205
	ld	a,(FLGINP)	;2207
	or	a		;220a
	jp	nz,DATLOP	;220b
	ld	a,(CASFLG)	;220e - value of the cassette input flag.
	or	a		;2211 - set flags
	ld	e,ERROD		;2212 - ?OD ERROR
	jp	z,ERROR		;2214 - if the input is from cassette
	ld	a,'?'		;2217
	call	OUTDO		;2219
	call	QINLIN		;221c
	pop	de		;221f
	pop	bc		;2220
	jp	c,STPEND	;2221
	inc	hl		;2224
	ld	a,(hl)		;2225
	or	a		;2226
	dec	hl		;2227
	push	bc		;2228
	jp	z,DATAH		;2229
	push	de		;222c
DATBK:	call	FILIND		;222d
	GETYPE			;2230 - RST 20 - check the current number type
	push	af		;2231
	jr	nz,NUMINS	;2232
	GETCHR			;2234 - rst 10h
	ld	d,a		;2235
	ld	b,a		;2236
	cp	DQUOTE		;2237
	jr	z,NOWGETR	;2239
	ld	d,':'		;223b
	ld	b,','		;223d
	dec	hl		;223f
NOWGETR: call	STRLT2		;2240
DOASIG:	pop	af		;2243
	ex	de,hl		;2244
	ld	hl,STRDN2	;2245
	ex	(sp),hl		;2248
	push	de		;2249
	jp	INPCOM		;224a
NUMINS:	GETCHR			;224d - rst 10h
	pop	af		;224e
	push	af		;224f
	ld	bc,DOASIG	;2250
	push	bc		;2253
	jp	c,FIN		;2254
	jp	nc,FINDBL	;2257
STRDN2:	dec	hl		;225a
	GETCHR			;225b - rst 10h
	jr	z,TRMOK		;225c
	cp	','		;225e
	jp	nz,TRMNOK	;2260
TRMOK:	ex	(sp),hl		;2263
	dec	hl		;2264
	GETCHR			;2265 - rst 10h
	jp	nz,LOPDT2	;2266
	pop	de		;2269
; ----------------------------------------------------------------------
; Removed in ROM v1.2 because this was not needed.
; ----------------------------------------------------------------------
	nop			;226a
	nop			;226b
	nop			;226c
	nop			;226d
	nop			;226e
; ----------------------------------------------------------------------
	ld	a,(FLGINP)	;226f
	or	a		;2272
	ex	de,hl		;2273
	jp	nz,RESFIN	;2274
	push	de		;2277
	call	EXCHDS		;2278
	or	(hl)		;227b
	ld	hl,EXIGNT	;227c
	call	nz,STROUT	;227f
	pop	hl		;2282
	jp	FINPRT		;2283
; ----------------------------------------------------------------------
; 2286-2295 – MESSAGE STORAGE LOCATION – “EXIGNT”
; ----------------------------------------------------------------------
EXIGNT:	DEFB	"?Extra ignored"
	DEFB	ENTER, $00
; ----------------------------------------------------------------------
; 2296-22B5 – FIND THE NEXT DATA STATEMENT ROUTINE – “DATLOP”
;   The original ROM source notes that the search is mad by uising
;   the execution code for DATA to skp over statements.
; ----------------------------------------------------------------------
DATLOP:	call	DATA		;2296
DATFND:	or	a		;2299
	jr	nz,NOWLIN	;229a
	inc	hl		;229c
	ld	a,(hl)		;229d
	inc	hl		;229e
	or	(hl)		;229f
	ld	e,ERROD		;22a0
	jp	z,ERROR		;22a2
	inc	hl		;22a5
	ld	e,(hl)		;22a6
	inc	hl		;22a7
	ld	d,(hl)		;22a8
	ex	de,hl		;22a9
	ld	(DATLIN),hl	;22aa
	ex	de,hl		;22ad
NOWLIN:	GETCHR			;22ae - rst 10h
	cp	TKDATA		;22af - data token
	jr	nz,DATLOP	;22b1
	jp	DATBK		;22b3
;
; ----------------------------------------------------------------------
; 22B6-2336 – LEVEL II BASIC NEXT ROUTINE – “NEXT”
; ----------------------------------------------------------------------
NEXT:	ld	de,$0000	;22b6 - default for cases where NEXT doesn't include a variable name
NEXTC:	call	nz,PTRGET	;22b9 - Get the pointer to variable which follows the NEXT token -> DE
	ld	(TEMP),hl	;22bc - Save the BASIC program pointer after NEXT into (TEMP)
	call	FNDFOR		;22bf - search the STACK for the appropriate FOR (see above)
	jp	nz,NFERR	;22c2 - If not found, then display a NF ERROR message
	ld	sp,hl		;22c5 - Reset Stack using discovered FOR entry (HL) Sign
	ld	(SAVSTK),hl	;22c6 - save the stack pointer
	push	de		;22c9 - Save the pointer to the variables address
	ld	a,(hl)		;22ca - sign for the STEP value
	inc	hl		;22cb - increment to the value of the STEP
	push	af		;22cc - Save the value of the sign for the STEP value
	push	de		;22cd - Save the pointer to the loop variable
	ld	a,(hl)		;22ce - number type flag for the STEP value
	inc	hl		;22cf
	or	a		;22d0
	jp	m,INTNXT	;22d1 - if the STEP value is an integer
; ----------------------------------------------------------------------
; Part of the NEXT code, process the variable as Single precision
; ----------------------------------------------------------------------
	call	MOVFM		;22d4
	ex	(sp),hl		;22d7 - HL pointer to loop variable; STACK pointer for the FOR entry
	push	hl		;22d8
	call	FADDS		;22d9
	pop	hl		;22dc
	call	MOVMF		;22dd
	pop	hl		;22e0
	call	MOVRM		;22e1
	push	hl		;22e4
	call	FCOMP		;22e5
	jr	FINNXT		;22e8
; ----------------------------------------------------------------------
; Part of the NEXT code, process the variable as an Integer
; ----------------------------------------------------------------------
INTNXT:	inc	hl		;22ea - skip 4 bytes of INTEGER Padding
	inc	hl		;22eb
	inc	hl		;22ec
	inc	hl		;22ed
	ld	c,(hl)		;22ee - the LSB of the STEP value
	inc	hl		;22ef
	ld	b,(hl)		;22f0 - the MSB of the STEP value
	inc	hl		;22f1
	ex	(sp),hl		;22f2 - HL pointer to loop variable; STACK pointer for the FOR entry
	ld	e,(hl)		;22f3 - the LSB of the TO variable
	inc	hl		;22f4
	ld	d,(hl)		;22f5 - the MSB of the TO variable
	push	hl		;22f6 - save the pointer to loop variable
	ld	l,c		;22f7 - STEP variable into HL
	ld	h,b		;22f8
	call	IADD		;22f9 - add the 2 integer numbers DE,HL store to ACC
	ld	a,(VALTYP)	;22fc - value type of result
	cp	VTSNG		;22ff - Compare with Single Precision
#IFDEF BUGFIX11
	jp	z,INTNXTOVER	; Correctly handle the overflow.
#ELSE
	; Issue #11 - with Integer loops with large step values causing
	; overflow into Single precision numbers, which is not well handled.
	; FOR J% = 0 TO 30000 STEP 5000 : NEXT J%
	jp	z,OVERR		;2301 - Overflow into Single precision !!!
#ENDIF
	ex	de,hl		;2304 - DE will now hold the new loop variable value
	pop	hl		;2305 - restore the loop variable pointer
	ld	(hl),d		;2306 - save MSB of result back to the loop variable
	dec	hl		;2307
	ld	(hl),e		;2308 - save LSB of result back to the loop variable
	pop	hl		;2309 - restore the for entry pointer
	push	de		;230a - save the loop variable pointer back to stack
	ld	e,(hl)		;230b - get the Final value LSB
	inc	hl		;230c
	ld	d,(hl)		;230d - get the Final value MSB
	inc	hl		;230e
	ex	(sp),hl		;230f -
	call	ICOMP		;2310 - Compare current HL, and final value DE, Set Flags
; ----------------------------------------------------------------------
; Part of the NEXT code, check for loop completed, or continue loop
; ----------------------------------------------------------------------
FINNXT:	pop	hl		;2313 - restore the loop variable pointer
	pop	bc		;2314 - Get the sign into B
	sub	b		;2315 - Subtract the sign
	call	MOVRM		;2316 - loads a SINGLE PRECISION value (HL) into BC and DE
	jr	z,LOOPDN	;2319 - Jump if loop HAS COMPLETED
; ----------------------------------------------------------------------
; Part of the NEXT code, NOT completed the loop, need to go back to FOR
; ----------------------------------------------------------------------
	ex	de,hl		;231b - HL -> BASIC line number of the FOR statement
	ld	(CURLIN),hl	;231c - Save the BASIC line number
	ld	l,c		;231f - LSB of the BASIC program pointer
	ld	h,b		;2320 - MSB of the BASIC program pointer
	jp	NXTCON		;2321 - continue execution and restore the FOR token
; ----------------------------------------------------------------------
; Part of the NEXT code, FINISHED the Loop, need to continue after NEXT
; ----------------------------------------------------------------------
LOOPDN:	ld	sp,hl		;2324 - restore the Stack based on HL position
	ld	(SAVSTK),hl	;2325 - save the stack
	ld	hl,(TEMP)	;2328 - Restore the BASIC program pointer after NEXT
	ld	a,(hl)		;232b - get the character from program
	cp	','		;232c - check for comma.
	jp	nz,NEWSTT	;232e - If NOT comma, then execute Statement after NEXT
	GETCHR			;2331 - rst 10h - consumes the comma
	call	NEXTC		;2332 - process the NEXT variable name after the comma
;
; ----------------------------------------------------------------------
; 2335-27C8 – EVALUATE EXPRESSION – “FRMPRN” and “FRMEVL”
;   this routine starts with HL
;   pointing to the first character of a formula. At the end of the routine
;   HL points to the terminator, and ACC holds the result. Important to
;   note that on exit Register A does not necessarily reflect the term char
; ----------------------------------------------------------------------
FRMPRN:	SYNTAX	('(')		;2335 - rst 08h
;----------------------------------------------------------------------
; FRMEVL evaluates a BASIC expression pointed to by the HL register pair and
; stores the result in the ACC. The expression must be terminated with zero byte,
; comma, right bracket or colon. After execution, HL will point to the delimiter and,
; in the case of string expressions, the ACC will contain the address of the first of
; three bytes that contain string length and string address. Note that the stack is used
; frequently and the machine should be formatted for RUN mode in order to use this
; routine. (See sample program in Appendix 1 for an application of this routine).
;----------------------------------------------------------------------
FRMEVL:	dec	hl		;2337
FRMCHK:	ld	d,$00		;2338
LPOPER:	push	de		;233a
	ld	c,$01		;233b
	call	GETSTK		;233d
	call	EVAL		;2340
	ld	(TEMP2),hl	;2343 - Save the BASIC program pointer
RETAOP:	ld	hl,(TEMP2)	;2346 - Restore the BASIC program pointer
TSTOP:	pop	bc		;2349
	ld	a,(hl)		;234a - the character at current program pointer
	ld	d,0		;234b - assume no relational operations
LOPREL:	sub	TKGT		;234d
	jr	c,ENDREL	;234f - Less than a > token
	cp	$03		;2351
	jr	nc,ENDREL	;2353
	cp	$01		;2355
	rla			;2357
	xor	d		;2358
	cp	d		;2359
	ld	d,a		;235a
	jp	c,SNERR		;235b
	ld	(TEMP3),hl	;235e
	GETCHR			;2361 - rst 10h
	jr	LOPREL		;2362
ENDREL:	ld	a,d		;2364
	or	a		;2365
	jp	nz,FINREL	;2366
	ld	a,(hl)		;2369
	ld	(TEMP3),hl	;236a
	sub	TKPLUS		;236d - subtract PLUS token, start of Arithmetic Tokens
	ret	c		;236f
	cp	$07		;2370
	ret	nc		;2372
	ld	e,a		;2373
	ld	a,(VALTYP)	;2374
	sub	VTSTR		;2377 - Adjust Type -1 INT, 0 STR, 1 SP, 5 DP.
	or	e		;2379 - Combine with operator value in Register E
	jp	z,CAT		;237a - If String addition.
	ld	hl,OPTAB	;237d - operation precidence table
	add	hl,de		;2380
	ld	a,b		;2381
	ld	d,(hl)		;2382
	cp	d		;2383
	ret	nc		;2384
	push	bc		;2385
	ld	bc,RETAOP	;2386
	push	bc		;2389
	ld	a,d		;238a
	cp	$7F		;238b
	jp	z,EXPSTK	;238d
	cp	$51		;2390
	jp	c,ANDORD	;2392
; the following will push the current value
; in the ACC onto the STACK EXCEPT in the case of a string, in which case it will throw
; a TYPE MISMATCH error. Registers D and E are preserved. This routine is also used in
; the user-defined function value savings
NUMREL:	ld	hl,FACLO	;2395
	or	a		;2398
	ld	a,(VALTYP)	;2399
	dec	a		;239c
	dec	a		;239d
	dec	a		;239e - Now A will be -1=Int, 0=Str, 1=SP, 5=DP
	jp	z,TMERR		;239f
	ld	c,(hl)		;23a2
	inc	hl		;23a3
	ld	b,(hl)		;23a4
	push	bc		;23a5
	jp	m,VPUSHD	;23a6
	inc	hl		;23a9
	ld	c,(hl)		;23aa
	inc	hl		;23ab
	ld	b,(hl)		;23ac
	push	bc		;23ad
	push	af		;23ae
	or	a		;23af
	jp	po,VPSHD1	;23b0
	pop	af		;23b3
	inc	hl		;23b4
	jr	c,PUSDVR	;23b5
	ld	hl,DFACLO	;23b7
PUSDVR:	ld	c,(hl)		;23ba
	inc	hl		;23bb
	ld	b,(hl)		;23bc
	inc	hl		;23bd
	push	bc		;23be
	ld	c,(hl)		;23bf
	inc	hl		;23c0
	ld	b,(hl)		;23c1
	push	bc		;23c2
;
	DEFB	LDBNN		;23c3 - Z80 Trick - LD B,nn - Skip next 1 byte instrution
;
VPSHD1:	pop	af		;23c4
VPUSHD:	add	a,$03		;23c5
	ld	c,e		;23c7
	ld	b,a		;23c8
	push	bc		;23c9
	ld	bc,APPLOP	;23ca
FINTMP:	push	bc		;23cd
	ld	hl,(TEMP3)	;23ce
	jp	LPOPER		;23d1
;
; ----------------------------------------------------------------------
; 23D4-23D6 – Part of the Evaluation Routine – “EPSTK”
;   Per the original ROM source, for exponentiation, we want to force
;   the current value in the ACCumulator to be single precision.
;   When application time comes, we force the right hand operand to
;   single precision as well.
; ----------------------------------------------------------------------
EXPSTK:	call	FRCSNG		;23d4
	call	PUSHF		;23d7
	ld	bc,FPWRQ	;23da
	ld	d,$7F		;23dd
	jr	FINTMP		;23df
; ----------------------------------------------------------------------
; 23D4-23D6 – Part of the Evaluation Routine – “ANDORD”
;   for AND and OR and \ and MOD
;   we want to force the current value in the ACCumulator to be an integer,
;   and at application time force the right hand operator to be an integer as well.
; ----------------------------------------------------------------------
ANDORD:	push	de		;23e1
	call	FRCINT		;23e2
	pop	de		;23e5
	push	hl		;23e6
	ld	bc,DANDOR	;23e7
	jr	FINTMP		;23ea
; ----------------------------------------------------------------------
; 23D4-23D6 – Part of the Evaluation Routine – “FINREL”
;   this routine will build an
;   entry for a relational operator strings are treated specially.
;   Numeric compares are different from most operator entries only
;   in the fact that at the bottom instead of having RETAOP, DOCMP
;   and the relational bits are stored. Strings have STRCMP, the pointer
;   at the string descriptor, DOCMP and the relational bits.
; ----------------------------------------------------------------------
FINREL:	ld	a,b		;23ec
	cp	$64		;23ed
	ret	nc		;23ef
	push	bc		;23f0
	push	de		;23f1
	ld	de,$6404	;23f2
	ld	hl,DOCMP	;23f5
	push	hl		;23f8
	GETYPE			;23f9 - RST 20 - check the current number type
	jp	nz,NUMREL	;23fa
	ld	hl,(FACLO)	;23fd
	push	hl		;2400
	ld	bc,STRCMP	;2401
	jr	FINTMP		;2404
; ----------------------------------------------------------------------
; 2406 – Part of the Evaluation Routine – “APPLOP”
;   APPLOP is returned to when
;   it is time to apply an arithmetic or numeric comparison operation.
;   The STACK has a double byte entry with the operator number and the
;   NTF of the value on the STACK. APPLOP decides what value level
;   the operation will occur at, and converts the arguments.
; ----------------------------------------------------------------------
APPLOP:	pop	bc		;2406
	ld	a,c		;2407
	ld	(DORES),a	;2408
	ld	a,b		;240b
	cp	VTDBL		;240c - Is type of the number in the STACK Double
	jr	z,STKDBL	;240e - force the number in the ACC to Double
	ld	a,(VALTYP)	;2410
	cp	VTDBL		;2413 - Is it a Double Precision
	jp	z,FACDBL	;2415
	ld	d,a		;2418
	ld	a,b		;2419
	cp	VTSNG		;241a ; number type in the STACK is single precision
	jp	z,STKSNG	;241c
	ld	a,d		;241f ; number type for ACCumulator
	cp	VTSTR		;2420 ; Compare with String
	jp	z,TMERR		;2422 ; If String Then TM ERR
	jp	nc,FACSNG	;2425 ; If Single or Double Precsion
	ld	hl,INTDSP	;2428 - Integer Function lookup table
	ld	b,$00		;242b
	add	hl,bc		;242d
	add	hl,bc		;242e
	ld	c,(hl)		;242f
	inc	hl		;2430
	ld	b,(hl)		;2431
	pop	de		;2432
	ld	hl,(FACLO)	;2433
	push	bc		;2436
	ret			;2437
; ----------------------------------------------------------------------
;   at this point we know
;   the STACK operand is double precision, so the number in the ACC
;   must be forced into double precision, then moved into ARG and the
;   STACK value POPped into ACC.
; ----------------------------------------------------------------------
STKDBL:	call	FRCDBL		;2438
	call	VMOVAF		;243b
	pop	hl		;243e
	ld	(DFACLO+2),hl	;243f
	pop	hl		;2442
	ld	(DFACLO),hl	;2443
SNGDBL:	pop	bc		;2446
	pop	de		;2447
	call	MOVFR		;2448 - Move single in BC:DE into ACC
SETDBL:	call	FRCDBL		;244b
	ld	hl,DBLDSP	;244e - Double Precision Math Table
DODSP:	ld	a,(DORES)	;2451
	rlca			;2454
	push	bc		;2455
	ld	c,a		;2456
	ld	b,$00		;2457
	add	hl,bc		;2459
	pop	bc		;245a
	ld	a,(hl)		;245b
	inc	hl		;245c
	ld	h,(hl)		;245d
	ld	l,a		;245e
	jp	(hl)		;245f
; ----------------------------------------------------------------------
; 2460H – Part of the Evaluation Routine – “FACDBL”
;   at this point the ACCumulator
;   holds a double precision number, and the STACK holds either an integer
;   or a single precision number, so we need to convert it.
; ----------------------------------------------------------------------
FACDBL:	push	bc		;2460
	call	VMOVAF		;2461
	pop	af		;2464
	ld	(VALTYP),a	;2465
	cp	VTSNG		;2468 - compare with single precision
	jr	z,SNGDBL	;246a
	pop	hl		;246c
	ld	(FACLO),hl	;246d
	jr	SETDBL		;2470
; ----------------------------------------------------------------------
; 2472H – Part of the Evaluation Routine – “STKSNG”
;   at this point the STACK
;   holds a single precision number, we know that the ACCumulator holds
;   either an integer or a single precision number, so we need to convert it.
; ----------------------------------------------------------------------
STKSNG:	call	FRCSNG		;2472
	pop	bc		;2475
	pop	de		;2476
SNGDO:	ld	hl,SNGDSP	;2477  - address of the SP arithmetic table
	jr	DODSP		;247a
; ----------------------------------------------------------------------
; 247CH – Part of the Evaluation Routine – “FACSNG”
;   at this point the ACCuumulator
;   holds a single precision number and the STACK holds an integer.
; ----------------------------------------------------------------------
FACSNG:	pop	hl		;247c
	call	PUSHF		;247d
	call	CONSIH		;2480
	call	MOVRF		;2483
	pop	hl		;2486
	ld	(FAC-1),hl	;2487
	pop	hl		;248a
	ld	(FACLO),hl	;248b
	jr	SNGDO		;248e
;
; ======================================================================
; 2490 – LEVEL II BASIC INTEGER DIVIDE – “INTDIV”
;
;   (ACC=DE / HL) Result will be in single-precision (NTF=4) in the ACC.
;    Divides DE by HL. Both values are converted to single precision before
;   the division is started. The quotient is left in REG l; the mode flag
;   is updated. The orginal contents of the DE and HL Register sets are lost
; ----------------------------------------------------------------------
INTDIV:	push	hl		;2490
	ex	de,hl		;2491
	call	CONSIH		;2492
	pop	hl		;2495
	call	PUSHF		;2496
	call	CONSIH		;2499
	jp	FDIVT		;249c
;
; ----------------------------------------------------------------------
; 249F – Evaluate a Variable, Constant, or Function Call – “EVAL”
; ----------------------------------------------------------------------
EVAL:	GETCHR			;249f - rst 10h
	ld	e,ERRMO		;24a0 - Missing Operand Error
	jp	z,ERROR		;24a2 - a ERROR if we are at the end of the string
	jp	c,FIN		;24a5 - char is numeric -> ASCII TO BINARY
	call	ISLET		;24a8 - char is alphabetic, assumed variable name
	jp	nc,ISVAR	;24ab
	cp	TKPLUS		;24ae - + token
	jr	z,EVAL		;24b0 - ignore any + token, jump back and keep parsing.
	cp	'.'		;24b2
	jp	z,FIN		;24b4
	cp	TKMNUS		;24b7 - - token
	jp	z,DOMIN		;24b9
	cp	DQUOTE		;24bc - " character
	jp	z,STRLTI	;24be
	cp	TKNOT		;24c1 - NOT token
	jp	z,NOTER		;24c3
	cp	'&'		;24c6
	jp	z,DVAND		;24c8 - & Disk Basic Vector
	cp	TKERR		;24cb
	jr	nz,NTERC	;24cd
	GETCHR			;24cf - rst 10h
	ld	a,(ERRFLG)	;24d0
	push	hl		;24d3
	call	SNGFLT		;24d4
	pop	hl		;24d7
	ret			;24d8
NTERC:	cp	TKERL		;24d9 - ERL token
	jr	nz,NTERL	;24db
	GETCHR			;24dd - rst 10h
	push	hl		;24de
	ld	hl,(ERRLIN)	;24df
	call	INEG2		;24e2
	pop	hl		;24e5
	ret			;24e6
; ----------------------------------------------------------------------
; 24E7-24FE VARPTR logic – “NTERL”
; ----------------------------------------------------------------------
NTERL:	cp	TKVARP		;24e7 - varptr
	jr	nz,NTVARP	;24e9
	GETCHR			;24eb - rst 10h
	SYNTAX	('(')		;24ec - rst 08h
	call	PTRGET		;24ee
VARRET:	SYNTAX	(')')		;24f1 - rst 08h
	push	hl		;24f3
	ex	de,hl		;24f4
	ld	a,h		;24f5
	or	l		;24f6
	jp	z,FCERR		;24f7
	call	MAKINT		;24fa - Move INT in HL into the ACCumulator
	pop	hl		;24fd
	ret			;24fe
; ----------------------------------------------------------------------
; 24FF – Other Function Routine – Jumped here if it wasn’t VARPTR to
; see what else it might have been – “NTVARP”
; ----------------------------------------------------------------------
NTVARP:	cp	TKUSR		;24ff - USR Function
	jp	z,USRFN		;2501
	cp	TKINST		;2504 - INSTR Function
	jp	z,DVINST	;2506
	cp	TKMEM		;2509 - MEM Function
	jp	z,MEM		;250b
	cp	TKTIME		;250e - TIME$
	jp	z,DVTIME	;2510
	cp	TKPOIN		;2513 - POINT
	jp	z,POINT		;2515
	cp	TKINKY		;2518 - INKEY$
	jp	z,INKEY		;251a
	cp	TKSTRG		;251d - STRING$
	jp	z,STRNGS	;251f
	cp	TKFN		;2522
	jp	z,DVFN		;2524 - FN Handler
	sub	TKSGN		;2527 - Is a function starting at SGN
	jp	nc,ISFUN	;2529 - Jump if is a SGN to MID$ token
; ----------------------------------------------------------------------
; 252CH – Other Function Routine – If we pass through to here, the only
; other possibility is that it is a function in parenthesis – “PARCHK”
;
; EVALUATE PARENTHESIZED EXPRESSION (TAS)
;   Call here to Evaluate a basic expression enclosed in parenthesis ()
; ----------------------------------------------------------------------
PARCHK:	call	FRMPRN		;252c - Evaluation expression starting with (
	SYNTAX	(')')		;252f - rst 08h = check for closing )
	ret			;2531
; ----------------------------------------------------------------------
; 2532 – Binary Minus Routine – “DOMIN”
; ----------------------------------------------------------------------
DOMIN:	ld	d,$7D		;2532
	call	LPOPER		;2534
	ld	hl,(TEMP2)	;2537
	push	hl		;253a
	call	VNEG		;253b
; ----------------------------------------------------------------------
; 253E - Return Site for Functions executed via Function Dispatch Table
; ----------------------------------------------------------------------
LABBCK:	pop	hl		;253e
	ret			;253f
; ----------------------------------------------------------------------
; 2540 – MATH ROUTINE – “ISVAR”
;   LOAD ACCUM WITH VALUE OF BASIC VARIABLE (TAS)
;   Get value of BASIC variable and put in ACCUM (also put precision of
;   variable in NFT) On entry HL mush point to first char of var name
;   On exit HL will point to first char following var name
; ----------------------------------------------------------------------
ISVAR:	call	PTRGET		;2540
RETVAR:	push	hl		;2543
	ex	de,hl		;2544
	ld	(FACLO),hl	;2545
	GETYPE			;2548 - RST 20 - check the current number type
	call	nz,VMOVFM	;2549
	pop	hl		;254c
	ret			;254d
; ----------------------------------------------------------------------
; 254E – This routine processes an expression for a Function Call – “ISFUN”
;   Function Calls are dispatched via the Function Dispatch table
;   and apply to tokens in the range SNG( to MID$(
; ----------------------------------------------------------------------
ISFUN:	ld	b,$00		;254e
	rlca			;2550 - Set A to be 2 * (token – D7H)
	ld	c,a		;2551
	push	bc		;2552
	GETCHR			;2553 - rst 10h
	ld	a,c		;2554
	;2555 - Test the adjusted token to see if it is past 2 * LASNUM – 2 * TKSGN + 1
	cp	$41
	jr	c,OKNORM	;2557 - Jump if the token is SGN( to CHR$(.
	call	FRMPRN		;2559 - If not, it is a LEFT$ – MID$
; ----------------------------------------------------------------------
	SYNTAX	(',')		;255c - rst 08h
	call	CHKSTR		;255e
	ex	de,hl		;2561
	ld	hl,(FACLO)	;2562
	ex	(sp),hl		;2565
	push	hl		;2566
	ex	de,hl		;2567
	call	GETBYT		;2568
	ex	de,hl		;256b
	ex	(sp),hl		;256c
	jr	FINGO		;256d
OKNORM:	call	PARCHK		;256f
	ex	(sp),hl		;2572
; ----------------------------------------------------------------------
	ld	a,l		;2573
	;2574 - Check to see if the operator token in Register A is one less than SQR - $0C
	cp	(TKSQR-TKSGN)*2
	jr	c,NOTFRF	;2576 - Jump to avoid forcing the argument if is SGN to SQR
	;2578 - Check to see if the operator token in Register A is bigger than ATN() - $1B
	cp	(TKATN-TKSGN)*2+1
	push	hl		;257a
	call	c,FRCSNG	;257b
	pop	hl		;257e
NOTFRF:	ld	de,LABBCK	;257f - address for once the function is executed
	push	de		;2582 - push address to stack for the RET in function
FINGO:	ld	bc,FUNDSP	;2583 - Base of the Function Dispatch Table
DISPAT:	add	hl,bc		;2586 - adding it to the function offset
	ld	c,(hl)		;2587 - load the address from the table
	inc	hl		;2588
	ld	h,(hl)		;2589
	ld	l,c		;258a - transferring the final address into hl
	jp	(hl)		;258b - JUMP to the Functions Code
; ----------------------------------------------------------------------
; 258C – Part of the Formula Evaluation Code – “STRCMP”
;   this routine will compare two strings, one with the description in
;   Register DE and the other in FACLO/FACLO+1. On exit:
;     A = 0 if the strings are equal
;     A = 377 if BC:DE > FACLO
;     A = 1 if BC:DE < FACLO
; ----------------------------------------------------------------------
STRCMP:	call	FRESTR		;258c
	ld	a,(hl)		;258f
	inc	hl		;2590
	ld	c,(hl)		;2591
	inc	hl		;2592
	ld	b,(hl)		;2593
	pop	de		;2594
	push	bc		;2595
	push	af		;2596
	call	FRETMP		;2597
	pop	de		;259a
	ld	e,(hl)		;259b
	inc	hl		;259c
	ld	c,(hl)		;259d
	inc	hl		;259e
	ld	b,(hl)		;259f
	pop	hl		;25a0
; ----------------------------------------------------------------------
; 25A1 - Compare 2 strings in Memory
;   On entry HL must point to String 1, while BC must point to string 2
;   the D and E registers must point to the lengths of string 1 and 2.
;   On exit A register will 0, 1, FF, with Z and C flags set accordingly
; ----------------------------------------------------------------------
CSLOOP:	ld	a,e		;25a1
	or	d		;25a2
	ret	z		;25a3
	ld	a,d		;25a4
	sub	$01		;25a5
	ret	c		;25a7
	xor	a		;25a8
	cp	e		;25a9
	inc	a		;25aa
	ret	nc		;25ab
	dec	d		;25ac
	dec	e		;25ad
	ld	a,(bc)		;25ae
	cp	(hl)		;25af
	inc	hl		;25b0
	inc	bc		;25b1
	jr	z,CSLOOP	;25b2
	ccf			;25b4
	jp	SIGNS		;25b5
DOCMP:	inc	a		;25b8
	adc	a,a		;25b9
	pop	bc		;25ba
	and	b		;25bb
	add	a,$FF		;25bc
	sbc	a,a		;25be
	call	CONIA		;25bf
	jr	RETAPG		;25c2
; ----------------------------------------------------------------------
; 25C4 – NOT Routine – “NOTER”
; ----------------------------------------------------------------------
NOTER:	ld	d,$5A		;25c4
	call	LPOPER		;25c6
	call	FRCINT		;25c9
	ld	a,l		;25cc
	cpl			;25cd
	ld	l,a		;25ce
	ld	a,h		;25cf
	cpl			;25d0
	ld	h,a		;25d1
	ld	(FACLO),hl	;25d2
	pop	bc		;25d5
RETAPG:	jp	RETAOP		;25d6
;
; ======================================================================
; 25D9 – The RST 20H code – “GETYPR” - GETYPE
;
;   This determines the type of the current
;   value in ACCumulator and returns a combination of STATUS flags and
;   unique numeric values in the A Register according to the data mode flag (40AFH).
;      TYPE   CODE   ZERO   CARRY   NEG   PARITY   A-Register
;      INT     02     NZ      C      N      E         -1
;      STR     03      Z      C      P      E          0
;      SNG     04     NZ      C      P      O          1
;      DBL     08     NZ     NC      P      E          5
; ----------------------------------------------------------------------
GETYPR:	ld	a,(VALTYP)	;25d9
	cp	VTDBL		;25dc - compare with Double Precision
	jr	nc,NCASE	;25de - If double precision
	sub	VTSTR		;25e0 - adjust -1=Int, 0=String, 1=Single
	or	a		;25e2 - Set the status flags of the adjusted number type flag
	scf			;25e3 - and Set Carry
	ret			;25e4
NCASE:	sub	VTSTR		;25e5 - If Double adjust = 5
	or	a		;25e7 - And set DBL Flags
	ret			;25e8
; ----------------------------------------------------------------------
; 25E9 – AND and OR Routines – “DANDOR”
;   this routine applies the AND
;   and OR operators and should be used to implement all logical operators
;   Whenever an operator is applied, its precedence is in Register B
;   This fact is used to distinguish between AND and OR
; ----------------------------------------------------------------------
DANDOR:	push	bc		;25e9
	call	FRCINT		;25ea
	pop	af		;25ed
	pop	de		;25ee
	ld	bc,GIVINT	;25ef
	push	bc		;25f2
	cp	$46		;25f3
	jr	nz,NOTOR	;25f5
; ----------------------------------------------------------------------
; 25F7 – OR logic.
; ----------------------------------------------------------------------
	ld	a,e		;25f7
	or	l		;25f8
	ld	l,a		;25f9
	ld	a,h		;25fa
	or	d		;25fb
	ret			;25fc
; ----------------------------------------------------------------------
; 25FD – AND logic – “NOTOR”
; ----------------------------------------------------------------------
NOTOR:	ld	a,e		;25fd
	and	l		;25fe
	ld	l,a		;25ff
	ld	a,h		;2600
	and	d		;2601
	ret			;2602
;
; ----------------------------------------------------------------------
; 2603 – Dimension and Variable Searching Routine – “DIMCON”
; ----------------------------------------------------------------------
DIMCON:	dec	hl		;2603
	GETCHR			;2604 - rst 10h
	ret	z		;2605
	SYNTAX	(',')		;2606 - rst 08h
;
; ----------------------------------------------------------------------
; 2608 – DIM logic – “DIM”
;   The original ROM source code states that this DIM code sets DIMFLG
;   and then falls into the variable search routine, which then looks
;   at DIMFLG at three different points:
; ----------------------------------------------------------------------
DIM:	ld	bc,DIMCON	;2608
	push	bc		;260b
;
	DEFB	ORNN		;260c - Z80 Trick - OR nn - causes NZ flag - skip next instruction
;
; ----------------------------------------------------------------------
; 260D – LOCATE OR CREATE A BASIC VARIABLE
;   Variable location and creation logic – “PTRGET”
;   locate storage area for existing variable if not exists will create
;   On entry HL must point to first char of variable name
;   On exit HL will point to next char after var name
;   and DE will point to the address of the variable storage
; ----------------------------------------------------------------------
PTRGET:	xor	a		;260d
	ld	(DIMFLG),a	;260e
	ld	b,(hl)		;2611
	call	ISLET		;2612
	jp	c,SNERR		;2615
	xor	a		;2618
	ld	c,a		;2619
	GETCHR			;261a - rst 10h
	jr	c,ISSEC		;261b
	call	ISLET		;261d
	jr	c,NOSEC		;2620
ISSEC:	ld	c,a		;2622
EATEM:	GETCHR			;2623 - rst 10h
	jr	c,EATEM		;2624
	call	ISLET		;2626
	jr	nc,EATEM	;2629
NOSEC:	ld	de,HAVTYP	;262b
	push	de		;262e - Save return address HAVTYP to stack
	ld	d,VTINT		;262f - Integer Value Type
	cp	'%'		;2631 - % Integer data type
	ret	z		;2633
	inc	d		;2634 - String Value type
	cp	'$'		;2635 - $ String data type
	ret	z		;2637
	inc	d		;2638 - Single Precision Value type
	cp	'!'		;2639 - ! Single precision
	ret	z		;263b
	ld	d,VTDBL		;263c - double value type = 8
	cp	'#'		;263e - # Double data type
	ret	z		;2640
	ld	a,b		;2641 - first character of the variable name
	sub	'A'		;2642 - Adjust so that it is 0 to 25 for a table offset
	and	$7F		;2644 - Get rid of the user-defined function bit
	ld	e,a		;2646
	ld	d,$00		;2647 - DE now contains the table offset
	push	hl		;2649
	ld	hl,DEFTBL	;264a - address of the variable declaration table.
	add	hl,de		;264d - Add the offset to the top of the table
	ld	d,(hl)		;264e - the number type from the variable declaration table
	pop	hl		;264f
	dec	hl		;2650
	ret			;2651
HAVTYP:	ld	a,d		;2652 - the number type
	ld	(VALTYP),a	;2653 - save the num type flag
	GETCHR			;2656 - rst 10h
	ld	a,(SUBFLG)	;2657 - Load the FOR flag
	or	a		;265a - set the Flags
	jp	nz,NOARYS	;265b
	ld	a,(hl)		;265e
	sub	'('		;265f - '(' - test for an array
	jp	z,ISARY		;2661
NOARYS:	xor	a		;2664
	ld	(SUBFLG),a	;2665 - Set the "permit arrays" array flag to 'no subscript'.
	push	hl		;2668
	push	de		;2669
	ld	hl,(VARTAB)	;266a
LOPFND:	ex	de,hl		;266d
	ld	hl,(ARYTAB)	;266e
	CPDEHL			;2671
	pop	hl		;2672
	jr	z,NOTFNS	;2673
	ld	a,(de)		;2675
	ld	l,a		;2676
	cp	h		;2677
	inc	de		;2678
	jr	nz,NOTIT1	;2679
	ld	a,(de)		;267b
	cp	c		;267c
	jr	nz,NOTIT1	;267d
	inc	de		;267f
	ld	a,(de)		;2680
	cp	b		;2681
	jp	z,FINPTR	;2682
;
	DEFB	LDANN		;2685 - Z80 Trick - LD a,nn - and skip next byte
;
NOTIT1:	inc	de		;2686
	inc	de		;2687
	push	hl		;2688
	ld	h,$00		;2689
	add	hl,de		;268b
	jr	LOPFND		;268c
NOTFNS:	ld	a,h		;268e
	pop	hl		;268f
	ex	(sp),hl		;2690
	push	af		;2691
	push	de		;2692
	ld	de,VARRET	;2693
	CPDEHL			;2696
	jr	z,VARNOT	;2697
	ld	de,RETVAR	;2699
	CPDEHL			;269c
	pop	de		;269d
	jr	z,FINZER	;269e
	pop	af		;26a0
	ex	(sp),hl		;26a1
	push	hl		;26a2
	push	bc		;26a3
	ld	c,a		;26a4
	ld	b,$00		;26a5
	push	bc		;26a7
	inc	bc		;26a8
	inc	bc		;26a9
	inc	bc		;26aa
	ld	hl,(STREND)	;26ab
	push	hl		;26ae
	add	hl,bc		;26af
	pop	bc		;26b0
	push	hl		;26b1
	call	BLTU		;26b2
	pop	hl		;26b5
	ld	(STREND),hl	;26b6
	ld	h,b		;26b9
	ld	l,c		;26ba
	ld	(ARYTAB),hl	;26bb
ZEROER:	dec	hl		;26be
	ld	(hl),$00	;26bf
	CPDEHL			;26c1
	jr	nz,ZEROER	;26c2
	pop	de		;26c4
	ld	(hl),e		;26c5
	inc	hl		;26c6
	pop	de		;26c7
	ld	(hl),e		;26c8
	inc	hl		;26c9
	ld	(hl),d		;26ca
	ex	de,hl		;26cb
FINPTR:	inc	de		;26cc
	pop	hl		;26cd
	ret			;26ce
VARNOT:	ld	d,a		;26cf
	ld	e,a		;26d0
	pop	af		;26d1
	pop	af		;26d2
	ex	(sp),hl		;26d3
	ret			;26d4
;
; ----------------------------------------------------------------------
; 26D5 – This routine is ZERO out all variable types and skip any RETurn – “FINZER”
; ----------------------------------------------------------------------
FINZER:	ld	(FAC),a		;26d5
	pop	bc		;26d8
	ld	h,a		;26d9
	ld	l,a		;26da
	ld	(FACLO),hl	;26db
	GETYPE			;26de - RST 20 - check the current number type
	jr	nz,POPHR2	;26df
	ld	hl,m_REDDY-1	;26e1
	ld	(FACLO),hl	;26e4
POPHR2:	pop	hl		;26e7
	ret			;26e8
; ----------------------------------------------------------------------
; 26E9 – This routine handles a subscripted variables – “ISARY”
;   On entry D = the type of variable, B = the 1st character of the variable name,
;   C = the 2nd character of the variable name, and HL = the current position
;   in the input string.
; ----------------------------------------------------------------------
ISARY:	push	hl		;26e9
	ld	hl,(DIMFLG)	;26ea
	ex	(sp),hl		;26ed
	ld	d,a		;26ee
INDLOP:	push	de		;26ef
	push	bc		;26f0
	call	INTIDX		;26f1
	pop	bc		;26f4
	pop	af		;26f5
	ex	de,hl		;26f6
	ex	(sp),hl		;26f7
	push	hl		;26f8
	ex	de,hl		;26f9
	inc	a		;26fa
	ld	d,a		;26fb
	ld	a,(hl)		;26fc
	cp	','		;26fd
	jr	z,INDLOP	;26ff
	SYNTAX	(')')		;2701 - rst 08h
	ld	(TEMP2),hl	;2703
	pop	hl		;2706
	ld	(DIMFLG),hl	;2707
	push	de		;270a
	ld	hl,(ARYTAB)	;270b
;
	DEFB	LDANN		;270d - Z80 Trick - LD A,nn - skipping next byte
;
LOPFDA:	add	hl,de		;270f
	ex	de,hl		;2710
	ld	hl,(STREND)	;2711
	ex	de,hl		;2714
	CPDEHL			;2715
	ld	a,(VALTYP)	;2716
	jr	z,NOTFDD	;2719
	cp	(hl)		;271b
	inc	hl		;271c
	jr	nz,NMARY2	;271d
	ld	a,(hl)		;271f
	cp	c		;2720
	inc	hl		;2721
	jr	nz,NMARY1	;2722
	ld	a,(hl)		;2724
	cp	b		;2725
;
	DEFB	LDANN		;2726 - Z80 Trick - LD A,nn - skipping next byte
;
NMARY2:	inc	hl		;2727
NMARY1:	inc	hl		;2728
	ld	e,(hl)		;2729
	inc	hl		;272a
	ld	d,(hl)		;272b
	inc	hl		;272c
	jr	nz,LOPFDA	;272d
	ld	a,(DIMFLG)	;272f
	or	a		;2732
	ld	e,ERRDD		;2733
	jp	nz,ERROR	;2735
	pop	af		;2738
	sub	(hl)		;2739
	jp	z,GETDEF	;273a
; ----------------------------------------------------------------------
; 273DH – ?BS ERROR ENTRY POINT – “BSERR”
; ----------------------------------------------------------------------
BSERR:	ld	e,ERRBS		;273d
	jp	ERROR		;273f
; ----------------------------------------------------------------------
; 2742 – Part of the ARRAY routines. – “NOTFDD”
;   Jumped here when a variable isn’t found in the ARRAY table
; -----------------------------------------------------------------------
NOTFDD:	ld	(hl),a		;2742
	inc	hl		;2743
	ld	e,a		;2744
	ld	d,$00		;2745
	pop	af		;2747
	ld	(hl),c		;2748
	inc	hl		;2749
	ld	(hl),b		;274a
	inc	hl		;274b
	ld	c,a		;274c
	call	GETSTK		;274d
	inc	hl		;2750
	inc	hl		;2751
	ld	(TEMP3),hl	;2752
	ld	(hl),c		;2755
	inc	hl		;2756
	ld	a,(DIMFLG)	;2757
	rla			;275a
	ld	a,c		;275b
LOPPTA:	ld	bc,$000B	;275c - Top of a loop assuming we did not get here from "DIM". Load BC with the default number of 11, which is the most entries an array can have without a DIM
	jr	nc,NOTDIM	;275f
	pop	bc		;2761
	inc	bc		;2762
NOTDIM:	ld	(hl),c		;2763
	inc	hl		;2764
	ld	(hl),b		;2765
	inc	hl		;2766
	push	af		;2767
	call	UMULT		;2768
	pop	af		;276b
	dec	a		;276c
	jr	nz,LOPPTA	;276d
	push	af		;276f
	ld	b,d		;2770
	ld	c,e		;2771
	ex	de,hl		;2772
	add	hl,de		;2773
	jr	c,BSERR		;2774
	call	REASON		;2776
	ld	(STREND),hl	;2779
ZERITA:	dec	hl		;277c
	ld	(hl),$00	;277d
	CPDEHL			;277f
	jr	nz,ZERITA	;2780
	inc	bc		;2782
	ld	d,a		;2783
	ld	hl,(TEMP3)	;2784
	ld	e,(hl)		;2787
	ex	de,hl		;2788
	add	hl,hl		;2789
	add	hl,bc		;278a
	ex	de,hl		;278b
	dec	hl		;278c
	dec	hl		;278d
	ld	(hl),e		;278e
	inc	hl		;278f
	ld	(hl),d		;2790
	inc	hl		;2791
	pop	af		;2792
	jr	c,FINNOW	;2793
; -----------------------------------------------------------------------
; At this point, HL points beyond the SIZE of the array
; to the NUMBER OF DIMENSIONS in the array.
; -----------------------------------------------------------------------
GETDEF:	ld	b,a		;2795
	ld	c,a		;2796
	ld	a,(hl)		;2797
	inc	hl		;2798
;
	DEFB	LDDNN		;2799 - Z80 Trick - LD D,nn - skipping next byte
;
INLPNM:	pop	hl		;279a
	ld	e,(hl)		;279b
	inc	hl		;279c
	ld	d,(hl)		;279d
	inc	hl		;279e
	ex	(sp),hl		;279f
	push	af		;27a0
	CPDEHL			;27a1
	jp	nc,BSERR	;27a2
	call	UMULT		;27a5
	add	hl,de		;27a8
	pop	af		;27a9
	dec	a		;27aa
	ld	b,h		;27ab
	ld	c,l		;27ac
	jr	nz,INLPNM	;27ad
	ld	a,(VALTYP)	;27af
	ld	b,h		;27b2
	ld	c,l		;27b3
	add	hl,hl		;27b4
	sub	VTSNG		;27b5 - Compare with Single Precision
	jr	c,DMLVAL	;27b7 - If it is an Integer or String
	add	hl,hl		;27b9
	jr	z,DONMUL	;27ba
	add	hl,hl		;27bc
DMLVAL:	or	a		;27bd
	jp	po,DONMUL	;27be
	add	hl,bc		;27c1
DONMUL:	pop	bc		;27c2
	add	hl,bc		;27c3
	ex	de,hl		;27c4
FINNOW:	ld	hl,(TEMP2)	;27c5
	ret			;27c8
; ----------------------------------------------------------------------
; 27C9-27D3 – LEVEL II BASIC MEM ROUTINE – “MEM”
;   This is the RETURN AMOUNT OF FREE MEMORY routine at 27C9H which computes
;   the amount of memory remaining between the end of the variable list
;   and the end of the STACK and puts the result in ACCumulator
;   as a SINGLE PRECISION number.
; ----------------------------------------------------------------------
MEM:	xor	a		;27c9
	push	hl		;27ca
	ld	(VALTYP),a	;27cb
	call	FNFRE		;27ce
	pop	hl		;27d1
	GETCHR			;27d2 - rst 10h
	ret			;27d3
; ----------------------------------------------------------------------
; 27D4-27F4 – LEVEL II BASIC FRE ROUTINE – “FNFRE”
; ----------------------------------------------------------------------
FNFRE:	ld	hl,(STREND)	;27d4
	ex	de,hl		;27d7
	ld	hl,$0000	;27d8
	add	hl,sp		;27db
	GETYPE			;27dc - RST 20 - check the current number type
	jr	nz,GIVDBL	;27dd
; ----------------------------------------------------------------------
; 27DF - Get number of bytes free string space to ACCUM (TAS)
; ----------------------------------------------------------------------
	call	FREFAC		;27df
	call	GARBA2		;27e2
	ld	hl,(STKTOP)	;27e5
	ex	de,hl		;27e8
	ld	hl,(FRETOP)	;27e9
GIVDBL:	ld	a,l		;27ec
	sub	e		;27ed
	ld	l,a		;27ee
	ld	a,h		;27ef
	sbc	a,d		;27f0
	ld	h,a		;27f1
	jp	INEG2		;27f2
; ----------------------------------------------------------------------
; 27F5-27FD – LEVEL II BASIC POS() ROUTINE – “FNPOS”
; ----------------------------------------------------------------------
FNPOS:
	ld	a,(TTYPOS)	;27f5 - Load A with the current cursor line position.
SNGFLT:	ld	l,a		;27f8 - Load Value into L
	xor	a		;27f9 - Zero A
GIVINT:	ld	h,a		;27fa - HL now contains the INT Value
	jp	MAKINT		;27fb - Move INT in HL into the ACCumulator
; ----------------------------------------------------------------------
; 27FE-2818 – LEVEL II BASIC USR(x) ROUTINE – “USRFN”
; ----------------------------------------------------------------------
USRFN:	call	USROUT		;27fe - dos usr n handling
	GETCHR			;2801 - rst 10h
	call	PARCHK		;2802
	push	hl		;2805
	ld	hl,POPHRT	;2806 - Routine to Pop HL and Return
	push	hl		;2809 - Save as return address
	ld	a,(VALTYP)	;280a
	push	af		;280d
	cp	VTSTR		;280e - Compare value type - is it a String
	call	z,FREFAC	;2810
	pop	af		;2813
	ex	de,hl		;2814
	ld	hl,(USRTAB)	;2815
	jp	(hl)		;2818
; ----------------------------------------------------------------------
; 2819-2827 – MATH CONVERSION ROUTINE– “DOCNVF”
;   Usually called by LET to convert the result of arithmetic
;   routines to the proper destination type.
; ----------------------------------------------------------------------
DOCNVF:	push	hl		;2819
	and	$07		;281a
	ld	hl,FRCTBL	;281c - Operation Converation Table
	ld	c,a		;281f
	ld	b,$00		;2820
	add	hl,bc		;2822
	call	DISPAT		;2823
	pop	hl		;2826
	ret			;2827
; ----------------------------------------------------------------------
; 2828-2835 – Routine to see if we are in DIRECT MODE and ERROR OUT if so – “ERRDIR”
;   Usually called from the INPUT routine. On entry HL has the current line number in binary.
; ----------------------------------------------------------------------
ERRDIR:	push	hl		;2828
	ld	hl,(CURLIN)	;2829
	inc	hl		;282c
	ld	a,h		;282d
	or	l		;282e
	pop	hl		;282f
	ret	nz		;2830
; ----------------------------------------------------------------------
; 2831H – ID? ERROR ENTRY POINT - "IDERR"
; ----------------------------------------------------------------------
IDERR:	ld	e,ERRID		;2831
	jp	ERROR		;2833
; ----------------------------------------------------------------------
; 2836-2856 – STRING ROUTINE – STR$ logic– “FNSTR”
;   Convert number in ACCUM to string.
;   On entry, the number to be converted to a string must be in the ACCUM
;   with the NTF set appropriately. PUSH the return address onto the
;   stack, PUSH HL, and BC (HL and BC are restored on exit from the
;   routine) . Then jump to 2836H (don't CALL).
;   On exit the VARPTR to the string created by this routine will be
;   found in the ACCUM, with the NTF set to 3
; ----------------------------------------------------------------------
FNSTR:	call	FOUT		;2836
	call	STRLIT		;2839
	call	FREFAC		;283c
	ld	bc,FINBCK	;283f
	push	bc		;2842
; ----------------------------------------------------------------------
; The next routine, STRCPY, creates a copy of the string pointed to by
; Reg Pair HL. On exit, DE points to DSCTMP which has the string info.
; ----------------------------------------------------------------------
STRCPY:	ld	a,(hl)		;2843
	inc	hl		;2844
	push	hl		;2845
	call	GETSPA		;2846
	pop	hl		;2849
	ld	c,(hl)		;284a
	inc	hl		;284b
	ld	b,(hl)		;284c
	call	STRAD2		;284d
	push	hl		;2850
	ld	l,a		;2851
	call	MOVSTR		;2852
	pop	de		;2855
	ret			;2856
; ----------------------------------------------------------------------
; 2857-2864 – STRING ROUTINE– “STRINI”
; ----------------------------------------------------------------------
STRINI:	call	GETSPA		;2857
STRAD2:	ld	hl,DSCTMP	;285a
	push	hl		;285d
	ld	(hl),a		;285e
	inc	hl		;285f
	ld	(hl),e		;2860
	inc	hl		;2861
	ld	(hl),d		;2862
	pop	hl		;2863
	ret			;2864
; ----------------------------------------------------------------------
; 2865-28A5 – STRING ROUTINE– “STRLIT”
;   STRLT2 takes the string literal whose first character is pointed by HL+1
;   and builds a descriptor for it. Leading quotes should be skipped before
;   the CALL to this routine.
; ----------------------------------------------------------------------
STRLIT:	dec	hl		;2865
STRLTI:	ld	b,DQUOTE	;2866
	ld	d,b		;2868
STRLT2:	push	hl		;2869
	ld	c,$FF		;286a
STRGET:	inc	hl		;286c
	ld	a,(hl)		;286d
	inc	c		;286e
	or	a		;286f
	jr	z,STRFIN	;2870
	cp	d		;2872
	jr	z,STRFIN	;2873
	cp	b		;2875
	jr	nz,STRGET	;2876
STRFIN:	cp	DQUOTE		;2878
	call	z,CHRGTR	;287a
	ex	(sp),hl		;287d
	inc	hl		;287e
	ex	de,hl		;287f
	ld	a,c		;2880
	call	STRAD2		;2881
PUTNEW:	ld	de,DSCTMP	;2884
;
       	DEFB	LDANN		;2887 - Z80 Trick LD A,nn - skip next instruction - load it into A
;
; ----------------------------------------------------------------------
; PUTTMP - A JUMP point in DOS Basic to process a new string in the
; DEF FN routine. When JUMPed to 2888H, a PUSH DE is processed
; ----------------------------------------------------------------------
PUTTMP:
	push	de		;2888 - Save a pointer to the stat of the string to the STACK
;
	ld	hl,(TEMPPT)	;2889
	ld	(FACLO),hl	;288c
	ld	a,VTSTR		;288f - value type String
	ld	(VALTYP),a	;2891
	call	VMOVE		;2894
	ld	de,FRETOP	;2897
	CPDEHL			;289a
	ld	(TEMPPT),hl	;289b
	pop	hl		;289e
	ld	a,(hl)		;289f
	ret	nz		;28a0
; ----------------------------------------------------------------------
; 28A1H – ST? ERROR ENTRY POINT - "STERR"
; ----------------------------------------------------------------------
STERR:	ld	e,ERRST		;28a1
	jp	ERROR		;28a3
;
; ----------------------------------------------------------------------
; 28A6-28BE – DISPLAY MESSAGE ROUTINE– “STROUI”
;
;   this routine will print the string pointed to by Register Pair HL.
;   The string MUST be terminated by a 00H. If the string exists below DSCTMP,
;   then it is copied into string space first.
;
;   this routine will print the string
;   pointed to by Register Pair HL. The string MUST be terminated by a 00H.
;   If the string exists below DSCTMP, then it is copied into string space first.
; ----------------------------------------------------------------------
;
STROUI:	inc	hl		;28a6
;
STROUT:	call	STRLIT		;28a7
;
STRPRT:	call	FREFAC		;28aa
	call	GETBCD		;28ad
	inc	d		;28b0
STRPR2:	dec	d		;28b1
	ret	z		;28b2
	ld	a,(bc)		;28b3
	call	OUTDO		;28b4
	cp	ENTER		;28b7
	call	z,CRFIN		;28b9
	inc	bc		;28bc
	jr	STRPR2		;28bd
;
; ----------------------------------------------------------------------
; 28BF-28D9 – STRING ROUTINE– “GETSPA”
; ----------------------------------------------------------------------
GETSPA:	or	a		;28bf
;
	DEFB	LDCNN		;28c0 - Z80 Trick - LD C,nn - skipping next byte
;
TRYGI2:	pop	af		;28c1
	push	af		;28c2
	ld	hl,(STKTOP)	;28c3
	ex	de,hl		;28c6
	ld	hl,(FRETOP)	;28c7
	cpl			;28ca
	ld	c,a		;28cb
	ld	b,$FF		;28cc
	add	hl,bc		;28ce
	inc	hl		;28cf
	CPDEHL			;28d0
	jr	c,GARBAG	;28d1
	ld	(FRETOP),hl	;28d3
	inc	hl		;28d6
	ex	de,hl		;28d7
PPSWRT:	pop	af		;28d8
	ret			;28d9
; ----------------------------------------------------------------------
; 28DA-298E – STRING ROUTINE – “GARBAG”
; ----------------------------------------------------------------------
GARBAG:	pop	af		;28da
	ld	e,ERROS		;28db
	jp	z,ERROR		;28dd
	cp	a		;28e0
	push	af		;28e1
	ld	bc,TRYGI2	;28e2 - push address
	push	bc		;28e5
GARBA2:	ld	hl,(MEMSIZ)	;28e6
FNVVAR:	ld	(FRETOP),hl	;28e9
	ld	hl,$0000	;28ec
	push	hl		;28ef
	ld	hl,(STKTOP)	;28f0
	push	hl		;28f3
	ld	hl,TEMPST	;28f4
TVAR:	ex	de,hl		;28f7
	ld	hl,(TEMPPT)	;28f8
	ex	de,hl		;28fb
	CPDEHL			;28fc
	ld	bc,TVAR		;28fd
	jp	nz,DVAR2	;2900
	ld	hl,(VARTAB)	;2903
SVAR:	ex	de,hl		;2906
	ld	hl,(ARYTAB)	;2907
	ex	de,hl		;290a
	CPDEHL			;290b
	jr	z,ARYVAR	;290c
	ld	a,(hl)		;290e
	inc	hl		;290f
	inc	hl		;2910
	inc	hl		;2911
	cp	$03		;2912
	jr	nz,SKPVAR	;2914
	call	DVAR		;2916
	xor	a		;2919
SKPVAR:	ld	e,a		;291a
	ld	d,$00		;291b
	add	hl,de		;291d
	jr	SVAR		;291e
ARYVA2:	pop	bc		;2920
ARYVAR:	ex	de,hl		;2921
	ld	hl,(STREND)	;2922
	ex	de,hl		;2925
	CPDEHL			;2926
	jp	z,GRBPAS	;2927
	ld	a,(hl)		;292a
	inc	hl		;292b
	call	MOVRM		;292c
	push	hl		;292f
	add	hl,bc		;2930
	cp	$03		;2931
	jr	nz,ARYVA2	;2933
	ld	(TEMP3),hl	;2935
	pop	hl		;2938
	ld	c,(hl)		;2939 - Load C with num of subscripts for the array HL pointer
	ld	b,$00		;293a - Zero B so that BC holds the number of dimensions
	add	hl,bc		;293c
	add	hl,bc		;293d
	inc	hl		;293e
ARYSTR:	ex	de,hl		;293f
	ld	hl,(TEMP3)	;2940
	ex	de,hl		;2943
	CPDEHL			;2944
	jr	z,ARYVAR	;2945
	ld	bc,ARYSTR	;2947
DVAR2:	push	bc		;294a
DVAR:	xor	a		;294b
	or	(hl)		;294c
	inc	hl		;294d
	ld	e,(hl)		;294e
	inc	hl		;294f
	ld	d,(hl)		;2950
	inc	hl		;2951
	ret	z		;2952
	ld	b,h		;2953
	ld	c,l		;2954
	ld	hl,(FRETOP)	;2955
	CPDEHL			;2958
	ld	h,b		;2959
	ld	l,c		;295a
	ret	c		;295b
	pop	hl		;295c
	ex	(sp),hl		;295d
	CPDEHL			;295e
	ex	(sp),hl		;295f
	push	hl		;2960
	ld	h,b		;2961
	ld	l,c		;2962
	ret	nc		;2963
	pop	bc		;2964
	pop	af		;2965
	pop	af		;2966
	push	hl		;2967
	push	de		;2968
	push	bc		;2969
	ret			;296a
;
GRBPAS:	pop	de		;296b
	pop	hl		;296c
	ld	a,l		;296d
	or	h		;296e
	ret	z		;296f
	dec	hl		;2970
	ld	b,(hl)		;2971
	dec	hl		;2972
	ld	c,(hl)		;2973
	push	hl		;2974
	dec	hl		;2975
	ld	l,(hl)		;2976
	ld	h,$00		;2977
	add	hl,bc		;2979
	ld	d,b		;297a
	ld	e,c		;297b
	dec	hl		;297c
	ld	b,h		;297d
	ld	c,l		;297e
	ld	hl,(FRETOP)	;297f
	call	BLTUC		;2982
	pop	hl		;2985
	ld	(hl),c		;2986
	inc	hl		;2987
	ld	(hl),b		;2988
	ld	l,c		;2989
	ld	h,b		;298a
	dec	hl		;298b
	jp	FNVVAR		;298c
; ----------------------------------------------------------------------
; 298F-29C5 – STRING ADDITION ROUTINE – Concatenate two strings – “CAT”
; ----------------------------------------------------------------------
CAT:	push	bc		;298f
	push	hl		;2990
	ld	hl,(FACLO)	;2991
	ex	(sp),hl		;2994
	call	EVAL		;2995
	ex	(sp),hl		;2998
	call	CHKSTR		;2999
; ----------------------------------------------------------------------
; 299C - Concatenate 2 Strings (TAS)
;   On entry, the stack must be prepared as follows.
;   PUSH the return address on the stack, PUSH BC and HL
;   (BC and HL will be restored on exit from the routine).
;   The HL register must contain the VARPTR for string number 1, and
;   the ACCUM must contain the VARPTR for string number 2 (NTF must
;   contain the value of 3). Then jump to 299CH (don't CALL).
;   On exit, the VARPTR to the string created by this routine
;   will be found in the ACCUM, with the NTF set to 3.
; ----------------------------------------------------------------------
	ld	a,(hl)		;299c
	push	hl		;299d
	ld	hl,(FACLO)	;299e
	push	hl		;29a1
	add	a,(hl)		;29a2
	ld	e,ERRLS		;29a3
	jp	c,ERROR		;29a5
	call	STRINI		;29a8
	pop	de		;29ab
	call	FRETMP		;29ac
	ex	(sp),hl		;29af
	call	FRETM2		;29b0
	push	hl		;29b3
	ld	hl,(DSCTMP+1)	;29b4
	ex	de,hl		;29b7
	call	MOVINS		;29b8
	call	MOVINS		;29bb
	ld	hl,TSTOP	;29be
	ex	(sp),hl		;29c1
	push	hl		;29c2
	jp	PUTNEW		;29c3
; ----------------------------------------------------------------------
; 29C6 – STRING ROUTINE – This will move strings using the STACK – “MOVINS”
; ----------------------------------------------------------------------
MOVINS:	pop	hl		;29c6
	ex	(sp),hl		;29c7
; ----------------------------------------------------------------------
; 29C8-29D6 – STRING ROUTINE - This will move string using registers - 'MOVREG'
;   On entry HL points to the string control block for the string to be moved,
;   and DE contains the destination address. All registers are used.
;   The string length and address are not moved. String control blocks
;   have the format: X=String Length; ADDR = String Address.
; ----------------------------------------------------------------------
MOVREG:	ld	a,(hl)		;29c8
	inc	hl		;29c9
	ld	c,(hl)		;29ca
	inc	hl		;29cb
	ld	b,(hl)		;29cc
	ld	l,a		;29cd
MOVSTR:	inc	l		;29ce
MOVLP:	dec	l		;29cf
	ret	z		;29d0
	ld	a,(bc)		;29d1
	ld	(de),a		;29d2
	inc	bc		;29d3
	inc	de		;29d4
	jr	MOVLP		;29d5
; ----------------------------------------------------------------------
; 29D7-29F4 – STRING ROUTINE – “FRESTR”
;
;   This routine makes the HL register pair point to the first
;   of the three bytes containing string length followed by the string address
; ----------------------------------------------------------------------
FRESTR:	call	CHKSTR		;29d7
FREFAC:	ld	hl,(FACLO)	;29da
FRETM2:	ex	de,hl		;29dd
;
;   FRETMP is passed a pointer to a string descriptor in Register Pair DE
;   and is returned in Register Pair HL. All the other registers are modified.
;
FRETMP:	call	FRETMS		;29de
	ex	de,hl		;29e1
	ret	nz		;29e2
	push	de		;29e3
	ld	d,b		;29e4
	ld	e,c		;29e5
	dec	de		;29e6
	ld	c,(hl)		;29e7
	ld	hl,(FRETOP)	;29e8
	CPDEHL			;29eb
	jr	nz,NOTLST	;29ec
	ld	b,a		;29ee
	add	hl,bc		;29ef
	ld	(FRETOP),hl	;29f0
NOTLST:	pop	hl		;29f3
	ret			;29f4
; ----------------------------------------------------------------------
; ----------------------------------------------------------------------
FRETMS:	ld	hl,(TEMPPT)	;29f5
	dec	hl		;29f8
	ld	b,(hl)		;29f9
	dec	hl		;29fa
	ld	c,(hl)		;29fb
	dec	hl		;29fc
	CPDEHL			;29fd
	ret	nz		;29fe
	ld	(TEMPPT),hl	;29ff
	ret			;2a02
; ----------------------------------------------------------------------
; 2A03-2A0E – LEVEL II BASIC LEN ROUTINE– “FNLEN”
;   Get length (number of bytes) of a string to ACCUM
; ----------------------------------------------------------------------
FNLEN:	ld	bc,SNGFLT	;2a03
	push	bc		;2a06
LEN1:	call	FRESTR		;2a07
	xor	a		;2a0a
	ld	d,a		;2a0b
	ld	a,(hl)		;2a0c
	or	a		;2a0d
	ret			;2a0e
; ----------------------------------------------------------------------
; 2A0F-2A1E – LEVEL II BASIC ASC ROUTINE – “FNASC”
;   Get ASCII value of first character of string to ACCUM
; ----------------------------------------------------------------------
FNASC:	ld	bc,SNGFLT	;2a0f
	push	bc		;2a12
ASC2:	call	LEN1		;2a13
	jp	z,FCERR		;2a16
	inc	hl		;2a19
	ld	e,(hl)		;2a1a
	inc	hl		;2a1b
	ld	d,(hl)		;2a1c
	ld	a,(de)		;2a1d
	ret			;2a1e
; ----------------------------------------------------------------------
; 2A1F-2A2E – LEVEL II BASIC CHR$ ROUTINE – “FNCHR”
;   Make a one - character string - ASCII value in ACCUM
; ----------------------------------------------------------------------
FNCHR:	ld	a,$01		;2a1f
	call	STRINI		;2a21
	call	CONINT		;2a24
	ld	hl,(DSCTMP+1)	;2a27
	ld	(hl),e		;2a2a
FINBCK:	pop	bc		;2a2b
	jp	PUTNEW		;2a2c
; ----------------------------------------------------------------------
; 2A2F-2A60 – LEVEL II BASIC STRING$ ROUTINE – “STRNGS”
; ----------------------------------------------------------------------
STRNGS:	GETCHR			;2a2f - rst 10h
	SYNTAX	('(')		;2a30 - rst 08h
	call	GETBYT		;2a32
	push	de		;2a35
	SYNTAX	(',')		;2a36 - rst 08h
	call	FRMEVL		;2a38
	SYNTAX	(')')		;2a3b - rst 08h
; ----------------------------------------------------------------------
; 2A3D - Make a string of multiple bytes of one character (TAS)
; ----------------------------------------------------------------------
	ex	(sp),hl		;2a3d
	push	hl		;2a3e
	GETYPE			;2a3f - RST 20 - check the current number type
	jr	z,STRSTR	;2a40
	call	CONINT		;2a42
	jr	CALSPA		;2a45
STRSTR:	call	ASC2		;2a47
CALSPA:	pop	de		;2a4a
	push	af		;2a4b
	push	af		;2a4c
	ld	a,e		;2a4d
	call	STRINI		;2a4e
	ld	e,a		;2a51
	pop	af		;2a52
	inc	e		;2a53
	dec	e		;2a54
	jr	z,FINBCK	;2a55
	ld	hl,(DSCTMP+1)	;2a57
SPLPS:	ld	(hl),a		;2a5a
	inc	hl		;2a5b
	dec	e		;2a5c
	jr	nz,SPLPS	;2a5d
	jr	FINBCK		;2a5f
; ----------------------------------------------------------------------
; 2A61-2A90 – LEVEL II BASIC LEFT$( ROUTINE – “FNLEFT”
; ----------------------------------------------------------------------
FNLEFT:	call	PREAM		;2a61
; ----------------------------------------------------------------------
; 2A64 - Make a string of the leftmost n characters of string (TAS)
; ----------------------------------------------------------------------
	xor	a		;2a64
LEFT3:	ex	(sp),hl		;2a65
	ld	c,a		;2a66
;
	DEFB	LDANN		;2a67 - Z80 Trick - LD A,nn - skip next byte
;
LEFTUS:	push	hl		;2a68
LEFT2:	push	hl		;2a69
	ld	a,(hl)		;2a6a
	cp	b		;2a6b
	jr	c,ALLSTR	;2a6c
	ld	a,b		;2a6e
;
	DEFB	LDDENN		;2a6f - Z80 Trick - LD DE,nnnn - skip next 2 bytes
;
ALLSTR:	ld	c,$00		;2a70
	push	bc		;2a72
	call	GETSPA		;2a73
	pop	bc		;2a76
	pop	hl		;2a77
	push	hl		;2a78
	inc	hl		;2a79
	ld	b,(hl)		;2a7a
	inc	hl		;2a7b
	ld	h,(hl)		;2a7c
	ld	l,b		;2a7d
	ld	b,$00		;2a7e
	add	hl,bc		;2a80
	ld	b,h		;2a81
	ld	c,l		;2a82
	call	STRAD2		;2a83
	ld	l,a		;2a86
	call	MOVSTR		;2a87
	pop	de		;2a8a
	call	FRETMP		;2a8b
	jp	PUTNEW		;2a8e
; ----------------------------------------------------------------------
; 2A91-2A99 – LEVEL II BASIC RIGHT$ ROUTINE – “FNRGT”
; ----------------------------------------------------------------------
FNRGT:	call	PREAM		;2a91
; ----------------------------------------------------------------------
; 2A94 - Make a string of the rightmost n characters of string (TAS)
; ----------------------------------------------------------------------
	pop	de		;2a94
	push	de		;2a95
	ld	a,(de)		;2a96
	sub	b		;2a97
	jr	LEFT3		;2a98
; ----------------------------------------------------------------------
; 2A9A-2AC4 – LEVEL II BASIC MID$ ROUTINE – “FNMID”
; ----------------------------------------------------------------------
FNMID:	ex	de,hl		;2a9a
	ld	a,(hl)		;2a9b
	call	PREAM2		;2a9c
	inc	b		;2a9f
	dec	b		;2aa0
	jp	z,FCERR		;2aa1
	push	bc		;2aa4
	ld	e,$FF		;2aa5
	cp	')'		;2aa7
	jr	z,MID2		;2aa9
	SYNTAX	(',')		;2aab - rst 08h
	call	GETBYT		;2aad
MID2:	SYNTAX	(')')		;2ab0 - rst 08h
	pop	af		;2ab2
; ----------------------------------------------------------------------
; 2AB3 - Make a string from a portion of another string (TAS)
; ----------------------------------------------------------------------
	ex	(sp),hl		;2ab3
	ld	bc,LEFT2	;2ab4
	push	bc		;2ab7
	dec	a		;2ab8
	cp	(hl)		;2ab9
	ld	b,$00		;2aba
	ret	nc		;2abc
	ld	c,a		;2abd
	ld	a,(hl)		;2abe
	sub	c		;2abf
	cp	e		;2ac0
	ld	b,a		;2ac1
	ret	c		;2ac2
	ld	b,e		;2ac3
	ret			;2ac4
; ----------------------------------------------------------------------
; 2AC5-2ADE – LEVEL II BASIC VAL ROUTINE – “FNVAL”
; ----------------------------------------------------------------------
FNVAL:	call	LEN1		;2ac5
	jp	z,SNGFLT	;2ac8
	ld	e,a		;2acb
	inc	hl		;2acc
	ld	a,(hl)		;2acd
	inc	hl		;2ace
	ld	h,(hl)		;2acf
	ld	l,a		;2ad0
	push	hl		;2ad1
	add	hl,de		;2ad2
	ld	b,(hl)		;2ad3
	ld	(hl),d		;2ad4
	ex	(sp),hl		;2ad5
	push	bc		;2ad6
	ld	a,(hl)		;2ad7
	call	FINDBL		;2ad8
	pop	bc		;2adb
	pop	hl		;2adc
	ld	(hl),b		;2add
	ret			;2ade
; ----------------------------------------------------------------------
; 2ADF-2A6 – STRING ROUTINE – “PREAM”
;   This is called by LEFT$, MID$, and RIGHT$ to test for the ending “)”
;   character. On entry, the STACK has the string address, byte count,
;   and return address. On exit the STACK has the string address,
;   DE and B each have the byte count.
; ----------------------------------------------------------------------
PREAM:	ex	de,hl		;2adf
	SYNTAX	(')')		;2ae0 - rst 08h
PREAM2:	pop	bc		;2ae2
	pop	de		;2ae3
	push	bc		;2ae4
	ld	b,e		;2ae5
	ret			;2ae6
; ----------------------------------------------------------------------
; 2AE7H-2AEE – Process a LEFT-HAND-SIDE MID$– “ISMID$”
;
; This routine is designed to handle a left-size MID$ call.
; So check to see if the character at the location of the current BASIC
; program pointer in Register A is trying to process a left hand side MID$.
; If they match, the Z FLAG is set, and otherwise the NZ FLAG is set.
; If A < the checked value, then the C FLAG is set.
; If A >= the checked value, the NC FLAG is set.
; ----------------------------------------------------------------------
ISMID:	cp	TKMID-TKOFF	;2ae7 - Check the Mid Token.
	jp	nz,SNERR	;2ae9
	jp	DLHSMD		;2aec JUMP to DOS to see if DOS wants to deal with this.
;
; ----------------------------------------------------------------------
; 2AEF-2AF7 – LEVEL II BASIC INP ROUTINE– “FNINP”
; ----------------------------------------------------------------------
FNINP:	call	CONINT		;2aef
	ld	(STAINP+1),a	;2af2
	call	STAINP		;2af5
	jp	SNGFLT		;2af8
;
; ----------------------------------------------------------------------
; 2AF8-2B00 – LEVEL II BASIC OUT ROUTINE– “FNOUT”
; ----------------------------------------------------------------------
FNOUT:	call	SETIO		;2afb
	jp	OUTWRD		;2afe
;
; ----------------------------------------------------------------------
; 2B01-2B0D – EVALUATE EXPRESSION ROUTINE “GETINT”
;   This evaluates an expression and leaves the result in DE as an integer.
; ----------------------------------------------------------------------
GETINT:	GETCHR			;2b01 - rst 10h
;
; ----------------------------------------------------------------------
; 2B02H - LOAD INTEGER EXPRESSION IN DE
;   Same as routine at 1E46H except allows negative argument.
;   Number must evaluate within range -32768 to 32767.
; ----------------------------------------------------------------------
GETIN2:	call	FRMEVL		;2b02
;
; ----------------------------------------------------------------------
; 2B05 – MATH CONVERSION ROUTINE - This routine converts value from the ACC to an
; integer value and places the result in the DE Register Pair. The Z flag will be
; set if the result in DE is smaller than or equal to 255 (FFH). (DE = INT (ACC)).
; ----------------------------------------------------------------------
INTFR2:	push	hl		;2b05
	call	FRCINT		;2b06
	ex	de,hl		;2b09
	pop	hl		;2b0a
	ld	a,d		;2b0b
	or	a		;2b0c
	ret			;2b0d
;
; ----------------------------------------------------------------------
; 2B0E-2B16 – EVALUATE EXPRESSION ROUTINE – OUT continues here – “SETIO”
; ----------------------------------------------------------------------
SETIO:	call	GETBYT		;2b0e
	ld	(STAINP+1),a	;2b11
	ld	(OUTWRD+1),a	;2b14
; ----------------------------------------------------------------------
; 2B17-2B1A – CHECK SYNTAX ROUTINE – This checks to see if the next character
; is a “ and contnues on to 2B1CH if it is, and errors out if it isn’t.
; ----------------------------------------------------------------------
	SYNTAX	(',')		;2b17 - rst 08h
	jr	GETBYT		;2b19
;
; ----------------------------------------------------------------------
; 2B1B-2B28 – EVALUATE EXPRESSION ROUTINE – This is called by PRINT TAB – “GTBYTC”.
; ----------------------------------------------------------------------
GTBYTC:	GETCHR			;2b1b - rst 10h
;
; ----------------------------------------------------------------------
; 2B1C – Common Conversion Routine – “GETBYT”
;   This routine converts a numeric ASCII string pointed to by the HL
;   into a hexadecimal value and places the result in the A register.
;   If the result is larger than 255 (FFH) then an FC ERROR (Illegal
;   function call) will be generated. After execution the HL will point
;   to the delimiter. If the delimiter is a zero byte or a colon (3AH)
;   then the Z flag will be set. Any other delimiter will cause the
;   Z flag to be reset.
; ----------------------------------------------------------------------
GETBYT:	call	FRMEVL		;2b1c
CONINT:	call	INTFR2		;2b1f
	jp	nz,FCERR	;2b22
	dec	hl		;2b25
	GETCHR			;2b26 - rst 10h
	ld	a,e		;2b27
	ret			;2b28
; ----------------------------------------------------------------------
