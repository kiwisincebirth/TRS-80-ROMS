;
; ======================================================================
;          TRS-80 Model I Level II BASIC ROM
;              "Modernised" Revision 1.4
;
;     Source Code Created By : kiwisincebirth - 2025
;     [https://github.com/kiwisincebirth/TRS-80]
;
; ======================================================================
;     NOTE: this code has been formatted with 8 spaces per tab
; ----------------------------------------------------------------------
;
; BASED OFF LEVEL 2 ROMS
; Version 1.3 - 80/02
; Date: 01/07/80-01/13/80
; CRC-32: A8E60D9A
;
; Rom Hardware Support
; #DEFINE EACA80  ; Uncomment to enable System-80 (EACA) hardware support
;
; Rom Bug Fixes
#DEFINE BUGFIX1 ; Fix Error 1 - 04F6H - 32 Character Mode Line Length
#DEFINE BUGFIX5 ; Fix Error 5 - 08A7H - INT(DoubleValue) rounding
#DEFINE BUGFIX7 ; Fix Error 7 - 0EF2H - Space after Type declaration Tag
#DEFINE BUGFIX7C ; Fix Error 7C - 213DH - Space after TAB keyword
#DEFINE BUGFIX8 ; Fix Error 8 - 1009H - PRINT USING, - sign at end of field
#DEFINE BUGFIX11 ; Fix Error 11 - 2301H - Overflow on Integer FOR loop
;
; Rom Additional Features
#DEFINE LOWCASE ; Disable Alpha Character Translation (0471h)
#DEFINE FREHDBT ; Enable FreHD Auto boot at startup (069Ch)
#DEFINE NMIHARD ; Set NMI Reset as always hard reset. (0066h)
#DEFINE NEWBOOT ; New diskette? startup routine. (06C0)
;
; Rom 1.3 Features (can be disabled to save space)
#DEFINE KEYBOUNCE ; Enable 1.3 Keyboard Debounce (03FBh)
;
; Build Features
; #DEFINE SIZE16K ; Uncomment to build a $FF padded 16K Image for banked ROM
;
; ======================================================================
;     INFORMATION
; ----------------------------------------------------------------------
;
; Code was based off the Model 1 Rev 1.3 source code, provided in the GIT Repo
; and enhanced modernised, with new features removing support for cassette
; based operations.
;
; ======================================================================
;      ERRORS - "TRS-80 ROM Errors - Vernon Hester"
;      https://www.trs-80.com/sub-rom-bugs.htm
; ----------------------------------------------------------------------
;
; ======================================================================
;      REFERENCES
; ----------------------------------------------------------------------
;   • Git Hub Repository - [https://github.com/kiwisincebirth/TRS-80]
;   • Ira Goldlang, TRS-80 ROM Information - [https://www.trs-80.com/wordpress/roms/]
;   • TRS-80 ROM Errors - Vernon Hester - [https://www.trs-80.com/sub-rom-bugs.htm]
;   • Telemark Assembler - [https://www.cpcalive.com/docs/TASMMAN.HTM]
;   • Microsoft BASIC Decoded & Other Mysteries - James Farvour
;   • TRS-80 Rom Routines Documented (The Alternate Source) - Jack Decker
;
; ======================================================================
;
#IFDEF EACA80
	DEFC 	EACA80_ENABLED = 1
	PUBLIC 	EACA80_ENABLED
#ENDIF

;
INCLUDE "CONSTANTS.Z80"
;
DEFC	CURCHR	= $5F	; _ cursor character
;
DEFC	BUFINI	= RAM+$1E5	; String Buffer initialised with -> colon null comma (M1)
DEFC	SMPSTK	= RAM+$1F8	; Initial Stack address (M1)
DEFC	MEMEND	= RAM+$200	; End of Reserved RAM Communications area
DEFC	SYSSTK	= RAM+$288	; Stack address usd by SYSTEM command
;
; ======================================================================
;   START OF PROGRAM CODE
; ======================================================================
;
	ORG	$0000	; Start of ROM Code Base
;
; ----------------------------------------------------------------------
; 0000H-0004H – POWER UP ROUTINE – "_START"
; ----------------------------------------------------------------------
_START:
rst00:	di			;0000
	xor	a		;0001
	jp	INIT		;0002
;
; The BDOS (Basic Disk Operating System) entry point address in most CP/M systems
; Having this here may be coincidental, or this may never called
	jp	mRST1		;0005
;
; ======================================================================
; 0008H (RST 8H) - Compare Symbol - SYMBOL
;
;   Jumps to 4000H. 4000H passes control to 1C96H.
;   Compares the symbol in the input string pointed to by HL
;   register to the value in the location following the RST 08
;   call. If there is a match, control is returned to address of the
;   RST 08 instruction 2 with the next symbol in the A-register
;   and HL incremented by one. If the two characters do not
;   match, a syntax error message is given and control returns
;   to the Input Phase.
; ----------------------------------------------------------------------
rst08:	jp	mRST1		;0008
;
; ----------------------------------------------------------------------
; 000BH-000CH – DISK ROUTINE – "_WHERE" ( RESOLVE RELOCATION ADDRESS )
;   Same as a RET instruction except leaves return address in HL
;    A relocatable program can CALL 000BH and upon return the HL register
;    will contain hte current address of PC, thus can find itself in memory
; ----------------------------------------------------------------------
_WHERE:	pop	hl		;000b
	jp	(hl)		;000c
;
; ----------------------------------------------------------------------
; 000DH-000FH – DISK BOOTSTRAP – "_BOOT"
;   Does a "warm" system reboot, in that it reloads and executes the Disk
;    Operating System but does not re-initialize all system pointers, etc.
; ----------------------------------------------------------------------
_BOOT:	jp	BOOT		;000d - Jump to Disk Bootstrap loader (069Fh)
;
; ======================================================================
; 0010H (RST 10) – GET A CHARACTER FROM THE BUFFER - GETCHR
;
;   Loads the next character from the string pointed to by the
;   HL register set into the A-register and clears the CARRY
;   flag if it is alphabetic, or sets it if is alphanumeric. Blanks
;   and control codes 09 and 0B are ignored causing the
;   following character to be loaded and tested. The HL
;   register will be incremented before loading any character
;   therefore on the first call the HL register should contain the
;   string address minus one. The string must be terminated by
;   a byte of zeros.
; ----------------------------------------------------------------------
rst10:	jp	mRST2		;0010
;
; ----------------------------------------------------------------------
; 0013H-0017H – INPUT ROUTINE – _GET
; ----------------------------------------------------------------------
_GET:	push	bc		;0013
	ld	b,$01		;0014 - device type entry code
	jr	CIOJ		;0016 - BASIC driver entry routine at 0046H
;
; ======================================================================
; 0018H (RST 18H) Compare DE:HL - CPDEHL
;
;   This routine can be called by using RST 18H or CALL 1C90H.
;   Numerically compares DE and HL. Will not work for
;   signed integers (except positive ones). Uses the A-register
;   only. Sets the S and Z flags accordingly
;   (they are set in the same way as for a normal 8 bit CP).
;   All registers are unchanged except for A
;   Jumps to lC90H through 4006H.
; ----------------------------------------------------------------------
rst18:	jp	mRST3		;0018
;
; ----------------------------------------------------------------------
; 001BH-001EH – DRIVER ENTRY ROUTINE – Part 1 – "_PUT"
; ----------------------------------------------------------------------
_PUT:	push	bc		;001b
	ld	b,$02		;001c - device type entry code
	jr	CIOJ		;001e - BASIC driver entry routine at 0046H
;
; ======================================================================
; 0020H (RST 20H) - Get the current Number Type - GETYPE
;
;   This routine jumps to 25D9H through 4009H.
;   If the NTF=8 then C=RESET or else C=SET, Z flag will be SET if NTF=3
;   (S flag is valid also.). After execution of RST 20H or CALL 25D9H,
;   A will contain the value NTF-3, all other registers are unchanged.
; ----------------------------------------------------------------------
rst20:	jp	mRST4		;0020
;
; ----------------------------------------------------------------------
; 0023H-0027H – DISK ROUTINE – "_CTL"
;   Outputs a control byte to a logical device or FCB.
;   DE = FCB and A = control byte
; ----------------------------------------------------------------------
_CTL:	push	bc		;0023
	ld	b,$04		;0024 - device type entry code
	jr	CIOJ		;0026- BASIC driver entry routine at 0046H
;
; ======================================================================
; 0028H (RST 28H) - DOS Function CALL - DOSCAL
;
;   Jumps to 400CH which contains C9H (RET) under Level II BASIC.
;   This vector is only used by Disk BASIC. It is called by the BREAK key routine,
;   and can be used to intercept the BREAK key logic
; ----------------------------------------------------------------------
_DOSCAL:
rst28:	jp	mRST5		;0028
;
; ======================================================================
; 002BH – KEYBOARD ROUTINE – "_KBD" - Scan Keyboard
;
;   This Routine Performs an instantaneous scan of the keyboard.
;   After CALLing 2BH, the A Register will contain
;   the ASCII value for the key that was pressed, or ZERO if no key pressed.
;
;   Apart from the AF Register Pair the DE Register Pair is also used by the routine.
;   If you want to wait for a key to be pressed, you would use CALL 0049
; ----------------------------------------------------------------------
_KBD:	ld	de,mKDCB	;002b
	jr	_GET		;002e
;
; ======================================================================
; 0030 (RST 30H) - Load DEBUG - LDEBUG
;
;   This CALL loads the DEBUG program and transfers
;   control to it. When DEBUG processing is complete, control
;   is returned to the original caller. For non-disk systems
;   control is returned immediately
;   This location passes control to 400FH which contains a RET (C9H)
;   under Level II. This location is only used by a Disk system
; ----------------------------------------------------------------------
rst30:	jp	mRST6		;0030
;
; ======================================================================
; 0033H – VIDEO ROUTINE – "_DSP" - Character print routine.
;
;  Print a character at the current cursor position.
;  The A Register must contain the ASCII code for the character or graphics
;  figure that is to be printed before CALLing this routine.
;  The DE Register Pair is used by the routine.
; ----------------------------------------------------------------------
VDCHAR:
_DSP:	ld	de,mDDCB	;0033 - video device control block.
	jr	_PUT		;0036
;
; ======================================================================
; 0038 (RST 38H) - Interrupt Entry Point - INTERR
;
;  This is the system entry point for all interrupts. It contains a
;  jump to section of code in the Communications Region
;  designed to field interrupts. That section of code consists
;  of a DI (disables further interrupts) followed by a RET
;  (returns to the point of interrupt) for non-disk systems
; ----------------------------------------------------------------------
rst38:	jp	mRST7		;0038
;
; ======================================================================
; 003BH – PRINTER ROUTINE – "$PRT"
;  Waits until printer is ready then prints charatcter.
;  A = ASCII character. If BREAK is pressed, a return to caller is made
;  Character LPRINT routine. Same as 33H but outputs to line printer.
;  (Contents of A Register will be printed).
; ----------------------------------------------------------------------
PRCHAR:
_PRT:	ld	de,mPDCB	;003b
	jr	_PUT		;003e
;
; ----------------------------------------------------------------------
; 0040H – INPUT ROUTINE – "$KEYIN" - GET A LINE FROM THE KEYBOARD
;  takes keyboard entry until a carriage return, a break, or buffer overrun occurs.
; ----------------------------------------------------------------------
KBLINE:
_KEYIN:	jp	KEYIN		;0040
	ret			;0043 - unsure of the purpose of these instructions
	nop			;0044
	nop			;0045
;
; ----------------------------------------------------------------------
; 0046H-0048H – DRIVER ENTRY ROUTINE – Part 2 – "CIOJ"
; ----------------------------------------------------------------------
CIOJ:	jp	CIO		;0046
;
; ======================================================================
; 0049H – KEYBOARD ROUTINE – "$KEY" -  Wait For Keyboard Input
;
;   Returns as soon as any key on keyboard is pressed. ASCII
;   value for character entered is returned in A- register. Uses
;   A, status and DE registers.
; ----------------------------------------------------------------------
KBWAIT:
_KEY:	call	_KBD		;0049
	or	a		;004c
	ret	nz		;004d
	jr	_KEY		;004e
;
; ----------------------------------------------------------------------
; 0050H-005FH – KEYBOARD LOOKUP TABLE – "KEYTAB"
;   XXX in 1.3, Shift-↓ is $00 to act as a Ctrl key
;                Std    Shifted
; ----------------------------------------------------------------------
KEYTAB:	DEFB	ENTER,	ENTER	; ENTER
	DEFB	CLRKEY,	CLRKEY	; CLEAR
	DEFB	BREAK,	BREAK	; BREAK
	DEFB	UPARRW,	ARUP	; ↑ Up Arrow
	DEFB	LINEF,	$00	; ↓ Down Arrow
				; to permit Shift-Down-Arrow to act as a control key
	DEFB	BACKS,	ARLEFT	; BS, ← Left arrow
	DEFB	TAB,	ARIGHT	; Tab, -> right arrow
	DEFB	SPACE,	SPACE	; Space
;
; ----------------------------------------------------------------------
; 0060H-0065H – DELAY ROUTINE – "$DELAY"
;  This is a delay loop. The BC Register Pair is used as the loop counter.
;  The duration of the delay, in microseconds, is the value of BC times 14.66.
;  Register A is used.
; ----------------------------------------------------------------------
DELAY:	dec	bc		;0060
	ld	a,b		;0061
	or	c		;0062
	jr	nz,DELAY	;0063
	ret			;0065
;
; ----------------------------------------------------------------------
; 0066 - NMI RESET
; the location to which program control jumps when the RESET button
; is pressed (Non Maskable Interrupt address)
; The RESET button generates an NMI, not an actual reset.
; ----------------------------------------------------------------------
#IFDEF NMIHARD
;
NMI:	jp	_START		;0066 - wrong Stack Pointer.
;
	DEFC 	NMIHARD_ENABLED = 1
	PUBLIC 	NMIHARD_ENABLED
	DEFS	$0072 - $	;UNUSED fill the space to next routine with ZERO's
;
#ELSE
;
NMI:	ld	sp,$0600	;0066 - wrong Stack Pointer. Replaced latter
	ld	a,(diskstat)	;0069 - $FF if no expansion interface present
	inc	a		;006C
	cp	$02		;006D - did we detect a disk controller
	jp	nc,_START	;006F - If a disk is present START as if power-up
;
#ENDIF
;
; ----------------------------------------------------------------------
; Alternative entry point to BASIC. See 06CCH or 1A19 for more details
; ----------------------------------------------------------------------
	ASSERT	$ == $0072, "Segment: Alternate BASIC Entry Point Should start at $0072"
	jp	RESETR		;0072 - NO - jump to Level II BASIC READY routine
;
; ----------------------------------------------------------------------
; 0075H-0104H – INITIALIZATION ROUTINE – "INIT2"
;  This is part of the Level II initialization procedure. It moves
;  several support routine from 18F7H to 191EH up to 4080H to 40A7H.
; ----------------------------------------------------------------------
INIT2:	ld	de,FDIVC	;0075 - Ram location - of Level II BASIC support routines.
	ld	hl,CONSTR	;0078 - Rom Location - of Level II BASIC support routines.
	ld  bc,CONSTR2-CONSTR+1 ;007b - Size of the Routine(s) to move
	ldir			;007e - Move the routines
;
;  Initialises String Buffer
	ld	hl,BUFINI	;0080 - String Buffer Area in RAM (41E5H)
	ld	(hl),':'	;0083 - save a colon
	inc	hl		;0085 - next location
	ld	(hl),b		;0086 - write a 0, B reg should be zero
	inc	hl		;0087 - next location
	ld	(hl),','	;0088 - save a comma
	inc	hl		;008a - next location
;
; This loads 40A7H with the I/O buffer location address 41E8H.
; (40A7H is the I/O buffer pointer and contents be changed to relocate the buffer.)
	ld	(BUFPNT),hl	;008b
;
; Fills the RAM locations pointing to all 28 DOS BASIC commands,
; set them to point to ?L3 ERROR, (4152-41A5)
	ld	de,L3ERR	;008e - address of L3 error code
	ld	b,28		;0091 - there are 28 DOS BASIC commands
	ld	hl,ERCALL	;0093 - address in RAM of lookup table
ERLOPS:	ld	(hl),OPJPNN	;0096 - opcode (1st byte) for JP nnnn
	inc	hl		;0098
	ld	(hl),e		;0099 - address low order
	inc	hl		;009a
	ld	(hl),d		;009b - address high order
	inc	hl		;009c
	djnz	ERLOPS		;009d - and loop bas as required
;
; Set DOS Exit links to RET instructions (41A6-41E2)
	ld	b,21		;009f - 21 DOS Exits
LOPRTS:	ld	(hl),OPRET	;00a1 - Store RET OpCode
	inc	hl		;00a3 - and advance to the next location (3 bytes)
	inc	hl		;00a4
	inc	hl		;00a5
	djnz	LOPRTS		;00a6 - and loop if required
;
; The rest of the initialization routine. Asks MEMORY SIZE ?,
; sets the memory pointers accordingly and prints RADIO SHACK LEVEL II BASIC ,
	ld	hl,MEMEND+$E8	;00a8 - starting address of user RAM (which is 42E8H)
	ld	(hl),b		;00ab
	ld	sp,SMPSTK	;00ac - STACK pointer to 41F8H, temporary until call STKINI
	call	STKINI		;00af - Go initialize the Level II BASIC variables and pointers
	call	CLS		;00b2 - clears the screen, changes to 64 characters, and homes the screen)
;
MEMGET:	ld	hl,MEMMSG	;00b5 - MEMORY SIZE? message
	call	STROUT		;00b8 - print it
	call	QINLIN		;00bb - Print a “?” and get input from the keyboard
	jr	c,MEMGET	;00be - If the BREAK key was pressed, ask again.
	GETCHR			;00c0 - rst 10h
	or	a		;00c1
	jr	nz,TYPMEM	;00c2 - was a response to the MEMORY SIZE?
;
; start testing RAM at 434CH towards FFFFH
	ld	hl,MEMEND+$14C	;00c4 - starting address for the memory size check (434C)
LOOPMM:	inc	hl		;00c7 - next ram location
	ld	a,h		;00c8 - MSB of ram location
	or	l		;00c9 - combine with LSB of ram location
	jr	z,USEDEF	;00ca - if the current memory pointer HL is equal to zero
	ld	a,(hl)		;00cc - get byte at memory location
	ld	b,a		;00cd - save it
	cpl			;00ce - and invert it (A) for test
	ld	(hl),a		;00cf - write it back to ram
	cp	(hl)		;00d0 - retrieve and compare test value
	ld	(hl),b		;00d1 - and save original value back
	jr	z,LOOPMM	;00d2 - loop back until the end of memory is found
	jr	USEDEF		;00d4 - If the address didn’t exist, have reached HIMEM
;
; process the users input to MEMORY SIZE ?
TYPMEM:	call	LINGET		;00d6 - convert user input string (HL) into value in DE
	or	a		;00d9 - Set Flags
	jp	nz,SNERR	;00da - Display a ?SN ERROR if Register A is not equal to zero
	ex	de,hl		;00dd - move value to HL
	dec	hl		;00de - minus 1
	ld	a,$8F		;00df - Load Register A with a memory test value
	ld	b,(hl)		;00e1 - read and save current value
	ld	(hl),a		;00e2 - write the test value
	cp	(hl)		;00e3 - read and compare to see if value was saved
	ld	(hl),b		;00e4 - restore the original value
	jr	nz,MEMGET	;00e5 - if not a usaable ram adress, back to MEM SIZE prompt
USEDEF:	dec	hl		;00e7 - minus 1
	ld	de,MEMEND+$214	;00e8 - the minimum MEMORY SIZE? response.
	CPDEHL			;00eb - RST 18 - compare DE (input)  and HL (minimum)
	jp	c,OMERR		;00ec - less than memory required, so OM ERROR
	ld	de,$FFCE	;00ef - Subtract 32 Bytes
	ld	(MEMSIZ),hl	;00f2 - Save the MEMORY SIZE? amount
	add	hl,de		;00f5 - subtract 32 bytes from the memory size
	ld	(STKTOP),hl	;00f6 - start of string space pointer MEMSIZE-32
	call	SCRTCH		;00f9 - init the Level II variables and pointers
	ld	hl,HDGMSG	;00fc - Radio Shack L2 Basic - Message
	call	STROUT		;00ff - print the message
	jp	READY		;0102 - Level II BASIC READY routine
;
; ----------------------------------------------------------------------
; 0105H-011BH – MESSAGE STORAGE
; ----------------------------------------------------------------------
;
#IFDEF EACA80
MEMMSG:	DEFB	"MEM SIZE",0			     	; Mem Size Message
HDGMSG:	DEFB	"TRS-80 Level II BASIC Rev 1.4",ENTER,0 ; L2 Basic Message
#ELSE
MEMMSG:	DEFB	"MEMORY SIZE",0			     ; RS Mem Size Message V1.2
HDGMSG:	DEFB	"R/S Level II BASIC Rev 1.4",ENTER,0 ; RS L2 Basic Message V1.4
#ENDIF
;
; 	DEFB	"RADIO SHACK LEVEL II BASIC",ENTER,0 ; RS L2 Basic Message V1.2
;
	DEFS	$012D - $	; Padding (also checks for overrun)
;
; ----------------------------------------------------------------------
; 012DH – ?L3 ERROR ENTRY POINT – "L3ERR"
; ----------------------------------------------------------------------
L3ERR:	ld	e,ERRL3		;012d - Load Register E with the ?L3 ERROR code of 2CH
	jp	ERROR		;012f
;
; ----------------------------------------------------------------------
; 0132H-0134H –	LEVEL II BASIC POINT COMMAND ENTRY POINT – "POINT"
; ----------------------------------------------------------------------
POINT:	GETCHR			;0132 - rst 10h
	xor	a		;0133
;
; Z-80 Trick! The byte at this memory location, 01H, is there to turn the real instruction
; that follows (the operative action of the SET command) into a harmless LD BC,xxxx.
; This way, they didn’t have to jump over SET or RESET to get to the common graphics code.
; If parsing straight down, this loads BC with 0380H and then moves to 0136H. But if jump
; straight to 0136H, you skip that 01H opcode, and get a real instruciton of 3EH 80H
	DEFB	LDBCNN		;0134
;
; ----------------------------------------------------------------------
; 0135H-0137H – LEVEL II BASIC SET COMMAND ENTRY POINT – “SET”
; ----------------------------------------------------------------------
SET:	ld	a,$80		;0135
	DEFB	LDBCNN		;0137 - See comment above about what this does
;
; ----------------------------------------------------------------------
; 0138H-0139H – LEVEL II BASIC RESET COMMAND ENTRY POINT – “RESET”
; ----------------------------------------------------------------------
RESET:	ld	a,$01		;0138
;
; ----------------------------------------------------------------------
; 013AH-019CH GRAPHICS ROUTINE - Common Code for SET RESET and POINT
;   A will be 0 if POINT, 80H if SET and 1 for RESET.
; ----------------------------------------------------------------------
;
	push	af		;013a
	SYNTAX	('(')		;013b - rst 08h - all commands start with a (
	call	GETBYT		;013d - get a numeric value X coordinate
	cp	128		;0140 - is it greater than 128
	jp	nc,FCERR	;0142 - if greater than 128 then an error
	push	af		;0145 - Save coordinate’s X value on the STACK
	SYNTAX	(',')		;0146 - rst 08h - then a comma
	call	GETBYT		;0148 - get a numeric value Y coordinate
	cp	$30		;014b - test to see if the character was alphabetic or alphanumeric
	jp	nc,FCERR	;014d
	ld	d,$FF		;0150
LOPMD3:	inc	d		;0152
	sub	$03		;0153
	jr	nc,LOPMD3	;0155
	add	a,$03		;0157
	ld	c,a		;0159
	pop	af		;015a
	add	a,a		;015b
	ld	e,a		;015c
	ld	b,$02		;015d
SHFTW:	ld	a,d		;015f
	rra			;0160
	ld	d,a		;0161
	ld	a,e		;0162
	rra			;0163
	ld	e,a		;0164
	djnz	SHFTW		;0165
	ld	a,c		;0167
	adc	a,a		;0168
	inc	a		;0169
	ld	b,a		;016a
	xor	a		;016b
	scf			;016c
PWR2:	adc	a,a		;016d
	djnz	PWR2		;016e
	ld	c,a		;0170
	ld	a,d		;0171
	or	$3C		;0172
	ld	d,a		;0174
	ld	a,(de)		;0175
	or	a		;0176
	jp	m,FND4		;0177
	ld	a,$80		;017a
FND4:	ld	b,a		;017c
	pop	af		;017d
	or	a		;017e
	ld	a,b		;017f
	jr	z,TBIT		;0180
	ld	(de),a		;0182
	jp	m,SBIT		;0183
	ld	a,c		;0186
	cpl			;0187
	ld	c,a		;0188
	ld	a,(de)		;0189
	and	c		;018a
FINSTB:	ld	(de),a		;018b
FINPTB:	SYNTAX	(')')		;018c - rst 08h
	ret			;018e
SBIT:	or	c		;018f
	jr	FINSTB		;0190
TBIT:	and	c		;0192
	add	a,$FF		;0193
	sbc	a,a		;0195
	push	hl		;0196
	call	CONIA		;0197
	pop	hl		;019a
	jr	FINPTB		;019b
;
; ----------------------------------------------------------------------
; 019DH-01C8H – LEVEL II BASIC INKEY$ ROUTINE – “INKEY”
; ----------------------------------------------------------------------
INKEY:	GETCHR			;019d - rst 10h
; ----------------------------------------------------------------------
; 019E - Create 1 character string from keyboard input (TAS)
; ----------------------------------------------------------------------
	push	hl		;019e
	ld	a,(CHARC)	;019f
	or	a		;01a2
	jr	nz,BUFCIN	;01a3
	call	ISCHAR		;01a5
	or	a		;01a8
	jr	z,NULRT		;01a9
BUFCIN:	push	af		;01ab
	xor	a		;01ac
	ld	(CHARC),a	;01ad
	inc	a		;01b0
	call	STRINI		;01b1
	pop	af		;01b4
	ld	hl,(DSCTMP+1)	;01b5
	ld	(hl),a		;01b8
	jp	PUTNEW		;01b9
NULRT:	ld	hl,m_REDDY-1	;01bc
	ld	(FACLO),hl	;01bf
	ld	a,VTSTR		;01c2 - String Value Type
	ld	(VALTYP),a	;01c4
	pop	hl		;01c7
	ret			;01c8
;
; ======================================================================
; 01C9H – LEVEL II BASIC CLS ROUTINE – "CLS"
;
;   Clear the screen, select 64 characters and home the cursor.
;   All registers are used.
; ----------------------------------------------------------------------
CLS:	ld	a,CHOME		;01c9 - ascii for cursor Home
	call	OUT2D		;01cb - display it
	ld	a,CLRKEY	;01ce - ascii for erase to end of frame
	jp	OUT2D		;01d0 - call and return
;
; ======================================================================
; 01D3H – LEVEL II BASIC REFRESH RANDOM ROUTINE – “RANDOM”
;
;   This is part of the RANDOM routine which takes a value out of the
;   REFRESH register, stores it in location 40ABH and then returns.
;   A call to 01D3H reseeds the random number seed (location 40AB)
;   with the current contents of the refresh register.
; ----------------------------------------------------------------------
RANDOM:	ld	a,r		;01d3 - R (refresh) Reg - semi random number.
	ld	(RNDX+1),a	;01d5
	ret			;01d8
;
; ======================================================================
; LEGACY CASSETTE ROUTINES FOR LEVEL 2 BASIC BACKWARS COMPATIBILITY
; ======================================================================
;
; ----------------------------------------------------------------------
; CASSETTE ROUTINE (EVALUATE DRIVE NUMBER) – “CTON”
;   This Code was left over after removing all the unneeded code
;   but still needed as it updates registers needed by caller
; ----------------------------------------------------------------------
CTON:	ld	a,(hl)		;01fe - char from BASIC program pointer
	sub	'#'		;01ff - Check for a # character
	ret	nz		;0203 - Isnt a # char so nothing to do
	call	GETINT		;0205 - get INT drive number from BASIC program -> DE
	SYNTAX	(',')		;0208 - rst 08h - See if we have a Comma
	ret			;021d
; ----------------------------------------------------------------------
; CASSETTE ROUTINE (TURN ON CASSETTE AND WRITE LEADER) – “CWRTON”
;   This Code was left over after removing all the unneeded code
;   but still needed as it updates registers needed by caller
; ----------------------------------------------------------------------
CWRTON: call	CTON		;0284
	ld	a,$A5		;028f - sync byte (A5H)      **NEEDED**
	ret			;027d
; ----------------------------------------------------------------------
;
; ======================================================================
; ROM REGION 1 - (01E9 - 02B1) - Cassette
; ======================================================================
;
; ----------------------------------------------------------------------
; BUGFIX1 - 32 Character Mode Line Length fixed
; ----------------------------------------------------------------------
;
#IFDEF BUGFIX1
;
DSPLINLTH:
	ld	a,(CAST)	; get shadow copy of Cassette port
	and	CAST32		; check if 32 char mode
	ld	a,64		; assume 64 line length
	ret	z		; flag not set so return the 64
	srl	a		; set 32 line length
	ret			; and return it.
;
; ----------------------------------------------------------------------
	DEFC 	BUGFIX1_ENABLED = 1
	PUBLIC 	BUGFIX1_ENABLED
	DEFC 	BUGFIX1_BYTES = $ - DSPLINLTH
	PUBLIC 	BUGFIX1_BYTES
#ENDIF
; ----------------------------------------------------------------------
; BUGFIX7 - Space after Type declaration Tag
; ----------------------------------------------------------------------
;
#IFDEF BUGFIX7
;
INFINEFIX:
	inc	hl		; next program byte
	ld	a,(hl)		; get program byte
	cp	SPACE		; Is it a space
	jp 	nz,FINE		; NOT - Continue (return)
	jr	INFINEFIX	; loop around
; ----------------------------------------------------------------------
	DEFC 	BUGFIX7_ENABLED = 1
	PUBLIC 	BUGFIX7_ENABLED
	DEFC 	BUGFIX7_BYTES = $ - INFINEFIX
	PUBLIC 	BUGFIX7_BYTES
#ENDIF
;
; ----------------------------------------------------------------------
; BUGFIX7C - Space after TAB keyword
; ----------------------------------------------------------------------
;
#IFDEF BUGFIX7C
;
TABERFIX:
	GETCHR			; get next char - RST 10
	cp	')'		; if close bracket
	ret	z		; found closing bracket, continue normally
	dec	hl		; not a closing bracket, so DONT consume it.
	ret
; ----------------------------------------------------------------------
	DEFC 	BUGFIX7C_ENABLED = 1
	PUBLIC 	BUGFIX7C_ENABLED
	DEFC 	BUGFIX7C_BYTES = $ - TABERFIX
	PUBLIC 	BUGFIX7C_BYTES
#ENDIF
;
; ----------------------------------------------------------------------
; BUGFIX11 - Overflow on Integer FOR loop
; ----------------------------------------------------------------------
;
#IFDEF BUGFIX11
;
INTNXTOVER:
	pop	hl		; restore the loop variable pointer (2305)
	pop	hl		; restore the for entry pointer (2309)
	ld	bc,6		; need to consume 6 more bytes off the stack
	add	hl,bc		; which is passed as HL into the next routine
	jp	LOOPDN		; Normal NEXT completion of loop
; ----------------------------------------------------------------------
	DEFC 	BUGFIX11_ENABLED = 1
	PUBLIC 	BUGFIX11_ENABLED
	DEFC 	BUGFIX11_BYTES = $ - INTNXTOVER
	PUBLIC 	BUGFIX11_BYTES
#ENDIF
;
; ======================================================================
	DEFC	R1FREE	= $02B2 - $
	PUBLIC	R1FREE
	DEFS	$02B2 - $
; ======================================================================
;
; ----------------------------------------------------------------------
; 02B2 – LEVEL II BASIC SYSTEM ROUTINE – “SYSTEM”
; ----------------------------------------------------------------------
SYSTEM:	call	SYSOUT		;02b2 - Call the DOS exit for system command at 41E2H.
	ld	sp,SYSSTK	;02b5 - Set the STACK pointer to the assumed load address.
	; This location passes control to the routine used by the BASIC command SYSTEM.
	call	CRDO		;02b8 - display a carriage return on the video display
	ld	a,'*'		;02bb
	call	OUTDO		;02bd - Display a * character on the video display.
	call	QINLIN		;02c0 - get the input from the keyboard
	jp	c,RESETR	;02c3 - If BREAK key, JMP 06CC entry. BUG 29
	GETCHR			;02c6 - rst 10h - first byte of user input
	jp	z,SNERR		;02c7 - if no input then a syntax error
	cp	'/'		;02ca - check for a slash command
;
; Rest of SYSTEM Code was removed/changed to remove cassette functionality
; Code below was moved up (see original addresses), and modified slightly
;
	jp	nz,SNERR	;IF NOT a "/" command then a syntax error
GODO:	GETCHR			;0322 - rst 10h
	call	LINGET		;0323 - Convert to ascii string
	jr	nz,SYSTEM	;0326 - if no address defined Display * prompt
	ex	de,hl		;0328 - execution address into HL
	jp	(hl)		;0329 - jump to execution address
;
; ======================================================================
; ROM REGION 2 - (02D7 - 0329) - System
; ======================================================================
;
;
; ======================================================================
	DEFC	R2FREE	= $032A - $
	PUBLIC	R2FREE
	DEFS	$032A - $
; ======================================================================
;
; ----------------------------------------------------------------------
; 032AH-0347H – OUTPUT ROUTINE – “OUTCH1” and “OUTDO”
;   This is a general purpose output routine which outputs a byte from
;   the A Register to video, tape or printer. In order to use it,
;   the location 409CH must be loaded with -1 tape, 0 video, or 1 for printer.
; ----------------------------------------------------------------------
OUTDO:	push	bc		;032a
	ld	c,a		;032b - Save the character
	call	EXOUTC		;032c - DOS EXIT for character output
	ld	a,(PRTFLG)	;032f - get the current Device
	or	a		;0332 - set the flags
	ld	a,c		;0333 - get the character back into A
	pop	bc		;0334
	ret	m		; If cassette skip the write return immediately
	NOP2
	jr	nz,OUTLPT	;0338 - if it is Printer
; ----------------------------------------------------------------------
; 033AH-0347H – OUTPUT ROUTINE – “OUT2D”
;   A Print routine which performs the same function as 33H except
;   that it doesn’t destroy the contents of the DE Register Pair.
;   All the general purpose registers are saved, which is often desirable
; ----------------------------------------------------------------------
OUT2D:	push	de		;033a
	call	_DSP		;033b
	push	af		;033e
	call	DSPPOS		;033f - Compute Line pos based on Vid Ram Cursor
	ld	(TTYPOS),a	;0342 - store current line pos
	pop	af		;0345
	pop	de		;0346
	ret			;0347
; ----------------------------------------------------------------------
; 0348H-0357H – VIDEO ROUTINE – “DSPPOS”
;   Works out horizontal cursor position based on (CURSOR) vid ram pointer
; ----------------------------------------------------------------------
DSPPOS:	ld	a,(CAST)	;0348 - get shadow copy of cassette port
	and	CAST32		;034b - mask of the 32 char mode bit
	ld	a,(CURSOR)	;034d - LSB of the current cursor position
	jr	z,NT32PS	;0350 - 64 characters per line mode?
	rrca			;0352 - divide by 2
	and	$1F		;0353 - Mask cursor position for 32 character
NT32PS:	and	$3F		;0355 - Mask cursor position for 64 character
	ret			;0357
; ----------------------------------------------------------------------
; 0358H-0360H – KEYBOARD ROUTINE – “ISCHAR”
;   Here is the routine to simulate the INKEY$ function. It performs exactly
;   the same function as 2BH but it restores all registers, whereas 2BH
;   destroys the DE Register Pair. This makes 35BH more useful than 2BH
; ----------------------------------------------------------------------
ISCHAR:	call	EXINC		;0358
	push	de		;035b
	call	_KBD		;035c
	pop	de		;035f
	ret			;0360
;
; ======================================================================
; 0361H – INPUT ROUTINE – “INLIN”
;
;   This is one of the general purpose input routines (see 5D9 and 1BB3 also).
;   This routine inputs a string from the keyboard, up to 240 characters,
;   and echoes them to the screen. It puts this data into a buffer located
;   at the address pointed to by the buffer pointer at 40A7H
; ----------------------------------------------------------------------
INLIN:	xor	a		;0361
	ld	(CHARC),a	;0362
	ld	(TTYPOS),a	;0365
	call	INLINE		;0368 - Go call the DOS link at 41AFH
	push	bc		;036b
	ld	hl,(BUFPNT)	;036c - starting address of the input buffer
	ld	b,240		;036f - length of the input buffer
	call	KEYIN		;0371 - keyboard input routine, until a CR, a BREAK
	push	af		;0374
	ld	c,b		;0375 - Move lenght of Input to C
	ld	b,0		;0376 - zero B, so BC has has lenght of Input
	add	hl,bc		;0378 - end of the Input
	ld	(hl),$00	;0379 - Save an end of the input terminator
	ld	hl,(BUFPNT)	;037b - back to start of the input buffer
	pop	af		;037e
	pop	bc		;037f
	dec	hl		;0380 - Decrement the input buffer pointer
	ret	c		;0381 - Return if the BREAK key was pressed
	xor	a		;0382 - Signal success
	ret			;0383
; ----------------------------------------------------------------------
; 0384H-038AH – KEYBOARD ROUTINE – “INCHR”
;   Waits for keypress
; ----------------------------------------------------------------------
INCHR:	call	ISCHAR		;0384
	or	a		;0387
	ret	nz		;0388
	jr	INCHR		;0389
; ----------------------------------------------------------------------
; 038BH-039BH – PRINTER ROUTINE – “FINLPT”
; ----------------------------------------------------------------------
FINLPT:	xor	a		;038b - DEV0VID
	ld	(PRTFLG),a	;038c - set current output device VIDEO
	ld	a,(LPTPOS)	;038f
	or	a		;0392
	ret	z		;0393
	ld	a,ENTER		;0394
	push	de		;0396
	call	OUTLPT		;0397
	pop	de		;039a
	ret			;039b
;
; =====================================================================
; 039CH-03C1H – PRINTER ROUTINE – “OUTLPT”
;
;  This is the LPRINT routine. All registers are saved.
;  The byte to be printed should be in the A register
; ----------------------------------------------------------------------
OUTLPT:	push	af		;039c
	push	de		;039d
	push	bc		;039e
	ld	c,a		;039f
	ld	e,$00		;03a0
	cp	FORMF		;03a2
	jr	z,LZRPOS	;03a4
	cp	LINEF		;03a6
	jr	nz,LZRNOT	;03a8
	ld	a,ENTER		;03aa
	ld	c,a		;03ac
LZRNOT:	cp	ENTER		;03ad
	jr	z,LZRPOS	;03af
	ld	a,(LPTPOS)	;03b1
	inc	a		;03b4
	ld	e,a		;03b5
LZRPOS:	ld	a,e		;03b6
	ld	(LPTPOS),a	;03b7
	ld	a,c		;03ba
	call	_PRT		;03bb
	pop	bc		;03be
	pop	de		;03bf
	pop	af		;03c0
	ret			;03c1
;
; ----------------------------------------------------------------------
; 03C2H-03E2H – DRIVER ENTRY ROUTINE – “CIO”
;   This routine is called from a RST 14 GET (with a device code of 01H in
;   Register B), RST 1C PUT (with a device code of 02H in Register B),
;   and RST 24 CTL (with a device code of 04H in Register B).
; ----------------------------------------------------------------------
CIO:	push	hl		;03c2 - Save HL, IX, DE registers on the stack
	push	ix		;03c3
	push	de		;03c5 - starting address of Device Drive
	pop	ix		;03c6 - moved from DE to IX via the stack
	push	de		;03c8
	ld	hl,CIORTN	;03c9 - return address for device driver call
	push	hl		;03cc - return address pushed to stack
	ld	c,a		;03cd - put character to process into C
	ld	a,(de)		;03ce - device type code from the DCB
	and	b		;03cf - Isolate device code bits, using B parameter
	cp	b		;03d0 - check for equality with passed device type
	jp	nz,CIOSS	;03d1 - if not same - jump to DOS device Driver (4033)
	cp	$02		;03d4 - clear status flags
	ld	l,(ix+1)	;03d6 - LSB of driver address
	ld	h,(ix+2)	;03d9 - MSB of driver address
	jp	(hl)		;03dc - Jump (and ret) to the driver address in HL
;
; Device driver returns here
CIORTN:	pop	de		;03dd - restore registers from the stack
	pop	ix		;03de - which were pushed in CIO code above
	pop	hl		;03e0
	pop	bc		;03e1 - restore BC, pushed before jump to CIO
	ret			;03e2
;
; ======================================================================
; 03E3H-0457H – KEYBOARD DRIVER – “KEY”
;
;   This is the keyboard driver. It scans the keyboard and converts
;   the bit pattern obtained to ASCII and stores it in the A register.
; ----------------------------------------------------------------------
KBDDRV:	ld	hl,KYBTSS	;03e3
	ld	bc,kbdmatrix+$01;03e6 - first keyboard matrix row
	ld	d,$00		;03e9
KEYLP:	ld	a,(bc)		;03eb
	ld	e,a		;03ec
	xor	(hl)		;03ed
	ld	(hl),e		;03ee
	and	e		;03ef
	jr	nz,KEYDWN	;03f0
	inc	d		;03f2
	inc	l		;03f3
	rlc	c		;03f4
	jp	p,KEYLP		;03f6
	ret			;03f9
; ----------------------------------------------------------------------
; 03FAH-040AH – Accept a KB Downstroke and Convert it to ASCII – “KEYDWN”
; ----------------------------------------------------------------------
KEYDWN:	ld	e,a		;03fa
;
#IFDEF KEYBOUNCE
;
        jp	KEYBOU		;03fb jump to the new keyboard debounce routine.
KYDRES:				;03fe return address for keybounce
;
#ELSE
	ld	a,d		;03fb
	rlca			;03fc
	rlca			;03fd
#ENDIF
;
	rlca			;03fe
	ld	d,a		;03ff
	ld	c,$01		;0400
KEYDLP:	ld	a,c		;0402
	and	e		;0403
	jr	nz,KEYFND	;0404
	inc	d		;0406
	rlc	c		;0407
	jr	KEYDLP		;0409
; ----------------------------------------------------------------------
; 040BH-0428H – Part of the Keyboard routine – “KEYFND”
;   We now have identified the key. Next we need to see if it is shifted
; ----------------------------------------------------------------------
KEYFND:	ld	a,(kbdmatrix+$80);040b - value of the SHIFT key from 3880H
	ld	b,a		;040e
	ld	a,d		;040f
	add	a,$40		;0410
	cp	$60		;0412
	jr	nc,KEYNAL	;0414
	rrc	b		;0416
	jr	nc,KEYRTN	;0418
	add	a,$20		;041a
	ld	d,a		;041c
	ld	a,(kbdmatrix+$40);041d - value at keyboard memory row six
	and	$10		;0420
	jr	z,KEYRT2	;0422
	ld	a,d		;0424
	sub	$60		;0425
	jr	KEYRTN		;0427
; ----------------------------------------------------------------------
; 0429H-043CH – Part of the Keyboard routine – “KEYNAL”
;    If we are here, the character was not alphanumeric,
;    so need to check for special and/or shift
; ----------------------------------------------------------------------
KEYNAL:	sub	$70		;0429
	jr	nc,KEYSPL	;042b
	add	a,$40		;042d
	cp	$3C		;042f
	jr	c,KEYINV	;0431
	xor	$10		;0433
KEYINV:	rrc	b		;0435
	jr	nc,KEYRTN	;0437
	xor	$10		;0439
	jr	KEYRTN		;043b
; ----------------------------------------------------------------------
; 043DH-044AH – Part of the Keyboard routine – “KEYSPL”
;   This routine does a special key conversion via a table
; ----------------------------------------------------------------------
KEYSPL:	rlca			;043d
	rrc	b		;043e
	jr	nc,KEYNSF	;0440
	inc	a		;0442
KEYNSF:	ld	hl,KEYTAB	;0443
	ld	c,a		;0446
	ld	b,$00		;0447
	add	hl,bc		;0449
	ld	a,(hl)		;044a
; ----------------------------------------------------------------------
; 044BH-044BH – Part of the Keyboard routine – “KEYRTN”
;   This routine will debounce the keyboard downstroke and return
; ----------------------------------------------------------------------
KEYRTN:	ld	d,a		;044b - save value for the key pressed from A
KEYRT2:	ld	bc,3500		;044c - delay count (3500)
	call	DELAY		;044f - delay about 51.3 ms
	ld	a,d		;0452 - restore value for the key pressed
	cp	$01		;0453 - Check to see if the BREAK key was pressed
	ret	nz		;0455 - Return if the BREAK key wasn’t pressed
	rst	28h		;0456
	ret			;0457
;
; ======================================================================
; 0458H-058CH – VIDEO DISPLAY DRIVER – “DSPDRV”
;
;   This is the video driver. On entry, the character to be displayed
;   should be in the C register. On exit, A would contain the character
;   at the cursor (if called for an INPUT). This routine handles scrolling etc.
;
;   Register IX points to the DCB, so
;   IX+0 = the DCB type,
;   IX+1 = LSB of the Driver Address, IX+2 = MSB of the Driver Address,
;   IX+3 = LSB of the Cursor Position, IX+4 = MSB of the Cursor Position,
;   IX+5 = Cursor Character, cursor on off flag
;   IX+6 = “D”, and IX+7=”O”
; ----------------------------------------------------------------------
DSPDRV:
	ld	l,(ix+3)	;0458 - LSB of the current cursor position
	ld	h,(ix+4)	;045b - MSB of the current cursor position
	jr	c,DSPRD		;045e - Jump if get last character
	ld	a,(ix+5)	;0460 - cursor on/off flag
	or	a		;0463 - set flags
	jr	z,DSPGRP	;0464 - Jump if the cursor is off
	ld	(hl),a		;0466 - Display the character under the cursor
DSPGRP:	ld	a,c		;0467 - convert and display the charater
	cp	SPACE		;0468 - is it a control code <$20
	jp	c,DSPCTL	;046a - display control code
	cp	$80		;046d - is it a graphic >= $80
	jr	nc,DSPGRC	;046f - display graphic
#IFDEF LOWCASE
	jr	DSPCHR		;0471 - Disable all Alpha CHR translation
	DEFC 	LOWCASE_ENABLED = 1
	PUBLIC 	LOWCASE_ENABLED
	DEFS	$047D - $	;UNUSED Fill Deleted code bock (ELSE) with NOP's
#ELSE
	cp	$40		;0471 - is it number or symbol ASCII 20h - 40h
	jr	c,DSPCHR	;0473 - then display it
	sub	$40		;0475 - So now upper case A is 01h
	cp	$20		;0477 - is it upper case case
	jr	c,DSPCHR	;0479 - display it
	sub	$20		;047b - convert from lower to upper case
#ENDIF
;
; Output the character, it is not a control character, tab, or special characters
;
DSPCHR:	call	DSPOUT		;047d - Display the character in A (and scroll if necessary)
;
; Completion of the Display Routines, after characters have been printed.
;
DSPSKP:	ld	a,h		;0480 - the MSB of the current cursor position
	and	$03		;0481 - Convert Cursor Pos to Vid Mem Address, clear upper bits.
	or	$3C		;0483 - then force the MSB to be 3C-3Fh (Vid Ram)
	ld	h,a		;0485 - save it back.
	ld	d,(hl)		;0486 - get the value at the location of the cursor
	ld	a,(ix+5)	;0487 - cursor on off flag
	or	a		;048a - Check to see if the cursor is on or off
	jr	z,DSPRTN	;048b - Jump if the cursor is off
	ld	(ix+5),d	;048d - cursor is on, save the character being displayed as the flag
	ld	(hl),CURCHR	;0490 - Display the cursor character
DSPRTN:	ld	(ix+3),l	;0492 - Save LSB of current cursor position
	ld	(ix+4),h	;0495 - Save MSB of current cursor position
	ld	a,c		;0498 - the character that was displayed
	ret			;0499
; ----------------------------------------------------------------------
; 049AH – Read the character at the current position of the display – “DSPRD”
; ----------------------------------------------------------------------
DSPRD:	ld	a,(ix+5)	;049a - the cursor on/off flag
	or	a		;049d - Check to see if the cursor is on or off
	ret	nz		;049e - RET if cursor is on and covering the character
	ld	a,(hl)		;049f - If cursor off, get char at the current cursor position
	ret			;04a0
; ----------------------------------------------------------------------
; 04A1H – Go to the beginning of the line – “DSPBOL”
; ----------------------------------------------------------------------
DSPBOL:	ld	a,l		;04a1 - the LSB of the current position
	and	$C0		;04a2 - point to the beginning of the line, zero the lowest 6 bits
	ld	l,a		;04a4 - save it back
	ret			;04a5
; ----------------------------------------------------------------------
; 04A6H – Handle graphic (NON ASCII) characters – “DSPHRC”
;   Called for characters $80 - $FF
; ----------------------------------------------------------------------
DSPGRC:	cp	$C0		;04a6 - check for Space compression Character
	jr	c,DSPCHR	;04a8 - It is Not. It is normal graphic, so display graphic
	sub	$C0		;04aa - convert into the number of spaces to display
	jr	z,DSPSKP	;04ac - $C0 means display 0 spaces, so Finish
	ld	b,a		;04ae - load the number of spaces to print
; ----------------------------------------------------------------------
; 04AFH – Handle Space Compression characters – “DSPSPC”
; ----------------------------------------------------------------------
DSPSPC:	ld	a,SPACE		;04af - a space character
	call	DSPOUT		;04b1 - Display It
	djnz	DSPSPC		;04b4 - Dec B, If more spaces then loop back
	jr	DSPSKP		;04b6 - Finish Off
; ----------------------------------------------------------------------
; 04B8H – Turn the cursor on – “DSPCON”
; ----------------------------------------------------------------------
DSPCON:	ld	a,(hl)		;04b8 - get char at current cursor position
DSPCN2:	ld	(ix+5),a	;04b9 - save it as the cursor on/off flag
	ret			;04bc
; ----------------------------------------------------------------------
; 04BDH – Turn the cursor off – “DSPCOF”
; ----------------------------------------------------------------------
DSPCOF:	xor	a		;04bd - clear the flag to ZERO, indicating No cursor
	jr	DSPCN2		;04be - save the Flag, and return
; ----------------------------------------------------------------------
; 04C0H – Home the cursor – “DSPHOM”
; ----------------------------------------------------------------------
DSPHOM:	ld	hl,vidmem	;04c0 - starting address of video memory
	ld	a,(CAST)	;04c3 - Shadow of Cassette Port
	and	~CAST32		;04c6 - turn off the 32 char mode bit
	ld	(CAST),a	;04c8 - save shadow copy
	out	(vidcmt),a	;04cb - write to the cassette port
	ret			;04cd
;
; ----------------------------------------------------------------------
; 04CEH – Backspace – “DSPBSP”
; ----------------------------------------------------------------------
DSPBSP:	dec	hl		;04ce - move cursor back 1 character
	ld	a,(CAST)	;04cf - get shadow copy of Cassette port
	and	CAST32		;04d2 - check for 32 char mode
	jr	z,DSPBS2	;04d4 - 64 char mode sip forward
	dec	hl		;04d6 - back again if 32 char mode
DSPBS2:	ld	(hl),SPACE	;04d7 - Clear the character under cursor
	ret			;04d9
; ----------------------------------------------------------------------
; 04DAH – Cursor Left – “DSPLFT”
; ----------------------------------------------------------------------
DSPLFT:	ld	a,(CAST)	;04da - get shadow copy of Cassette port
	and	CAST32		;04dd - check for 32 char mode
	call	nz,DSPLF2	;04df - if 32 char mode, move back twice
DSPLF2:	ld	a,l		;04e2 - get the lower order address
	and	$3F		;04e3 - mask 64 char line for RET below
	dec	hl		;04e5 - move back 1
	ret	nz		;04e6 - Return if still on the same line
;
; ----------------------------------------------------------------------
; 04E7H – Cursor Down – “DSPDWN”
;  This is a space saver because if the cursor isn’t on the same line
;  it needs to move down, so jumping here is also jumping to a CURSOR DOWN
;  routine that was simply a fall-through from a wrap around
; ----------------------------------------------------------------------
DSPDWN:	ld	de,vidlin	;04e7 - 1 line of 64 characters
	add	hl,de		;04ea - add to the cursor position
	ret			;04eb
; ----------------------------------------------------------------------
; 04ECH – Cursor Right – “DSPRHT”
; ----------------------------------------------------------------------
DSPRHT:	inc	hl		;04ec - advance the cursor
	ld	a,l		;04ed - LSB of the current cursor position
	and	$3F		;04ee - Mask out the upper bits
	ret	nz		;04f0 - Return if cursor still on the same line
; ----------------------------------------------------------------------
; 04F1H – Cursor Up – “DSPUP”
;  Same trick as dealing with CURSOR DOWN if there was an overflow,
;  this does a CURSOR UP if you back up too far
; ----------------------------------------------------------------------
DSPUP:	ld   de,$10000-vidlin	;04f1 - negative video line length (-64)
	add	hl,de		;04f4 - subtract 64 from current position
	ret			;04f5
; ----------------------------------------------------------------------
; 04F6H – Set up 32-Character mode – “DSPETB”
; ----------------------------------------------------------------------
DSPETB:
	ld	a,(CAST)	;04f6 - get shadow copy of Cassette port
	or	CAST32		;04f9 - Set the 32 Char mode bit
	ld	(CAST),a	;04fb - save shadow copy of cassette port
	out	(vidcmt),a	;04fd - output setting the HW register
	inc	hl		;0500 - Increment the current cursor position
	ld	a,l		;0501 - get lower order byte
	and	$FE		;0502 - mask out the LSB bit, not relevant for 32char
	ld	l,a		;0504 - write it back to L, adjusting cursor position
	ret			;0505
; ----------------------------------------------------------------------
; 0506H – Process control characters – “DSPCTL”
; ----------------------------------------------------------------------
DSPCTL:
	ld	de,DSPSKP	;0506 - Completion of video display routines
	push	de		;0509 - Save the return address on the STACK
	cp	BACKS		;050a - is a backspace 08h
	jr	z,DSPBSP	;050c - then process a backspace
	cp	LINEF		;050e - is less than a line feed 0A character
	ret	c		;0510 - then nothing further to check
	cp	CURON		;0511 - compare with cursor on 0Eh
	jr	c,DSPCR		;0513 - process a CR/LF which is 0Dh
	jr	z,DSPCON	;0515 - process a cursor on.
	cp	CUROFF		;0517 - cursor off
	jr	z,DSPCOF	;0519
	cp	MODE32		;051b - turn on the 32 character per line mode
	jr	z,DSPETB	;051d
	cp	ARLEFT		;051f - move cursor left
	jr	z,DSPLFT	;0521
	cp	ARIGHT		;0523 - move cursor right
	jr	z,DSPRHT	;0525
	cp	ARDOWN		;0527 - move cursor down
	jr	z,DSPDWN	;0529
	cp	ARUP		;052b - move cursor up
	jr	z,DSPUP		;052d
	cp	CHOME		;052f - cursor home, top left
	jr	z,DSPHOM	;0531
	cp	CLINE		;0533 - cursor to SOL
	jp	z,DSPBOL	;0535
	cp	ELINE		;0538 - erase to EOL
	jr	z,DSPEOL	;053a
	cp	CLRKEY		;053c - erase to EOF
	jr	z,DSPEOF	;053e
	ret			;0540
; ----------------------------------------------------------------------
; 0541H – Part of the Display routine – “DSPOUT”
;   Output the character held in Register A and move the cursor,
;   scrolling the screen if necessary
;   HL contains the current screen address
; ----------------------------------------------------------------------
DSPOUT:
	ld	(hl),a		;0541 - write the character to video ram
	inc	hl		;0542 - next screen position
	ld	a,(CAST)	;0543 - cassette port shadow byte
	and	CAST32		;0546 - mask out 32 char mode bit
	jr	z,DSPOT2	;0548 - if not 32 character mode, skip over
	inc	hl		;054a - Skip another screen location (32 char)
DSPOT2:
	ld	a,h		;054b
	cp	$40		;054c - past end of screen at (4000h)
	ret	nz		;054e - nothing to do
	ld	de,$FFC0	;054f - => -64, ie one line of characters
	add	hl,de		;0552 - move cursor back one line
	push	hl		;0553
; ----------------------------------------------------------------------
; 0554H – Part of the Display routine – “DSPROL”
;   Scroll the screen upward by one line
; ----------------------------------------------------------------------
DSPROL:	ld	de,vidmem	;0554 - starting address of video memory (3C00h)
	ld   hl,vidmem+vidlin	;0557 - second line of vid memory
	push	bc		;055a - Save BC
	ld	bc,15*vidlin	;055b - 15 Lines of Video Memory
	ldir			;055e - MOVE 15 LINES OF VIDEO MEMORY UP ONE LINE
	pop	bc		;0560 - Restore BC
	ex	de,hl		;0561
	jr	DSPERF		;0562 - clear the last line
; ----------------------------------------------------------------------
; 0564H – Part of the Display routine – “DSPCR”
;   Display a carriage return / line feed
; ----------------------------------------------------------------------
DSPCR:	ld	a,l		;0564 - LSB of the current cursor position
	and	$C0		;0565 - make it’s at the start of the current line
	ld	l,a		;0567 - put the value back.
	push	hl		;0568 - Save current cursor position
	ld	de,vidlin	;0569 - length of video display line (64 chars)
	add	hl,de		;056c - add line to current cursor pos
	ld	a,h		;056d - MSB of the current cursor position
	cp	$40		;056e - is past end of video memory (+1)
	jr	z,DSPROL	;0570 - if past the end, scroll the screen
	pop	de		;0572 - Throw away saved cursor position
; ----------------------------------------------------------------------
; 0573H – Part of the Display routine – “DSPEOL”
;   Erase to the end of the line
; ----------------------------------------------------------------------
DSPEOL:	push	hl		;0573 - Save cursor position on the STACK
	ld	d,h		;0574 - MSB of the current cursor position
	ld	a,l		;0575 - LSB of the current cursor position
	or	$3F		;0576 - Set he EOL by setting the lower bits
	ld	e,a		;0578 - EOL of the current line
	inc	de		;0579 - starting character of next line
	jr	DSPERA		;057a - blank to address in DE, and return
; ----------------------------------------------------------------------
; 057CH – Part of the Display routine – “DSPEOF”
;   Erase to the end of the frame. clear the video screen from (including)
;   position N – where N is an integer between 0 and 1023 (decimal),
;   inclusive, to the end of the display, Load the HL Register with the
;   value 3C00H + N and then CALL DSPEOF
; ----------------------------------------------------------------------
DSPEOF:	push	hl		;057c - Save cursor position on the STACK
DSPERF:	ld      de,vidmem+1024  ;057d - end of video memory (4000H)
DSPERA:	ld	(hl),SPACE	;0580 - write a space to cursor
	inc	hl		;0582 - next position
	ld	a,h		;0583 - MSB of the video memory pointer
	cp	d		;0584 - compare with end of VID ram ($40)
	jr	nz,DSPERA	;0585 - Loop back if not finished
	ld	a,l		;0587 - LSB of the video memory pointer
	cp	e		;0588 - compare with end of VID ram ($0)
	jr	nz,DSPERA	;0589 - Loop back if not finished
	pop	hl		;058b - retrieve the saved cusor position
	ret			;058c
;
; ======================================================================
; 058DH – PRINTER DRIVER – “PRT”
;
;   This is the Printer Driver. On entry, Register C to hold the character
;   to be sent to the printer, and [IX] should point to the DCB,
; ----------------------------------------------------------------------
PRTDRV:	ld	a,c		;058d
	or	a		;058e
	jr	z,PRTSTA	;058f - If char=0 then get the printer status and return
	cp	VERTAB		;0591 - is a skip to the top of the form Vertical Tab
	jr	z,PRTVT		;0593 - Jump if it is a Vertical Tab
	cp	FORMF		;0595 - is conditional skip to the top of the form Form Feed
	jr	nz,PRTIT	;0597 - if not form feed - jump and print char
	xor	a		;0599
	or	(ix+3)		;059a
	jr	z,PRTIT		;059d - Jump if zero lines are to be skipped
PRTVT:	ld	a,(ix+3)	;059f - number of lines on the page
	sub	(ix+4)		;05a2 - number of lines printed
	ld	b,a		;05a5 - number of lines left to print
PRTFF:	call	PRTSTA		;05a6 - Call the GET PRINTER STATUS routine
	jr	nz,PRTFF	;05a9 - Loop back until the printer is ready
	ld	a,LINEF		;05ab - We print line feed character(s)
#IFNDEF EACA80
	ld	(prtstat),a	;05ad - Send the character to the printer port 37E8H
#ELSE
	nop			;05ad
	out	(prtport),a	;05ae - On Dick Smith System-80 (EACA) use IO port
#ENDIF
	djnz	PRTFF		;05b0 - Loop back until all of the lines have been skipped
	jr	PRTOP		;05b2 - all lines skipped, reset the line counter and ret
; ----------------------------------------------------------------------
; Printing of normal character starts here
; ----------------------------------------------------------------------
PRTIT:	push	af		;05b4
PRTIT2:	call	PRTSTA		;05b5 - Call the GET PRINTER STATUS routine
	jr	nz,PRTIT2	;05b8 - Loop back until the printer is ready
	pop	af		;05ba
#IFNDEF EACA80
	ld	(prtstat),a	;05ad - Send the character to the printer port 37E8H
#ELSE
	nop			;05bb
	out	(prtport),a	;05bc - On Dick Smith System-80 (EACA) use IO port
#ENDIF
	cp	ENTER		;05be
	ret	nz		;05c0
	inc	(ix+4)		;05c1
	ld	a,(ix+4)	;05c4
	cp	(ix+3)		;05c7
	ld	a,c		;05ca
	ret	nz		;05cb
PRTOP:	ld	(ix+4),0	;05cc
	ret			;05d0
;
; ======================================================================
; 05D1H – Get printer status routine – “PRTSTA”
;
;   Returns the status of the line printer in the status register as
;   zero if the printer is ready, and non-zero if not ready.
; ----------------------------------------------------------------------
PRTSTA:
#IFNDEF EACA80
	ld	a,(prtstat)	;05d1 - Get the status value from the printer (37E8H)
#ELSE
	nop			;05d1
	in	a,(prtport)	;05d2 - On Dick Smith System-80 (EACA) use IO port
#ENDIF
	and	$F0		;05d4
	cp	$30		;05d6
	ret			;05d8
;
; ======================================================================
; 05D9H – Wait For Next Line – “KEYIN”
;
;   Accepts keyboard input and stores each character in a
;   buffer supplied by caller. Input continues until either a
;   carriage return or a BREAK is typed, or until the buffer is
;   full. All edit control codes are recognized, e.g. TAB,
;   BACKSPACE, etc. The calling sequence is: On exit the
;   registers contain
;
;   On exit the registers contain: HL=Buffer address, B=num chars transmitted
;   excluding last, C=Orginal buffer size, A=Last character received
;   if a carriage return or BREAK is typed.
;   Carry Set if break key was terminator, reset otherwise.
;   If the buffer is full, the A Register will contain the buffer size.
; ----------------------------------------------------------------------
KEYIN:	push	hl		;05d9
	ld	a,CURON		;05da - turn on the cursor character
	call	_DSP		;05dc
	ld	c,b		;05df
KLNNXT:	call	_KEY		;05e0
	cp	SPACE		;05e3
	jr	nc,KLNCHR	;05e5
	cp	ENTER		;05e7 - ENTER
	jp	z,KLNCR		;05e9
	cp	CLRKEY		;05ec - CLEAR
	jr	z,KLNCLR	;05ee
	cp	BREAK		;05f0 - BREAK
	jr	z,KLNBRK	;05f2
	ld	de,KLNNXT	;05f4
	push	de		;05f7
	cp	BACKS		;05f8 - Backspace (left arrow)
	jr	z,KLNBSP	;05fa
	cp	ARLEFT		;05fc - Shifted left arrow
	jr	z,KLNCAN	;05fe
	cp	TAB		;0600 - TAB (right arrow)
	jr	z,KLNHT		;0602
	cp	ARIGHT		;0604 - Shifted Right Arrow
	jr	z,KLNETB	;0606
	cp	LINEF		;0608
	ret	nz		;060a
	pop	de		;060b
; ----------------------------------------------------------------------
; Printable Character
; ----------------------------------------------------------------------
KLNCHR:	ld	(hl),a		;060c
	ld	a,b		;060d
	or	a		;060e
	jr	z,KLNNXT	;060f
	ld	a,(hl)		;0611
	inc	hl		;0612
	call	_DSP		;0613
	dec	b		;0616
	jr	KLNNXT		;0617
; ----------------------------------------------------------------------
; 0619H – Part of the Display routine – “KLNCLR”
;   Clear the screen
; ----------------------------------------------------------------------
KLNCLR:	call	CLS		;0619
	ld	b,c		;061c
	pop	hl		;061d
	push	hl		;061e
	jp	KLNNXT		;061f
; ----------------------------------------------------------------------
; 0622H – Part of the Display routine – “KLNCNL”
;   Cancel the accumulated line
; ----------------------------------------------------------------------
KLNCNL:	call	KLNBSP		;0622
	dec	hl		;0625
	ld	a,(hl)		;0626
	inc	hl		;0627
	cp	LINEF		;0628
	ret	z		;062a
KLNCAN:	ld	a,b		;062b
	cp	c		;062c
	jr	nz,KLNCNL	;062d
	ret			;062f
; ----------------------------------------------------------------------
; 0630H – Part of the Display routine – “KLNBSP”
;   Backspace one character. On entry Register B to hold the number
;   of characters received, and Register C to hold the size of the buffer
; ----------------------------------------------------------------------
KLNBSP:	ld	a,b		;0630
	cp	c		;0631
	ret	z		;0632
	dec	hl		;0633
	ld	a,(hl)		;0634
	cp	LINEF		;0635
	inc	hl		;0637
	ret	z		;0638
	dec	hl		;0639
	ld	a,BACKS		;063a
	call	_DSP		;063c
	inc	b		;063f
	ret			;0640
; ----------------------------------------------------------------------
; 0641H – Part of the Display routine – “KLNETB”
;   Turn on 32 Character Mode
; ----------------------------------------------------------------------
KLNETB:	ld	a,MODE32	;0641 - turn on the 32 character per line mode character
	jp	_DSP		;0643
; ----------------------------------------------------------------------
; 0646H – Part of the Display routine – “KLNHT”
;   Process a horizontal tab
; ----------------------------------------------------------------------
KLNHT:	call	DSPPOS		;0646
	and	$07		;0649
	cpl			;064b
	inc	a		;064c
	add	a,$08		;064d
	ld	e,a		;064f
KLNHTL:	ld	a,b		;0650
	or	a		;0651
	ret	z		;0652
	ld	a,SPACE		;0653
	ld	(hl),a		;0655
	inc	hl		;0656
	push	de		;0657
	call	_DSP		;0658
	pop	de		;065b
	dec	b		;065c
	dec	e		;065d
	ret	z		;065e
	jr	KLNHTL		;065f
; ----------------------------------------------------------------------
; 0661H – Part of the Display routine – “KLNBRK”
;   Process a Carriage Return and Automatic Line Feed
; ----------------------------------------------------------------------
KLNBRK:	scf			;0661
KLNCR:	push	af		;0662
	ld	a,ENTER		;0663
	ld	(hl),a		;0665
	call	_DSP		;0666
	ld	a,CUROFF	;0669 - turn off the cursor character
	call	_DSP		;066b
	ld	a,c		;066e
	sub	b		;066f
	ld	b,a		;0670
	pop	af		;0671
	pop	hl		;0672
	ret			;0673
;
; ----------------------------------------------------------------------
; 0674H-06D1H – INITIALIZATION ROUTINE – "INIT"
;   System initialisation.
;   - Enter with CMT/Video port init value in A.
;     On reset, A=0: 64 char video mode, CMT motor relay off, CMT out = 0.85 V.
; ----------------------------------------------------------------------
INIT:
	out	(vidcmt),a	;0674 - reset the Video cassette latch, A=0
;
INITA1:	ld	hl,INITR	;0676 - starting address of the RST’s and DCB’s
	ld	de,RAM		;0679 - starting address of the RAM comms region
	ld	bc,$36		;067c - move 54 bytes
	ldir			;067f - Move 6D2-707 to 4000-4035
;
#IFDEF FREHDBT
	ld	sp,TMPSTK	; For FreHD - init SP, the line commented @ $0693 below
	nop			; The code being replaced (a delay loop), frehd does anyway
#ELSE
	dec	a		;0681 - count down by 2 starting at 0
	dec	a		;0682 - so effective loop
	jr	nz,INITA1	;0683 - Loop back until block move occurred 128 times
#ENDIF
;
	ld	b,$27		;0685 - 39 bytes of memory need to be zerod
CLRAM:	ld	(de),a		;0687 - zero byte in memory starting at 4036h
	inc	de		;0688 - next address
	djnz	CLRAM		;0689 - loop until filled zero's till 4062h
; ----------------------------------------------------------------------
;  Check for a manual override
; ----------------------------------------------------------------------
	ld	a,(kbdmatrix+$40);068b - value at keyboard BREAK KEY
	and	$04		;068e - if the BREAK key is being pressed
	jp	nz,INIT2	;0690 - Jump if the BREAK key was pressed
;
#IFDEF FREHDBT
	call	HDBOOT		; Call to the FreHD Boot routines.
#ELSE
	ld	sp,TMPSTK	;0693 - $407D since Disk load will overite > $4200
#ENDIF
;
	; Check for a floppy Disk Drive
	ld	a,(diskstat)	;0696 - status of the disk controller (37ECH)
	inc	a		;0699 - FF => 0, 0 => 1
	cp	$02		;069a - is disk controller present.
	jp	c,INIT2		;069c - Jump to Level II Init if no disk controller
;
;   fallthrough for floppy boot
; ----------------------------------------------------------------------
; 069FH-06CBH – Bootstrap from Diskette – "BOOT"
; Now we know (can assume) there is a disk controller and we should boot it.
;
	ASSERT	$ == $069F, "Segment: BOOT (floppy) Entry Point should start at $069F"
; ----------------------------------------------------------------------
;
BOOT:	ld	a,$01		;069f - Drive 0
	ld	(dskselect),a	;06a1 - Select Drive, turning motor on
;
	ld	hl,diskstat	;06a4 - address of the disk command/status Register 37ECH
	ld	de,diskdata	;06a7 - address of the disk data Register (37EFH)
	ld	(hl),$03	;06aa - command 03H (RESTORE and POSITION TO TRACK 0)
	ld	bc,$0000	;06ac
	call	DELAY		;06af - delay (BC times 14.65) about 3 seconds
;
BOOTDL:	bit	0,(hl)		;06b2 - is the diskette controller is busy
	jr	nz,BOOTDL	;06b4 - Wait until it is ready
;
	xor	a		;06b6
	ld	(disksect),a	;06b7 - set the disk sector register with 0
;
#IFDEF NEWBOOT
	ld	a,$8C		;06bd - command to read single IBM formatted sector
	ld	(hl),a		;06bf - send command to FDC register
	JP	NEWBOOTENTRY	; Jump to the New Boot Loop, returns to BOOTRD
#ELSE
	ld	bc,MEMEND	;06ba - 4200H for sector data - MOVED down from above
	ld	a,$8C		;06bd - command to read single IBM formatted sector
	ld	(hl),a		;06bf - send command to FDC register
#ENDIF
;
BOOTLP:	bit	1,(hl)		;06c0 - check to see if there is data available
	jr	z,BOOTLP	;06c2 - loop indefinitely until data ready
;
BOOTRD:	ld	a,(de)		;06c4 - load byte from disk data register
	ld	(bc),a		;06c5 - write byte to ram.
	inc	c		;06c6 - next mem address
	jr	nz,BOOTLP	;06c7 - Loop until whole 256 byte sector has been read
	jp	MEMEND		;06c9 - Hand execution to the boot sector code $4200
;
; ----------------------------------------------------------------------
; 06CCH-06CEH – (Model 1 Only!) - re-entry point into BASIC – "RESETR"
;  This is the best re-entry point to BASIC on the Model I.
;  This is an alternative re-entry point into BASIC.
;  A JP 6CCH is often better than a jump to 1A19H.
; ----------------------------------------------------------------------
	ASSERT	$ == $06CC, "Segment: BASIC Entry Point Should start at $06CC"
RESETR:	ld	bc,STPRDY	;06cc - Address of
	jp	ERESET		;06cf - Jumps to 19AE
; ----------------------------------------------------------------------
; 06D2H-0707H – ROM STORAGE LOCATION FOR DATA TO BE MOVED TO RAM
;   BY THE INITIALIZATION PROCESS – “INITR”
;   Note These $36 bytes are moved to RAM at address $4000 during init
; ----------------------------------------------------------------------
INITR:
; RST Code vectors, each is a 3 byte instruction
	jp	SYNCHR		;4000 (mRST1) - RST 00H
	jp	CHRGTR		;4003 (mRST2) - RST 10H
	jp	DCOMPR		;4006 (mRST3) - RST 18H
	jp	GETYPR		;4009 (mRST4) - RST 20H
	ret			;400C (mRST5) - RST 28H
	NOP2
	ret			;400F (mRST6) - RST 30H
	NOP2
	ei			;4012 (mRST7) - RST 38H (Interrupt)
	ret
	nop
; Keyboard DCB
	DEFB	1		; 4015 (mKDCB) - Device Type = 1 for KB (Read only)
	DEFW	KBDDRV		; 4016 - keyboard driver address
	DEFB	0		; 4017 - Not used on Model 1
	DEFB	0		; 4018 - Not used on Model 1
	DEFB	0		; 4019 - Not used on Model 1
	DEFB	"KI"
; Display DCB
	DEFB	7		; 401D (mDDCB) - Device Type = 7 for VID
	DEFW	DSPDRV		; 401E - DISPLAY driver address
	DEFW	vidmem		; 4020 (CURSOR) - Cursor Position (3C00H to 3FFFH)
	DEFB	0		; 4022 - Character "covered" on video by Cursor
	DEFB	"DO"
; Printer DCB
	DEFB	6		; 4025 (mPDCB) - Device Type = 6 for Printer
	DEFW	PRTDRV		; 4026 - printer driver address
	DEFB	67		; 4028 - lines per page
	DEFB	0		; 4029 - Current Line Number
	DEFB	0		; 402A - Not used on Model 1
	DEFB	"PR"
;
; Normal Disk Operating System re-entry vector.
	jp	$5000		; 402D - MAKE SYS1 (10) DOS REQUEST,
				; typically JP 4400H
; Abnormal DOS re-entry
	rst	00h		; 4030 - DOS REQUEST CODE FOR SYS1
	NOP2			; typically LD A,A3 followed by RST 28
; DOS Device Vectoring Routine
	ld	a, 0		; 4033 (CIOSS) - CALL DOS DEVICE DRIVER (CIOSS)
	ret			; typically will JP 44BBh
;
; ======================================================================
; ======================================================================
;
; LEVEL 2 BASIC ROUTINES $0708 - $2B28
;
#DEFINE	NOCASSETTE ; Removes Cassette Routines - disabled by Revision 4
;
INCLUDE	"LEVEL2BASIC-0708.Z80"
;
ASSERT $ == $2B29, "Segment: Continuation at $2B29"
;
; ======================================================================
; ======================================================================
;
; ----------------------------------------------------------------------
; 2B29-2B2D – LEVEL II BASIC LLIST ROUTINE – “LLIST”
;   This routine sets the output device flag to PRINTER and then
;   flows through to the LIST command.
; ----------------------------------------------------------------------
LLIST:	ld	a,DEV1PRT	;2b29 - the output device code for the printer (1)
	ld	(PRTFLG),a	;2b2b - Save the current output device type number
; ----------------------------------------------------------------------
; 2B2E-2B74 – LEVEL II BASIC LIST ROUTINE – “LIST”
;   On entry the STACK has the return address, then the first basic line
;   number to be listed, then the last basic line number to be listed.
; ----------------------------------------------------------------------
LIST:	pop	bc		;2b2e
	call	SCNLINE		;2b2f
	push	bc		;2b32
LIST4:	ld	hl,$FFFF	;2b33
	ld	(CURLIN),hl	;2b36
	pop	hl		;2b39
	pop	de		;2b3a
	ld	c,(hl)		;2b3b
	inc	hl		;2b3c
	ld	b,(hl)		;2b3d
	inc	hl		;2b3e
	ld	a,b		;2b3f
	or	c		;2b40
	jp	z,READY		;2b41
	call	EXCHDS		;2b44
	call	ISCNTN		;2b47
	push	bc		;2b4a
	ld	c,(hl)		;2b4b
	inc	hl		;2b4c
	ld	b,(hl)		;2b4d
	inc	hl		;2b4e
	push	bc		;2b4f
	ex	(sp),hl		;2b50
	ex	de,hl		;2b51
	CPDEHL			;2b52
	pop	bc		;2b53
	jp	c,STPRDY	;2b54
	ex	(sp),hl		;2b57
	push	hl		;2b58
	push	bc		;2b59
	ex	de,hl		;2b5a
	ld	(DOT),hl	;2b5b
	call	LINPRT		;2b5e
	ld	a,SPACE		;2b61
	pop	hl		;2b63
	call	OUTDO		;2b64
	call	BUFLIN		;2b67
	ld	hl,(BUFPNT)	;2b6a
	call	LISPRT		;2b6d
	call	CRDO		;2b70
	jr	LIST4		;2b73
; ----------------------------------------------------------------------
; 2B75-2B7D – DISPLAY MESSAGE ROUTINE – “LISPRT”
;  Output a string to device indicated by device type flag stored
;  at 409CH. On entry, HL registers must point to address of start of string.
;  String must end with zero byte. Calls routine at 032AH
;  (note warning for that routine)
; ----------------------------------------------------------------------
LISPRT:	ld	a,(hl)		;2b75
	or	a		;2b76
	ret	z		;2b77
	call	OUTDO		;2b78
	inc	hl		;2b7b
	jr	LISPRT		;2b7c
; ----------------------------------------------------------------------
; 2B7E-2BC5 – UNTOKENIZE ROUTINE – “BUFLIN”
; ----------------------------------------------------------------------
BUFLIN:	push	hl		;2b7e
	ld	hl,(BUFPNT)	;2b7f
	ld	b,h		;2b82
	ld	c,l		;2b83
	pop	hl		;2b84
	ld	d,$FF		;2b85
	jr	PLOOP2		;2b87
PLOOP:	inc	bc		;2b89
	dec	d		;2b8a
	ret	z		;2b8b
PLOOP2:	ld	a,(hl)		;2b8c
	or	a		;2b8d
	inc	hl		;2b8e
	ld	(bc),a		;2b8f
	ret	z		;2b90
	jp	p,PLOOP		;2b91
	cp	TKSNQT		;2b94 - single quote token
	jr	nz,NRQTTK	;2b96
	dec	bc		;2b98
	dec	bc		;2b99
	dec	bc		;2b9a
	dec	bc		;2b9b
	inc	d		;2b9c
	inc	d		;2b9d
	inc	d		;2b9e
	inc	d		;2b9f
NRQTTK:	cp	TKELSE		;2ba0 - else token
	call	z,DCXBRT	;2ba2
	sub	$7F		;2ba5
	push	hl		;2ba7
	ld	e,a		;2ba8
	ld	hl,RESLST	;2ba9 - starting address of the reserved words list
LOPRES:	ld	a,(hl)		;2bac
	or	a		;2bad
	inc	hl		;2bae
	jp	p,LOPRES	;2baf
	dec	e		;2bb2
	jr	nz,LOPRES	;2bb3
	and	$7F		;2bb5
MORPUR:	ld	(bc),a		;2bb7
	inc	bc		;2bb8
	dec	d		;2bb9
	jp	z,PPSWRT	;2bba
	ld	a,(hl)		;2bbd
	inc	hl		;2bbe
	or	a		;2bbf
	jp	p,MORPUR	;2bc0
	pop	hl		;2bc3
	jr	PLOOP2		;2bc4
; ----------------------------------------------------------------------
; DELETE
; ----------------------------------------------------------------------
DELETE:	call	SCNLINE		;2bc6
	pop	de		;2bc9
	push	bc		;2bca
	push	bc		;2bcb
	call	FNDLIN		;2bcc
	jr	nc,FCERRG	;2bcf
	ld	d,h		;2bd1
	ld	e,l		;2bd2
	ex	(sp),hl		;2bd3
	push	hl		;2bd4
	CPDEHL			;2bd5
FCERRG:	jp	nc,FCERR	;2bd6
	ld	hl,m_REDDY	;2bd9
	call	STROUT		;2bdc
	pop	bc		;2bdf
	ld	hl,FINI		;2be0
	ex	(sp),hl		;2be3
DELDEL:	ex	de,hl		;2be4
	ld	hl,(VARTAB)	;2be5
MLOOP:	ld	a,(de)		;2be8
	ld	(bc),a		;2be9
	inc	bc		;2bea
	inc	de		;2beb
	CPDEHL			;2bec
	jr	nz,MLOOP	;2bed
	ld	h,b		;2bef
	ld	l,c		;2bf0
	ld	(VARTAB),hl	;2bf1
	ret			;2bf4
;
; ======================================================================
; ROM REGION 3 - (2BF5 - 2CA4) - Cload Csave
; ======================================================================
;
; ----------------------------------------------------------------------
; HDBOOT - FreHD HD bootup routine
; ----------------------------------------------------------------------
#IFDEF FREHDBT
;
HDBOOT:	call	CLS		;0069 - Clear Screen
	call	DELAY		;006c - pause for a few seconds
	ld	a,ROM_MODEL_1	;00ff - ROM parameter to FreHD. 1 for Model1.
        out	(WRITEROM),a	;0101 - write the value
        in	a,(READROM)	;0103 - read response
        cp	0FEh		;0105 - FE is FreHD present and valid code!
        ret	nz		;0107 - return if no FreHD or old firmware
        ld	hl,ROM_LOAD	;0108 - load more "rom" from FreHD
        ld	bc,READROM	;010b - port to read and size counter
        inir			;010e - bulk transfer
        jp	ROM_LOAD	;0110 - jump to loader in RAM, (which may performa RET)
; ----------------------------------------------------------------------
	DEFC 	FREHDBT_ENABLED = 1
	PUBLIC 	FREHDBT_ENABLED
	DEFC 	FREHDBT_BYTES = $ - HDBOOT
	PUBLIC 	FREHDBT_BYTES
#ENDIF
;
; ----------------------------------------------------------------------
; KEYBOUNCE - Routine Added to V1.3 ROMS
; ----------------------------------------------------------------------
#IFDEF KEYBOUNCE
;
KEYBOU:	push	bc		;011C Save Row Address in BC into the STACK
	ld 	bc,$0500	;011D the debounce delay
	call	DELAY		;0120 delay on delay count in BC (18.8 ms)
	pop	bc		;0123 Restore the Row Address back to BC
	ld	a,(bc)		;0124 Reload the original flags from active row
	and	e		;0125 Combine the current flag lists with the original flag bits
	ret	z		;0126 Return to caller if zero because the row was not active on the second test
	ld	a,d		;0127 Otherwise, we have a legitimate active row
	rlca			;0128 Multiply the row index by 2. twice.
	rlca			;0129 This code previously existed at the calling site
	jp	KYDRES		;012A Resume the keyboard driver routine
; ----------------------------------------------------------------------
	DEFC 	KEYBOUNCE_ENABLED = 1
	PUBLIC 	KEYBOUNCE_ENABLED
	DEFC 	KEYBOUNCE_BYTES = $ - KEYBOU
	PUBLIC 	KEYBOUNCE_BYTES
#ENDIF
;
; ----------------------------------------------------------------------
; New diskette Startup routine (CREDIT : JOHN SWIDERSKI)
; clears screen, and allows for break and retries
; ----------------------------------------------------------------------
#IFDEF NEWBOOT
;
NEWBOOTENTRY:
	; If DRQ never appears, wait ~2 seconds then restart BOOT (full re-init).
	ld	bc,$C000	; ~2 second-ish timeout (tune if needed)
;
NB_BOOTLP:
	bit	1,(hl)		; DRQ ready?
	jr	z,NB_BOOTLP1	; no -> continue thru loop
	ld	bc,MEMEND	;06ba - 4200H for sector data
	jp	BOOTRD		; EXIT and return to the main boot process
;
NB_BOOTLP1:
	ld	a,(kbdmatrix+$40) ; check BREAK while waiting
	and	$04		; the BREAK key
	jp	nz,INIT2	; if break, Level2 basic INIT
;
	dec	bc		; countdown until we restart BOOT
	ld	a,b
	or	c
	jr	nz,NB_BOOTLP	; not zero so need to wait, LOOP
;
	; Display the Diskette Message
	ld	hl,DSKMSG	; load Diskette? Message
;
NB_PRTLP:			; Print using OUT2D one character at a time
    	ld  	a,(hl)
    	or  	a
    	jp  	z,BOOT		; if no more chars, EXIT to main boot
    	call 	OUT2D           ; OUT2D prints the char in A (one char)
    	inc 	hl
    	jr  	NB_PRTLP	; loop to next char
;
DSKMSG:
	DEFB	CHOME, ELINE	; Cursor Home, Clear to EOL
	DEFB	"Diskette?",0	; diskette message
;
; ----------------------------------------------------------------------
	DEFC 	NEWBOOT_ENABLED = 1
	PUBLIC 	NEWBOOT_ENABLED
	DEFC 	NEWBOOT_BYTES = $ - NEWBOOTENTRY
	PUBLIC 	NEWBOOT_BYTES
#ENDIF
;
; ======================================================================
	DEFC	R3FREE	= $2CA5 - $
	PUBLIC	R3FREE
	DEFS	$2CA5 - $
; ======================================================================
;
; ======================================================================
; ======================================================================
;
; LEVEL 2 BASIC ROUTINES $2CA5 - $2B28
;
INCLUDE	"LEVEL2BASIC-2CA5.Z80"
;
ASSERT $ == $2FFB, "Segment: Continuation at $2FFB"
;
; ======================================================================
; ======================================================================
;
; 2FFB - 2FFF - ROM VERSION STAMP - Previously unused
	DEFB	0 		; Reserved for CRC injected here
	DEFB	$01, $04	; Identifier Model 1 Rev (1.)4
	DEFB	$26, $01	; DateStamp Year, Week
;
; ======================================================================
; THE END OF THE LEVEL II BASIC ROMS
; ======================================================================
;                END OF CODE
; ======================================================================
;
; Report Free Memory
	DEFC	TOTFREE = R1FREE + R2FREE + R3FREE
	PUBLIC	TOTFREE
; ======================================================================
;
; PADDING to create 16KB ROM Image, to allow append multiple
; versions into a larger (modern) paged ROM file.
;
#IFDEF	SIZE16K
	DEFS	(4000h - $),$FF
#ENDIF
;
; ======================================================================
